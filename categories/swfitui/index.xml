<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SwfitUI on M X</title>
    <link>https://coderxdlee.github.io/categories/swfitui/</link>
    <description>Recent content in SwfitUI on M X</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>M X ©{year}</copyright>
    <lastBuildDate>Sat, 12 Oct 2019 23:25:11 +0800</lastBuildDate>
    
	    <atom:link href="https://coderxdlee.github.io/categories/swfitui/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2.5_如何创建固定尺寸的Spacer</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E7%9A%84spacer/</link>
      <pubDate>Sat, 12 Oct 2019 23:25:11 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E7%9A%84spacer/</guid>
      <description>&lt;p&gt;SwiftUI 的 &lt;code&gt;Spacer&lt;/code&gt; 视图会自动填充其扩展轴上的所有可用空间，这是一种奇特的说法: 即根据我们所放置的内容，它们在水平或垂直方向上会占用尽可能多的空间。&lt;/p&gt;

&lt;p&gt;如果要制作一个精确大小的 &lt;code&gt;Spacer&lt;/code&gt;，则可以执行与其他视图相同的操作: 使用具有所需大小的 &lt;code&gt;frame()&lt;/code&gt; 修饰符。&lt;/p&gt;

&lt;p&gt;例如，这显示了两个文本视图，它们之间有一个50点的空格：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;First Label&amp;quot;)
                .background(Color.red)
            Spacer()
                .frame(height: 50)
            Text(&amp;quot;Second Label&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.5_make_a_fix_spacer.png&#34; alt=&#34;2.5_make_a_fix_spacer.png&#34; title=&#34;Make a fix size spacer view&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.4_如何使用Spacer将视图强制移到堆栈中的一侧</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8spacer%E5%B0%86%E8%A7%86%E5%9B%BE%E5%BC%BA%E5%88%B6%E7%A7%BB%E5%88%B0%E5%A0%86%E6%A0%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BE%A7/</link>
      <pubDate>Sat, 12 Oct 2019 21:27:39 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8spacer%E5%B0%86%E8%A7%86%E5%9B%BE%E5%BC%BA%E5%88%B6%E7%A7%BB%E5%88%B0%E5%A0%86%E6%A0%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BE%A7/</guid>
      <description>

&lt;p&gt;默认情况下，SwiftUI 会将其视图居中，这意味着: 如果将三个文本视图放在 VStack 中，则这三个文本视图将垂直居中显示在屏幕上。如果要更改此设置(如果要强制视图朝向屏幕的顶部/底部/左侧/右侧)，则应使用 &lt;code&gt;Spacer&lt;/code&gt; 视图。&lt;/p&gt;

&lt;h3 id=&#34;1-不使用-spacer&#34;&gt;1. 不使用 Spacer&lt;/h3&gt;

&lt;p&gt;例如，我们将一个文本视图放置在 VStack 内，这意味着它将垂直居中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        
        // 1. 不使用 Spacer
        VStack {
            Text(&amp;quot;Hello World&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_default_without_spacer.png&#34; alt=&#34;2.4_default_without_spacer&#34; title=&#34;Without spacer view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-将文本视图推到父视图的顶部&#34;&gt;2. 将文本视图推到父视图的顶部&lt;/h3&gt;

&lt;p&gt;要将文本视图推到父视图的顶部，我们将在其下面放置一个 &lt;code&gt;Spacer&lt;/code&gt; 视图，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 使用 Spacer 将文本视图推到父视图顶部
        VStack {
            Text(&amp;quot;Hello World&amp;quot;)
            Spacer()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_push_text_to_top.png&#34; alt=&#34;2.4_push_text_to_top&#34; title=&#34;Push text view to super view&#39;s top using spacer view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-在-hstack-中使用-spacer&#34;&gt;3. 在 HStack 中使用 Spacer&lt;/h3&gt;

&lt;p&gt;如果我们希望在 HStack 的前后边缘上有两段文字，可以使用这样的分隔符:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 在 HStack 中使用 Spacer
        HStack {
            Text(&amp;quot;Hello&amp;quot;)
            Spacer()
            Text(&amp;quot;World&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_using_spacer_in_hstack.png&#34; alt=&#34;2.4_using_spacer_in_hstack&#34; title=&#34;Using spacer view in HStack, to seperate two text views&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-多个-spacer-分割空间&#34;&gt;4. 多个 Spacer 分割空间&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Spacer&lt;/code&gt; 会自动分割所有剩余空间，这意味着如果您使用多个 Spacer，则可以按不同数量分割空间。&lt;/p&gt;

&lt;p&gt;例如，这将通过在其上放置一个空格，在其后放置两个空格，将文本视图置于其父视图的三分之一以下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 多个 Spacer 分割空间
        VStack {
            Spacer()
            Text(&amp;quot;Hello world.&amp;quot;)
            Spacer()
            Spacer()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_using_multi_spacer.png&#34; alt=&#34;2.4_using_multi_spacer&#34; title=&#34;Using multi spacer view to divide up all remaining space&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果为 &lt;code&gt;Spacer&lt;/code&gt; 提供一定范围的值，例如使用 &lt;code&gt;.frame（minHeight: 50,maxHeight:500）&lt;/code&gt;，则它将自动占用尽可能多的空间，直到您设置的最大值。 以这种方式添加一些灵活性通常是一个好主意，这样我们的用户界面就可以更轻松地跨设备扩展。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.6_如何使用ForEach在循环中创建视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Fri, 26 Jul 2019 00:21:40 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;p&gt;我们通常会发现，我们需要循环一个序列来创建视图，而在 SwiftUI 中，这是通过 &lt;code&gt;ForEach&lt;/code&gt; 来完成的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;:
我们很容易一看到 &lt;em&gt;ForEach&lt;/em&gt; 就认为它与 Swift 序列中的 &lt;em&gt;forEach()&lt;/em&gt; 方法相同，但事实并非如你所见。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SwiftUI 中的 &lt;code&gt;ForEach&lt;/code&gt; 本身是一个视图结构，这就意味着我们可以根据需要直接从视图 &lt;em&gt;Body&lt;/em&gt; 返回它。&lt;/li&gt;
&lt;li&gt;我们为它提供一系列项目，可能还需要告诉 SwiftUI 它如何唯一地标识每个项目，以便 SwiftUI 知道如何在值更改时更新它们。&lt;/li&gt;
&lt;li&gt;我们还传递一个要运行的闭包，来为循环中的每个项创建一个视图。&lt;/li&gt;
&lt;li&gt;对于范围内的简单循环，您可以将范围直接传递给ForEach。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-循环-1-10-创建文本视图&#34;&gt;1. 循环 1&amp;hellip;10 创建文本视图&lt;/h3&gt;

&lt;p&gt;例如，这从10减少到1然后在最后添加一条消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack(alignment: .leading) {
        ForEach((1...10).reversed()) {
            Text(&amp;quot;\($0)…&amp;quot;)
        }
            
        Text(&amp;quot;Ready or not, here I come!&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foreach_create_views.png&#34; alt=&#34;foreach_create_views&#34; title=&#34;Create views using ForEach&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-foreach-colors&#34;&gt;2. ForEach colors&lt;/h3&gt;

&lt;p&gt;对于简单类型数组（如字符串、整数、颜色等）的循环，可以在数组上使用 &lt;code&gt;.identified(by: \.self)&lt;/code&gt;，让 SwiftUI  使用值本身作为标识符。因此，如果您的数组是 &lt;code&gt;[&amp;quot;cat&amp;quot;, &amp;quot;Dog&amp;quot;, &amp;quot;monkey&amp;quot;]&lt;/code&gt;，那么 SwiftUI 会将这些字符串本身作为您的视图的标识符。
因此，此代码创建一个包含三种颜色的数组，在它们上面循环，并使用每个颜色名称和颜色值创建文本视图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let colors: [Color] = [.red, .green, .blue]
    
var body: some View {
        
    VStack {
        ForEach(colors.identified(by: \.self)) { color in
            Text(color.description.capitalized)
                .padding()
                .background(color)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foreach_colors_array.png&#34; alt=&#34;foreach_colors_array&#34; title=&#34;foreach colors&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-foreach-custom-type&#34;&gt;3. ForEach custom type&lt;/h3&gt;

&lt;p&gt;如果您的数组中有自定义类型，则应使用  &lt;code&gt;.identified(by:)&lt;/code&gt; 与您的类型中的任何属性唯一标识它。
例如，这是一个存储测试结果的结构，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Result {
    var id = UUID()
    var score: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它有一个带有 &lt;code&gt;UUID&lt;/code&gt; 的 &lt;code&gt;id&lt;/code&gt; 属性，这意味着它保证是唯一的 - 完美的用于我们的目的。 如果我们想循环一个结果数组，创建一个显示 &lt;code&gt;VStack&lt;/code&gt; 中每个结果的文本视图，那么我们将使用它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let results = [Result(score: 8), Result(score: 5), Result(score: 10)]
    
var body: some View {
    VStack {
        ForEach(results.identified(by: \.id)) { result in
            Text(&amp;quot;Result: \(result.score)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foreach_custom_type.png&#34; alt=&#34;foreach_custom_type&#34; title=&#34;ForEach custom type&#34; /&gt;
这告诉 SwiftUI 它可以通过查看它们的 &lt;code&gt;id&lt;/code&gt; 属性来区分 &lt;code&gt;ForEach&lt;/code&gt; 中的视图。
&lt;strong&gt;提示&lt;/strong&gt;：如果您使 &lt;code&gt;Result&lt;/code&gt; 符合 &lt;code&gt;Identifiable&lt;/code&gt; protocol，您只需编写 &lt;code&gt;ForEach（Result）&lt;/code&gt;。 符合此协议意味着添加唯一标识每个对象的 &lt;code&gt;id&lt;/code&gt; 属性，在我们的示例中我们已经拥有，因此您只需编写 &lt;code&gt;struct Result：Identifiable {&lt;/code&gt;！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.5_如何返回不同的视图类型</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 25 Jul 2019 13:47:21 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/</guid>
      <description>

&lt;p&gt;当我们从视图的 body 返回 &lt;code&gt;some View&lt;/code&gt; 的时候，Swift 理解这意味着我们有一个特定的返回类型。&lt;/p&gt;

&lt;p&gt;例如: 如果我们想掷硬币并显示 &amp;ldquo;你赢了!&amp;ldquo;，但是我们不能这样写: 要么返回一个 Image，要么返回一个 Text，写着 &amp;ldquo;下次祝你好运&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    if Bool.random() {
        Image(&amp;quot;example-image&amp;quot;)
    } else {
        Text(&amp;quot;Better luck next time&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码会报错:
&lt;img src=&#34;img/error_return_view_type.png&#34; alt=&#34;error_return_view_type&#34; title=&#34;Compilation error&#34; /&gt;
因为它可能返回 &lt;em&gt;Image&lt;/em&gt; 或者 &lt;em&gt;Text&lt;/em&gt; ，这是不允许的 &amp;ndash;  我们&lt;code&gt;必须精确返回一种类型&lt;/code&gt;。
有两种方法可以解决这个问题。&lt;/p&gt;

&lt;h3 id=&#34;1-group&#34;&gt;1. Group&lt;/h3&gt;

&lt;p&gt;第一种方法是将输出包装在一个 &lt;code&gt;group&lt;/code&gt; 中，这样无论我们发送图像视图还是文本视图，它们都将返回到一个 &lt;code&gt;group&lt;/code&gt; 中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Group {
        if Bool.random() {
            Image(&amp;quot;example-image&amp;quot;)
        } else {
            Text(&amp;quot;Better luck next time&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/return_image.png&#34; alt=&#34;return_image&#34; title=&#34;Return an image or a text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-anyview&#34;&gt;2. AnyView&lt;/h3&gt;

&lt;p&gt;第二种方法，SwiftUI 提供了一个名为 &lt;code&gt;AnyView&lt;/code&gt; 的类型，我们可以返回这种类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: AnyView {
    if Bool.random() {
        return AnyView(Image(&amp;quot;example-image&amp;quot;))
    } else {
        return AnyView(Text(&amp;quot;Better luck next time&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你还没有听说过这个概念，它会强制让 Swift 忘记 &lt;code&gt;AnyView&lt;/code&gt; 中包含的特定类型，让它们看起来像是一样的东西。但这有性能成本，所以不要经常使用它。
尽管 &lt;code&gt;Group&lt;/code&gt; 和 &lt;code&gt;AnyView&lt;/code&gt; 都为我们的布局实现了相同的结果，但通常最好使用 &lt;code&gt;Group&lt;/code&gt;，因为它对 SwiftUI 更有效。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.7_如何使用ZStack将视图叠加在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Thu, 25 Jul 2019 13:26:52 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>

&lt;p&gt;SwiftUI 有一个专用的 &lt;em&gt;stack&lt;/em&gt; 类型，用于创建重叠内容，例如，如果我们想在图片上放置一些文本，它就很有用。它被称为 &lt;code&gt;ZStack&lt;/code&gt;，其工作原理与其他两种 &lt;em&gt;stack&lt;/em&gt; 类型相同。&lt;/p&gt;

&lt;h3 id=&#34;1-在文本下面放置图片&#34;&gt;1. 在文本下面放置图片&lt;/h3&gt;

&lt;p&gt;例如: 我们可以在如下文本下面放置一个大图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    ZStack() {
        Image(&amp;quot;example-image&amp;quot;)
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(Color.black)
            .foregroundColor(.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.7_zstack_image_text.png&#34; alt=&#34;2.7_zstack_image_text&#34; title=&#34;Set zstack with a image and a text, image is below text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-对齐&#34;&gt;2. 对齐&lt;/h3&gt;

&lt;p&gt;与其它 &lt;em&gt;stack&lt;/em&gt; 类型一样，&lt;code&gt;ZStack&lt;/code&gt; 也可以设置对齐方式，这样它就不会总是将事物置于自身的中心位置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    ZStack(alignment: .leading) {
        Image(&amp;quot;example-image&amp;quot;)
            .resizable()
            .aspectRatio(contentMode: .fit)
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(Color.black)
            .foregroundColor(.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.7_zstack_alignment_leading.png&#34; alt=&#34;2.7_zstack_alignment_leading&#34; title=&#34;Set zstack&#39;s alignment as .leading&#34; /&gt;
但是，它没有 &lt;em&gt;spacing&lt;/em&gt; 属性，因为它实际上没有意义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.3_如何使用padding控制单个视图周围的间距</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/</link>
      <pubDate>Thu, 25 Jul 2019 11:39:45 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/</guid>
      <description>

&lt;p&gt;SwiftUI 允许我们使用 &lt;code&gt;padding()&lt;/code&gt; 修饰符在视图周围设置单独的填充。&lt;/p&gt;

&lt;h3 id=&#34;1-系统默认-padding&#34;&gt;1. 系统默认 padding&lt;/h3&gt;

&lt;p&gt;如果在不传参数的情况下使用 &lt;em&gt;padding()&lt;/em&gt; ，我们将在视图的四周获得系统默认填充，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            // 1. 系统默认 padding
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding()
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_system_default.png&#34; alt=&#34;2.3_padding_system_default&#34; title=&#34;Set padding with system default&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 这里默认设置了视图四周的填充。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-只设置一侧系统默认-padding&#34;&gt;2. 只设置一侧系统默认 padding&lt;/h3&gt;

&lt;p&gt;我们也可以自定义要应用的 填充 和 位置。因此，我们只希望将系统填充应用于一侧:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {  
            // 2. 只设置一侧填充
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding(.bottom)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_system_bottom.png&#34; alt=&#34;2.3_padding_system_bottom&#34; title=&#34;Set bottom padding with system default&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 这里只设置了底部填充，与上面的例子不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;3-用具体数值来设置-padding&#34;&gt;3. 用具体数值来设置 padding&lt;/h3&gt;

&lt;p&gt;我们可能希望控制对所有边应用了多少填充:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {  
            // 2. 只设置一侧填充
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding(100)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_100.png&#34; alt=&#34;2.3_padding_100&#34; title=&#34;Set padding as 100&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-在视图一侧添加特定数量的填充&#34;&gt;4. 在视图一侧添加特定数量的填充&lt;/h3&gt;

&lt;p&gt;我们也可以将这两者结合起来，在视图的一侧添加特定数量的填充：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding(.bottom, 100)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_bottom_100.png&#34; alt=&#34;2.3_padding_bottom_100&#34; title=&#34;Set bottom padding as 100&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.2_如何通过alignment和spacing自定义stack布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 25 Jul 2019 10:54:52 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/</guid>
      <description>

&lt;h3 id=&#34;1-spacing&#34;&gt;1. &lt;code&gt;spacing&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以通过在 SwiftUI stacks 的构造方法中填一个值来设置间距，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 设置 spacing
        VStack(spacing: 50) {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.2_stack_spacing.png&#34; alt=&#34;2.2_stack_spacing&#34; title=&#34;Set a spacing for stack&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-divider&#34;&gt;2. &lt;code&gt;Divider&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以在项目之间创建分隔线，以便 SwiftUI 在 &lt;em&gt;stack&lt;/em&gt; 中的每个项目之间进行较小的视觉区分，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 设置 divider
        VStack {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Divider()
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.2_stack_divider.png&#34; alt=&#34;2.2_stack_divider&#34; title=&#34;Set a divider for stack&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-alignment&#34;&gt;3. &lt;code&gt;alignment&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;默认情况下，&lt;em&gt;stacks&lt;/em&gt; 中的项目居中对齐。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;em&gt;HStack&lt;/em&gt; 中: 项目在中间垂直对齐，因此如果有两个不同高度的文本视图，它们都将与垂直中心对齐。&lt;/li&gt;
&lt;li&gt;在 &lt;em&gt;VStack&lt;/em&gt; 中: 项目在中间水平对齐，因此如果有两个长度不同的文本视图，它们都将与水平中心对齐。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要调整这种情况，请在创建 &lt;em&gt;stack&lt;/em&gt; 时按以下方式传递一个 &lt;em&gt;alignment&lt;/em&gt; 参数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 设置 alignment
        VStack(alignment: .leading) {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.2_stack_alignment_leading.png&#34; alt=&#34;2.2_stack_alignment_leading&#34; title=&#34;Set alignment to .leading&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这将使 &lt;code&gt;Hello SwiftUI&lt;/code&gt; 和 &lt;code&gt;Hello M X&lt;/code&gt; 左对齐，但它们最终将位于屏幕的中间，因为 stack 只占用所需的空间。&lt;/p&gt;

&lt;h3 id=&#34;4-同时设置-alignment-和-spacing&#34;&gt;4.同时设置 &lt;code&gt;alignment&lt;/code&gt; 和 &lt;code&gt;spacing&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以同时使用 &lt;em&gt;alignment&lt;/em&gt; 和 &lt;em&gt;spacing&lt;/em&gt; ，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 同时设置 alignment 和 spacing
        VStack(alignment: .leading, spacing: 20) {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/2.2_stack_alignment_spacing.png&#34; alt=&#34;2.2_stack_alignment_spacing&#34; title=&#34;Using alignment and spacing in stack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这将使两个文本视图水平对齐到 &lt;code&gt;leading&lt;/code&gt;（对于从左到右的语言是左对齐），并在它们之间放置20个点的垂直间距。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.1_如何使用VStack和HStack创建stacks</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/</link>
      <pubDate>Thu, 25 Jul 2019 10:10:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/</guid>
      <description>

&lt;p&gt;SwiftUI 的内容视图(content views)必须返回一个视图，即我们希望它们显示的视图。当我们想要一次性在屏幕上显示多个视图时，我们需要告诉 SwiftUI 如何排列它们，这就是 &lt;code&gt;堆栈（stacks）&lt;/code&gt;的来源。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;堆栈（Stacks）&lt;/code&gt; 相当于 UIKit 中的 &lt;strong&gt;UIStackView&lt;/strong&gt; 。有三种形式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;水平（HStack）&lt;/li&gt;
&lt;li&gt;垂直（VStack）&lt;/li&gt;
&lt;li&gt;基于深度（ZStack）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们想放置子视图以便它们重叠时可以使用后者。&lt;/p&gt;

&lt;h3 id=&#34;1-vstack&#34;&gt;1. VStack&lt;/h3&gt;

&lt;p&gt;让我们从一些简单的事情开始，先创建一个文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            // 1. 创建一个文本视图
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.1_single_text.png&#34; alt=&#34;2.1_single_text&#34; title=&#34;A single text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们想在下面再放一个文本视图，我们不能只写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
    Text(&amp;quot;Hello M X&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话，编译器会直接报错。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;记住，我们只能返回一个视图，否则代码就不会工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么怎么办呢？我们需要将其放置在 &lt;code&gt;VStack&lt;/code&gt; 中，以便将文本视图放置在彼此上方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            // 2. 创建两个文本视图
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.1_two_text_in_vstack.png&#34; alt=&#34;2.1_two_text_in_vstack&#34; title=&#34;Two texts in VStack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;您会注意到: &lt;code&gt;VStack&lt;/code&gt; 位于屏幕的中心，标签也居中，并且它们之间有一些自动间隔。&lt;/p&gt;

&lt;h3 id=&#34;2-hstack&#34;&gt;2. HStack&lt;/h3&gt;

&lt;p&gt;如果我们希望文本视图并排水平放置，请使用如下方式将 &lt;code&gt;VStack&lt;/code&gt; 替换为 &lt;code&gt;HStack&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        HStack {
            // 3. 水平放置
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.1_two_text_in_hstack.png&#34; alt=&#34;2.1_two_text_in_hstack&#34; title=&#34;Two texts in HStack&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.9_如何使用图像和其它视图作为背景</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/</link>
      <pubDate>Wed, 24 Jul 2019 15:46:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/</guid>
      <description>

&lt;p&gt;我们可以使用相同的 &lt;code&gt;background()&lt;/code&gt; 修饰符来设置背景图像，而不是设置背景颜色。&lt;/p&gt;

&lt;h3 id=&#34;1-给文本视图设置图像背景&#34;&gt;1. 给文本视图设置图像背景&lt;/h3&gt;

&lt;p&gt;例如: 现在，我们要创建一个大字体的文本视图，然后在其后面放置一个 &lt;code&gt;100x100 的图像&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 设置图像背景
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(
                Image(&amp;quot;example-image&amp;quot;)
                    .resizable()
                    .frame(width: 100, height: 100)
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.9_background_image.png&#34; alt=&#34;1.9_background_image&#34; title=&#34;Set background with image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-给文本视图设置一个红色圆圈作为背景&#34;&gt;2. 给文本视图设置一个红色圆圈作为背景&lt;/h3&gt;

&lt;p&gt;在 SwiftUI 中，背景 View 并不一定是一个图像，实际上我们可以使用任何类型的视图作为背景。
例如: 现在将创建相同的文本视图，然后在其后面放置一个 &lt;code&gt;200x200 的红色圆圈&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 设置红色圆圈背景
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(
                Circle()
                    .fill(Color.red)
                    .frame(width: 200, height: 200)
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.9_background_red_circle.png&#34; alt=&#34;1.9_background_red_circle&#34; title=&#34;Set background with a red circle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，背景视图会自动占用尽可能多的空间以完全可见，但如果需要，可以使用 &lt;code&gt;clipped(&lt;/code&gt;) 修饰符将其剪裁为父视图的大小：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
        .font(.largeTitle)
        .background(
            Circle()
                .fill(Color.red)
                .frame(width: 200, height: 200)
                .clipped()
        )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.9_background_red_circle_clipped.png&#34; alt=&#34;1.9_background_red_circle_clipped&#34; /&gt;&lt;/p&gt;

&lt;p&gt;明确地说，您可以使用任何视图作为背景，例如，如果需要，可以使用另一个文本视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.8_如何显示几何形状</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/</link>
      <pubDate>Wed, 24 Jul 2019 15:46:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/</guid>
      <description>

&lt;p&gt;如果我们想在应用程序中使用简单的几何形状，我们可以直接创建它们，然后根据需要对它们进行着色和定位。&lt;/p&gt;

&lt;h3 id=&#34;1-矩形&#34;&gt;1. 矩形&lt;/h3&gt;

&lt;p&gt;例如，如果我们想要一个 &lt;code&gt;200x200&lt;/code&gt; 红色矩形，可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 200 * 200 红色矩形
        Rectangle()
            .fill(Color.red)
            .frame(width: 200, height: 200)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.8_square_red_wh200.png&#34; alt=&#34;1.8_square_red_wh200&#34; title=&#34;Square: 200 x 200&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-圆&#34;&gt;2. 圆&lt;/h3&gt;

&lt;p&gt;同样，如果你想要一个 &lt;code&gt;50x50&lt;/code&gt; 的蓝色圆圈，您可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 50 * 50 蓝色圆圈
        Circle()
            .fill(Color.blue)
            .frame(width: 50, height: 50)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.8_circle_blue_r50.png&#34; alt=&#34;1.8_circle_blue_r50&#34; title=&#34;Circle: 50 x 50&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.7_如何渲染渐变</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/</link>
      <pubDate>Wed, 24 Jul 2019 15:45:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/</guid>
      <description>

&lt;p&gt;SwiftUI 为我们提供了各种渐变选项（gradient options），所有这些选项都可以以各种方式来使用。例如:&lt;/p&gt;

&lt;h3 id=&#34;1-垂直线性渐变&#34;&gt;1. 垂直线性渐变&lt;/h3&gt;

&lt;p&gt;我们使用从白色到黑色的线性渐变来渲染文本视图，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 线性渐变: white -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .black]), startPoint: .top, endPoint: .bottom))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_vertical_white_black.png&#34; alt=&#34;1.7_gradient_vertical_white_black&#34; title=&#34;vertical gradient: white -&amp;gt; black&#34; /&gt;&lt;/p&gt;

&lt;p&gt;颜色被指定为一个数组，我们可以设置任意多我们想要的颜色 - 默认情况下，SwiftUI 将会平均分配这些颜色。所以，我们也可以这样从 白色 -&amp;gt; 红色 -&amp;gt; 黑色 来设置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 线性渐变: white -&amp;gt; red -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .top, endPoint: .bottom))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_vertical_white_red_black.png&#34; alt=&#34;1.7_gradient_vertical_white_red_black&#34; title=&#34;vertical gradient: white -&amp;gt; red -&amp;gt; black&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-水平线性渐变&#34;&gt;2. 水平线性渐变&lt;/h3&gt;

&lt;p&gt;要实现一个水平渐变（a horizontal gradient）而不是一个垂直渐变（a vertical one），使用 &lt;code&gt;.leading&lt;/code&gt; 和 &lt;code&gt;.trailing&lt;/code&gt; 来作为 &lt;em&gt;startPoint&lt;/em&gt; 和 &lt;em&gt;endPoint&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 水平线性渐变: white -&amp;gt; red -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .leading, endPoint: .trailing))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_horizontal_white_red_black.png&#34; alt=&#34;1.7_gradient_horizontal_white_red_black&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-对角线线性渐变&#34;&gt;3. 对角线线性渐变&lt;/h3&gt;

&lt;p&gt;要实现对角线渐变，可以使用 &lt;code&gt;.topLeading&lt;/code&gt; 和 &lt;code&gt;.bottomTrailing&lt;/code&gt; 作为 &lt;em&gt;startPoint&lt;/em&gt; 和 &lt;em&gt;endPoint&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 对角线性渐变: white -&amp;gt; red -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .topLeading, endPoint: .bottomTrailing))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_diagonal.png&#34; alt=&#34;1.7_gradient_diagonal&#34; title=&#34;diagonal gradient: white -&amp;gt; red -&amp;gt; black &#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-径向渐变&#34;&gt;4. 径向渐变&lt;/h3&gt;

&lt;p&gt;对于其他渐变样式，请尝试 &lt;code&gt;RadialGradient&lt;/code&gt; 或 &lt;code&gt;AngularGradient&lt;/code&gt;。
例如，这将创建一个从圆心开始到边缘的各种颜色的径向渐变:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 5. 径向渐变
        let colors = Gradient(colors: [.red, .yellow, .green, .blue, .purple])
        let conic = RadialGradient(gradient: colors, center: .center, startRadius: 50, endRadius: 200)
        return Circle()
            .fill(conic)
            .frame(width: 400, height: 400)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_radial.png&#34; alt=&#34;1.7_gradient_radial&#34; title=&#34;Radial gradient&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-角度渐变-圆锥梯度&#34;&gt;5. 角度渐变(圆锥梯度)&lt;/h3&gt;

&lt;p&gt;这就形成一个角梯度（通常称为圆锥梯度），通过各种颜色然后返回到开始循环:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 6. 圆锥梯度
        let colors = Gradient(colors: [.red, .yellow, .green, .blue, .purple, .red])
        let conic = AngularGradient(gradient: colors, center: .center)
        return Circle()
            .fill(conic)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_angular.png&#34; alt=&#34;1.7_gradient_angular&#34; title=&#34;Angular gradient&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-角度渐变-圆环&#34;&gt;6. 角度渐变(圆环)&lt;/h3&gt;

&lt;p&gt;由于所有三种渐变类型都符合 &lt;code&gt;ShapeStyle&lt;/code&gt; 协议，因此可以将它们用于背景，填充和笔触。 例如，这使用我们的彩虹圆锥形渐变作为圆的粗内部笔画：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 7. 圆环
        let colors = Gradient(colors: [.red, .yellow, .green, .blue, .purple, .red])
        let conic = AngularGradient(gradient: colors, center: .center, startAngle: .zero, endAngle: .degrees(360))
        return Circle()
            .strokeBorder(conic, lineWidth: 50)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_circle.png&#34; alt=&#34;1.7_gradient_circle&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.6_如何调整图像视图的填充模式</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:45:07 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;img/1.6_ba_xian_tai.png&#34; alt=&#34;1.6_ba_xian_tai&#34; /&gt;
SwiftUI 的 &lt;code&gt;Image&lt;/code&gt; 视图能够以不同的方式进行缩放，就像 &lt;code&gt;UIImageView&lt;/code&gt; 的 &lt;strong&gt;content mode&lt;/strong&gt; 一样。&lt;/p&gt;

&lt;h3 id=&#34;1-默认&#34;&gt;1.默认&lt;/h3&gt;

&lt;p&gt;默认情况下，图像视图会根据其内容自动调整大小，这可能会使它们超出屏幕范围。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_the_default_content_mode.png&#34; alt=&#34;1.6_the_default_content_mode&#34; title=&#34;default content mode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果添加 &lt;code&gt;resizable()&lt;/code&gt; 修饰符，则图像将自动调整大小，以填充所有可用空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_resizable_image.png&#34; alt=&#34;1.6_resizable_image&#34; title=&#34;resizable image&#34; /&gt;
然而，这也可能导致图像的原始纵横比失真，因为它将在所有维度上被拉伸任意量，以使其填充空间。&lt;/p&gt;

&lt;h3 id=&#34;2-fill-和-fit&#34;&gt;2. &lt;code&gt;.fill&lt;/code&gt; 和 &lt;code&gt;.fit&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;如果要保持其纵横比，应使用 &lt;code&gt;.fill&lt;/code&gt; 或 &lt;code&gt;.fit&lt;/code&gt;添加一个&lt;code&gt;aspectRatio()&lt;/code&gt;修饰符，如下所示:&lt;/p&gt;

&lt;h4 id=&#34;2-1-fill&#34;&gt;2.1 fill&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
    .aspectRatio(contentMode: .fill)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_fill_content_mode.png&#34; alt=&#34;1.6_fill_content_mode&#34; title=&#34;content mode = .fill&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-2-fit&#34;&gt;2.2 fit&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
    .aspectRatio(contentMode: .fit)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_fit_content_mode.png&#34; alt=&#34;1.6_fit_content_mode&#34; title=&#34;content mode = .fit&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.5_如何使用图像视图绘制图像</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:44:15 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</guid>
      <description>

&lt;p&gt;使用图像视图 &lt;code&gt;Image&lt;/code&gt; 可以在 SwiftUI 布局中渲染图像（images）。我们可以从 &lt;code&gt;Bundle&lt;/code&gt;、&lt;code&gt;System icons&lt;/code&gt;、&lt;code&gt;UIImage&lt;/code&gt; 等中加载图像，但这三个将是最常见的。&lt;/p&gt;

&lt;h3 id=&#34;1-从-bundle-加载&#34;&gt;1. 从 Bundle 加载&lt;/h3&gt;

&lt;p&gt;要从 Bundle 中加载图像并将其显示在图像视图中，只需使用以下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Image(&amp;quot;example-image&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_load_image_from_bundle.png&#34; alt=&#34;1.5_load_image_from_bundle.png&#34; title=&#34;load image from buldle&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-从-system-icons-加载&#34;&gt;2. 从 System icons 加载&lt;/h3&gt;

&lt;p&gt;要从苹果旧金山符号集(Apple’s San Francisco Symbol set)中加载图标，请使用 &lt;code&gt;Image(systemName: )&lt;/code&gt; 初始化器，传入图标字符串进行加载，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_load_image_from_systemicon.png&#34; alt=&#34;1.5_load_image_from_systemicon&#34; title=&#34;load image from system icons&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-从-uiimage-加载&#34;&gt;3. 从 UIImage 加载&lt;/h3&gt;

&lt;p&gt;最后，可以从现有的 UIImage 创建一个图像视图。因为这需要更多的代码，所以需要显式地使用 return 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let image = UIImage(named: &amp;quot;example-image&amp;quot;) else {
    fatalError(&amp;quot;Unable to load image&amp;quot;)
}

return Image(uiImage: image)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_load_image_from_uiimage.png&#34; alt=&#34;1.5_load_image_from_uiimage&#34; title=&#34;load image from uiimage&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-通过-foregroundcolor-给系统图标着色&#34;&gt;4. 通过 foregroundColor 给系统图标着色&lt;/h3&gt;

&lt;p&gt;如果你使用的是 系统图标集，则返回的图像是 &lt;code&gt;可缩放&lt;/code&gt; 和 &lt;code&gt;可着色&lt;/code&gt; 的，这意味着你可以使用 &lt;code&gt;foregroundColor()&lt;/code&gt; 修改器对图像着色。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
    .foregroundColor(.red)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_foreground_color_image.png&#34; alt=&#34;1.5_foreground_color_image&#34; title=&#34;set foreground color for system icon&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-通过给系统图标设置动态文本样式来放大图像&#34;&gt;5. 通过给系统图标设置动态文本样式来放大图像&lt;/h3&gt;

&lt;p&gt;这意味着你可以通过匹配任何 &lt;code&gt;Dynamic Type&lt;/code&gt; 文本样式，来要求 SwiftUI 放大图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
    .font(.largeTitle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_font_largetitle_image.png&#34; alt=&#34;1.5_font_largetitle_image&#34; title=&#34;set font as largeTitle for system icons&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.4_如何格式化文本视图中的文本</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/</link>
      <pubDate>Wed, 24 Jul 2019 15:43:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/</guid>
      <description>&lt;p&gt;SwiftUI 的文本视图有一个可选的 &lt;code&gt;formatter&lt;/code&gt; 参数，允许我们自定义数据在标签（label）中的显示方式。这一点很重要，因为在我们的程序中发生某些事情时，通常会为我们更新值，因此通过附加 &lt;code&gt;formatter&lt;/code&gt;， SwiftUI 可以确保我们的数据以我们期望的方式来正确显示。&lt;/p&gt;

&lt;p&gt;例如，我们定义了一个日期格式化程序（date formatter），并使用它来确保 任务日期 以人类可读的形式显示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftUI

struct ContentView: View {
    static let taskDateFormat: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        return formatter
    }()
    
    var dueDate = Date()
    
    var body: some View {
        Text(&amp;quot;Task due date: \(dueDate, formatter: Self.taskDateFormat)&amp;quot;)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.4_date_formatter_text.png&#34; alt=&#34;1.4_date_formatter_text.png&#34; title=&#34;date formatter&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.3_如何使用字体颜色行距等设置文本视图的样式</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:42:28 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/</guid>
      <description>

&lt;!-- more --&gt;

&lt;p&gt;&lt;code&gt;Text&lt;/code&gt; 不仅在外观方面可以让我们进行可预测的广泛控制，而且它们还可以与 &lt;code&gt;Dynamic Type&lt;/code&gt; 等 Apple 的核心技术无缝协作。&lt;/p&gt;

&lt;h3 id=&#34;1-设置字体&#34;&gt;1. 设置字体&lt;/h3&gt;

&lt;p&gt;默认情况下，文本视图有一个 &lt;code&gt;Body&lt;/code&gt; 动态类型样式，但是我们可以通过以下方式调用 &lt;code&gt;.font()&lt;/code&gt;，从其它 &lt;em&gt;sizes&lt;/em&gt; 和 &lt;em&gt;weights&lt;/em&gt; 进行选择:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 设置字体
        Text(&amp;quot;This is an extremely long text string that will never fit even the widest of Phones&amp;quot;)
            .font(.largeTitle)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_font_large_title.png&#34; alt=&#34;1.3_text_font_large_title&#34; title=&#34;Set a font for text&#34; /&gt;
我们现在在文本视图下面使用了两个修改器，这没关系 - 我们可以将它们堆叠起来，并且它们都会生效。&lt;/p&gt;

&lt;h3 id=&#34;2-设置文本对齐方式&#34;&gt;2. 设置文本对齐方式&lt;/h3&gt;

&lt;p&gt;特别是，现在我们有多行文本，我们需要调整文本的对齐方式，使其居中，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2.设置文本对齐方式
        Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones&amp;quot;)
            .font(.largeTitle)
            .multilineTextAlignment(.center)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_alignment_center.png&#34; alt=&#34;1.3_text_alignment_center&#34; title=&#34;Set center alignment for text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-设置字体颜色&#34;&gt;3. 设置字体颜色&lt;/h3&gt;

&lt;p&gt;我们可以通过 &lt;code&gt;.foregroundColor()&lt;/code&gt; 修改器来设置文本颜色，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 设置字体颜色
        Text(&amp;quot;The best laid plans&amp;quot;)
            .foregroundColor(.red)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_foregroundcolor.png&#34; alt=&#34;1.3_text_foregroundcolor&#34; title=&#34;Set a foreground color for text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-设置背景颜色&#34;&gt;4. 设置背景颜色&lt;/h3&gt;

&lt;p&gt;我们可以使用 &lt;code&gt;.background()&lt;/code&gt; 来设置背景颜色，但是它不仅仅可以用来设置背景颜色，也可以设置背景视图。无论如何，为了给我们的文本视图设置一个黄色背景，代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 设置背景颜色
        Text(&amp;quot;The best laid plans&amp;quot;)
            .foregroundColor(.red)
            .background(Color.yellow)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_backgroundcolor.png&#34; alt=&#34;1.3_text_backgroundcolor&#34; title=&#34;Set a background color for text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-设置行间距&#34;&gt;5. 设置行间距&lt;/h3&gt;

&lt;p&gt;我们可以设置多行文本的行间距，行间距默认值为0，表示没有额外的行间距，但是我们可以通过以下方式在行与行之间指定一个值来添加额外的行间距。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 5.设置行间距
        Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones&amp;quot;)
            .font(.largeTitle)
            .lineSpacing(50)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_line_spacing.png&#34; alt=&#34;1.3_text_line_spacing&#34; title=&#34;Set a line spacing for text&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.2_如何使用 Text 创建静态标签</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-text-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Wed, 24 Jul 2019 13:35:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-text-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Text&lt;/code&gt; 主要用于在屏幕上显示静态文本，相当于 UIKit 中的 &lt;code&gt;UILabel&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-基本用法&#34;&gt;2. 基本用法&lt;/h3&gt;

&lt;p&gt;最基本的用法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;ContentView&lt;/code&gt; 的预览窗口中，我们可能会看到 &lt;code&gt;Automatic preview updating paused&lt;/code&gt;， 继续按 &lt;code&gt;Resume&lt;/code&gt; 以让 Swift 开始构建代码并向我们展示 &lt;code&gt;ContentView&lt;/code&gt; 外观的实时预览。&lt;/p&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_automatic_preview_updating_paused.png&#34; alt=&#34;1.2_automatic_preview_updating_paused&#34; title=&#34;Automatic preview updating paused, need to resume.&#34; /&gt;
&lt;img src=&#34;img/1.2_text_hello_world.png&#34; alt=&#34;1.2_text_hello_world&#34; title=&#34;Hello world&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-设置显示行数&#34;&gt;3. 设置显示行数&lt;/h3&gt;

&lt;p&gt;默认情况下，Text 视图会根据需要自动换行(包含尽可能多的行)，但是如果我们更希望限制它们可以使用的行数，则应该添加 &lt;code&gt;lineLimit&lt;/code&gt; 修改器，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Hello world&amp;quot;)
    .lineLimit(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 请注意 &lt;code&gt;lineLimit(3)&lt;/code&gt; 位于 &lt;code&gt;Text(&amp;quot;Hello World&amp;quot;)&lt;/code&gt; 下方靠右侧的方式。这不是必需的，但从长远来看，它确实使我们的代码更易于阅读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果对某些文本设置行限制，然后为其提供一个太长而不适合可用空间的字符串，SwiftUI将截断文本，使其以 &lt;code&gt;...&lt;/code&gt; 结尾。&lt;/p&gt;

&lt;p&gt;或者，我们可以为 &lt;code&gt;lineLimit()&lt;/code&gt; 方法指定 &lt;code&gt;nil&lt;/code&gt;，这样就允许它根据需要运行任意多行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones.&amp;quot;)
    .lineLimit(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_text_line_limit_nil.png&#34; alt=&#34;1.2_text_line_limit_nil&#34; title=&#34;lineLimit = nil&#34; /&gt;
&amp;gt; &lt;strong&gt;注意:&lt;/strong&gt; 这里设置 &lt;code&gt;lineLimit(0)&lt;/code&gt; 不能实现多行显示，这一点跟 UIKit 中是不一样的。&lt;/p&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_text_line_limit_0.png&#34; alt=&#34;1.2_text_line_limit_0&#34; title=&#34;lineLimit = 0&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-文本截断&#34;&gt;4. 文本截断&lt;/h3&gt;

&lt;p&gt;我们也可以调整 SwiftUI 截断文本的方式: 默认情况下，从末尾删除文本并在那里显示省略号，但也可以将省略号放在中间或开头，具体取决于字符串各个部分的重要程度。&lt;/p&gt;

&lt;p&gt;例如: 以下代码会在中间截断文本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones.&amp;quot;)
    .lineLimit(0)
    .truncationMode(.middle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_text_truncation_mode_middle.png&#34; alt=&#34;1.2_text_truncation_mode_middle&#34; title=&#34;truncationMode = middle&#34; /&gt;
不管我们如何截断文本，我们将看到文本视图始终位于主视图（main view）的中心。这是 SwiftUI 的默认行为 &amp;ndash; 除非我们明确告诉 SwiftUI 将视图定位到其它位置，否则 SwiftUI 会将视图定位到相对于屏幕中心的位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.1_工程模板介绍</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 23 Jul 2019 15:51:58 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;img/1.1_swiftui_basic_template.png&#34; alt=&#34;1.1_swiftui_basic_template&#34; /&gt;
如图，自 Xcode 11 之后，基本的 单一视图应用程序(Single View App)模板 为我们提供以下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AppDelegate.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它负责监视外部事件。&lt;/li&gt;
&lt;li&gt;例如: 如果另一个应用程序试图向我们发送要一个要打开的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SceneDelegate.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它负责管理应用程序的显示方式。&lt;/li&gt;
&lt;li&gt;例如: 让多个实例同时运行，或者当一个实例移动到后台时采取操作/措施。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContentView.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是我们最初的用户界面。&lt;/li&gt;
&lt;li&gt;如果这是一个 UIKit 项目，它就相当于 Xcode 提供给我们的 &lt;strong&gt;ViewController&lt;/strong&gt; 类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Assets.xcassets&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是项目的资产目录。&lt;/li&gt;
&lt;li&gt;存储着我们项目中使用的所有图像和颜色。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LaunchScreen.storyboard&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是在我们的应用加载时显示的屏幕。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Info.plist&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是一个属性列表文件，用于存储应用程序的系统级设置。&lt;/li&gt;
&lt;li&gt;例如: 应该在 iOS 主屏幕上的图标下面显示什么名称。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preview content&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;它是一个名为 &lt;strong&gt;Preview content&lt;/strong&gt; 的组，其中包含另一个名为 &lt;strong&gt;Preview Assests&lt;/strong&gt; 的资产目录。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就是这样 - 只有少量的代码和资源，这意味着我们可以在此基础上进行构建。&lt;/p&gt;

&lt;h3 id=&#34;2-查看-scenedelegate&#34;&gt;2. 查看 SceneDelegate&lt;/h3&gt;

&lt;p&gt;事实上，我们真正关心的、也是唯一重要的部分是 &lt;code&gt;ContentView.swift&lt;/code&gt;。这是我们应用程序的主要功能，在这里我们可以立即开始尝试各种 &lt;code&gt;SwiftUI&lt;/code&gt; 代码。&lt;/p&gt;

&lt;p&gt;不过，我们首先要弄清楚的是: 是什么让 &lt;em&gt;ContentView.swift&lt;/em&gt; 显示在屏幕上?
上面我们提到: &lt;code&gt;SceneDelegate.swift&lt;/code&gt; 负责管理应用程序的显示方式。那么，我们打开 &lt;code&gt;SceneDelegate.swift&lt;/code&gt;，就会看到下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create the SwiftUI view that provides the window contents.
let contentView = ContentView()

// Use a UIHostingController as window root view controller.
if let windowScene = scene as? UIWindowScene {
    let window = UIWindow(windowScene: windowScene)
    window.rootViewController = UIHostingController(rootView: contentView)
    self.window = window
    window.makeKeyAndVisible()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码创建了一个新的 &lt;code&gt;ContentView&lt;/code&gt; 实例（这是我们即将看到的主要功能），并将其放置在窗口中，以便在屏幕上显示。通过显示 &lt;code&gt;ContentView&lt;/code&gt; 的第一个实例，可以有效地引导我们的应用程序，并从那里结束 - 那么接下来你想做什么？&lt;/p&gt;

&lt;h3 id=&#34;3-查看-contentview&#34;&gt;3. 查看 ContentView&lt;/h3&gt;

&lt;p&gt;打开  &lt;code&gt;ContentView.swift&lt;/code&gt; ，让我们看看一些实际的 SwiftUI 代码。我们应该可以看到这样的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftUI

struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello World&amp;quot;)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不是很多代码，但它实际上包含了大量代码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，请注意，&lt;code&gt;ContentView&lt;/code&gt; 是一个结构体。熟悉 UIKit 的开发人员都知道 - 我们从用户界面的所有值类型的不变性和简单性中获益巨大！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其次，&lt;code&gt;ContentView&lt;/code&gt; 遵守 &lt;code&gt;View&lt;/code&gt; 协议。我们想在 SwiftUI 中显示的所有内容都需要遵守 &lt;code&gt;View&lt;/code&gt; 协议，这实际上只意味着一件事: 我们需要一个名为 &lt;code&gt;body&lt;/code&gt; 的属性来返回 &lt;code&gt;some View&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三，&lt;code&gt;body&lt;/code&gt; 的返回类型是 &lt;code&gt;some View&lt;/code&gt;。&lt;code&gt;some&lt;/code&gt; 关键字是在 Swift 5.1 中新引入的，是一个名为 &lt;strong&gt;不透明返回类型（opaque return types）&lt;/strong&gt; 功能的一部分，在这种情况下，它的意思是 将返回某种视图，但 SwiftUI 不需要知道（或关心）什么。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;重要说明:&lt;/strong&gt; 返回 &lt;code&gt;some View&lt;/code&gt; 意味着 &lt;code&gt;body&lt;/code&gt; 属性将返回遵守 &lt;code&gt;View&lt;/code&gt; 协议的内容。我们不能返回很多东西或忘记返回任何东西，否则，Swift 编译器将拒绝构建我们的代码。为了清楚起见，我们的视图 body 必须始终返回一个子视图。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第四，body 属性中有 &lt;code&gt;Text(&amp;quot;hello world&amp;quot;)&lt;/code&gt;，它创建了文本内容为 &amp;ldquo;hello world&amp;rdquo; 的标签。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，在 ContentView 下面的是一个类似但不同的 struct，称为 &lt;code&gt;ContentView_Previews&lt;/code&gt;。它不遵守 &lt;code&gt;View&lt;/code&gt; 协议，因为它专门用于在 Xcode 中显示 视图预览（Preview），而不是在真正的应用程序中显示在屏幕上。这就是为什么你会看到它在 &lt;code&gt;#if DEBUG&lt;/code&gt; 和 &lt;code&gt;#endif&lt;/code&gt; 之间 - 当我们的应用程序在调试环境中运行时，这段代码只构建在 成品（finished product）中，因为它在生产应用程序（Production app）中没有意义。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
