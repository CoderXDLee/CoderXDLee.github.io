<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SwiftUI on M X</title>
    <link>https://coderxdlee.github.io/categories/swiftui/</link>
    <description>Recent content in SwiftUI on M X</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>M X ©{year}</copyright>
    <lastBuildDate>Tue, 30 Jul 2019 00:23:02 +0800</lastBuildDate>
    
	    <atom:link href="https://coderxdlee.github.io/categories/swiftui/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>5.2_如何创建静态项列表</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jul 2019 00:23:02 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;要创建静态项目列表，首先需要定义列表中每行的外观。 这是一个与其他视图一样的视图，因此您可以编写如下的视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow : View {
    
    var name: String
    
    var body: some View {
        Text(&amp;quot;Restaurant: \(name)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然已经定义了每一行的外观，那么就可以创建一个 &lt;code&gt;List&lt;/code&gt;，根据需要创建任意数量的行，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        List {
            RestaurantRow(name: &amp;quot;Joe&#39;s Original&amp;quot;)
            RestaurantRow(name: &amp;quot;The Real Joe&#39;s Original&amp;quot;)
            RestaurantRow(name: &amp;quot;Original Joe&#39;s&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_2_list_static_items_list.gif&#34; alt=&#34;5_2_list_static_items_list&#34; title=&#34;static list&#34; /&gt;
当该代码运行时，您将在表中看到三行，就像您在 UIKit 中使用 &lt;code&gt;UITableView&lt;/code&gt; 一样。
您不需要使每一行使用相同的视图类型，因此您可以根据需要混合和匹配行视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.1_使用List</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/</link>
      <pubDate>Mon, 29 Jul 2019 01:40:08 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;List&lt;/code&gt; 视图类似于 &lt;code&gt;UITableView&lt;/code&gt;，它可以根据您的需要显示静态或动态表视图单元格(table view cells)。 但是，它使用起来要简单得多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们不需要在 storyboard 中创建原型cell( &lt;em&gt;prototype cell&lt;/em&gt; );&lt;/li&gt;
&lt;li&gt;也不需要在代码中注册 Cell;&lt;/li&gt;
&lt;li&gt;我们不需要告诉它有多少行;&lt;/li&gt;
&lt;li&gt;我们不需要手动出列(dequeue)和配置单元格等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相反，SwiftUI 的列表是为可组合性而设计的 - 旨在能够从较小的东西构建更大的东西。 因此，SwiftUI 不需要一个手动配置单元的大视图控制器，而是让我们构建小视图，知道如何将自己配置为列表行，然后使用它们。&lt;/p&gt;

&lt;p&gt;在代码大小方面（如果没有其他的话），差异是惊人的——您可以删除几乎所有的表视图代码，仍然可以获得与您习惯的相同的出色外观和感觉。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4.3_如何使用@EnvironmentObject在视图之间共享数据</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 29 Jul 2019 01:17:25 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;对于应该与整个应用程序中所有视图共享的数据，SwiftUI 为我们提供了 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 。这使我们可以在任何需要的地方共享模型数据，同时确保当模型数据发生变化时，我们的视图自动保持更新。&lt;/p&gt;

&lt;p&gt;可以将 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 看作是在多个视图中使用 &lt;code&gt;@ObjectBinding&lt;/code&gt; 的一种更智能、更简单的方法。而不是在视图 A 中创建一些数据，然后将其传递给视图 B，然后查看视图 C，然后在最终使用数据之前查看视图 D，我们可以在视图中创建它并将其放入环境（environment）中，这样的话，视图B、C、D将会自动访问它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 环境对象必须由祖先视图（ancestor view）提供 &amp;ndash; 如果 SwiftUI 找不到正确类型的环境对象，将会导致崩溃（crash），这也适用于预览，所以要小心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 这里有一个可绑定对象，用于存储用户设置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Combine
import SwiftUI
​
class UserSettings: BindableObject {
    
    var didChange = PassthroughSubject&amp;lt;Void, Never&amp;gt;()
    
    var score = 0 {
        didSet {
            didChange.send(())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，它只存储一个值，但是没关系 &amp;ndash; 重要的是: 当值发生改变时，&lt;code&gt;PassthroughSubject&lt;/code&gt; 会告诉所有使用它（这个值）的的视图进行刷新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用户设置&lt;/strong&gt; 是我们可能希望能够在应用程序的任何地方共享的一个合理的数据，这样我们就不再需要手动处理同步。&lt;/p&gt;

&lt;p&gt;因此，当我们的应用程序首次启动时，我们将创建一个 &lt;code&gt;UserSettings&lt;/code&gt; 的实例。以便在我们的应用程序中随处都可以访问共享实例。&lt;/p&gt;

&lt;p&gt;如果打开 &lt;em&gt;Scenedelegate.swift&lt;/em&gt; ，您将在 &lt;code&gt;（_:willConnectTo:options:）&lt;/code&gt;方法：中找到这两行代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let window = UIWindow(windowScene: windowScene)
window.rootViewController = UIHostingController(rootView: ContentView())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行代码创建我们的初始内容视图（ContentView）并将其显示到屏幕上。这就是我们需要传入我们创建的任何环境对象的地方，以便 SwiftUI 可以在 ContentView 以及它使用的任何其它视图中使用我们创建的环境对象。&lt;/p&gt;

&lt;p&gt;首先，将其添加为 &lt;code&gt;SceneDelegate&lt;/code&gt; 的一个属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var settings = UserSettings() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会创建一个 &lt;em&gt;settings&lt;/em&gt; 实例，并安全地存储它。现在回到刚才展示的那两行代码，并更改第二行，以便将我们的 &lt;em&gt;settings&lt;/em&gt; 属性作为环境对象传递给 &lt;code&gt;ContentView&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;window.rootViewController = UIHostingController(rootView: ContentView().environmentObject(settings))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，共享的 &lt;code&gt;UserSettings&lt;/code&gt; 实例可用于 ContentView 以及它承载（hosts）或展现（presents）的任何其它视图。你只需要使用 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 属性包装器创建一个属性，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@EnvironmentObject var settings: UserSettings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不需要使用默认值进行初始化，因为它将自动从环境中读取。&lt;/p&gt;

&lt;p&gt;因此，我们可以创建一个 &lt;code&gt;ContentView&lt;/code&gt; 结构来增加我们的分数设置，甚至使它呈现出一个显示分数设置的 &lt;code&gt;Detailview&lt;/code&gt;，所有这些都不需要创建或传递任何 &lt;code&gt;UserSettings&lt;/code&gt; 的本地实例 &amp;ndash; 它总是使用环境。&lt;/p&gt;

&lt;p&gt;以下是实现这一目标的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @EnvironmentObject var settings: UserSettings
    
    var body: some View {
        NavigationView {
            VStack {
                Button(action: {
                    self.settings.score += 1
                }) {
                    Text(&amp;quot;Increase score&amp;quot;)
                }
                
                NavigationButton(destination: DetailView()) {
                    Text(&amp;quot;Show Detail View&amp;quot;)
                }
            }
        }
    }
}
​
struct DetailView : View {
    
    @EnvironmentObject var settings: UserSettings
    
    var body: some View {
        // A text view that reads from the environment settings
        Text(&amp;quot;Score: \(settings.score)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，一旦你将一个对象注入到环境中，你就可以立即在顶层视图中或者在下面的十层视图中使用它——这并不重要。最重要的是，每当任何视图改变环境时，依赖它的所有视图都会自动刷新，从而保持同步。&lt;/p&gt;

&lt;p&gt;如你所见，我们不需要将场景代理（scene delegate）中的 &lt;code&gt;UserSettings&lt;/code&gt; 实例与我们两个视图中的 &lt;code&gt;settings&lt;/code&gt; 属性显式关联 - SwiftUI 会自动发现它在环境中有一个 &lt;code&gt;UserSettings&lt;/code&gt; 实例，因此这就是要使用的实例。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;警告：既然我们的视图依赖于存在的环境对象，那么您还必须更新预览代码以提供一些要使用的示例设置。例如，使用 &lt;code&gt;ContentView().EnvironmentObject(UserSettings())&lt;/code&gt; 进行预览应该可以做到这一点。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>4.2_如何使用@ObjectBinding创建对象绑定</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Mon, 29 Jul 2019 00:09:24 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-两件重要的事情&#34;&gt;1. 两件重要的事情&lt;/h3&gt;

&lt;p&gt;当使用对象绑定时，我们需要处理两个细微不同的东西:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BindableObject 协议，用于一些可以存储数据的类。&lt;/li&gt;
&lt;li&gt;@ObjectBinding 属性包装器，在视图中用于存储可绑定对象实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;举个例子，这是一个遵循 &lt;code&gt;BindableObject&lt;/code&gt; 协议的 &lt;code&gt;UserSettings&lt;/code&gt; 类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Combine
import SwiftUI

class UserSettings: BindableObject {
    var didChange = PassthroughSubject&amp;lt;Void, Never&amp;gt;()
    
    var score = 0 {
        didSet {
            didChange.send(())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码代码量很小，但是却包含了相当多的知识点，接下来我们逐一解释:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一: &lt;code&gt;didChange&lt;/code&gt;是 &lt;code&gt;PassthroughSubject&lt;/code&gt; 的一个实例。

&lt;ul&gt;
&lt;li&gt;这个类来自 &lt;code&gt;Combine&lt;/code&gt; 框架，我们需要添加 &lt;code&gt;import Combine&lt;/code&gt; 以使我们的代码能够编译。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;passthrough subject&lt;/em&gt; 的工作很简单: 每当我们想要告诉世界我们的对象发生了变化，我们就要求  &lt;em&gt;passthrough subject&lt;/em&gt; 为我们做这件事情。它被称为 &lt;em&gt;pass through&lt;/em&gt; ，因为我们传递给它的值实际上会传递给任何正在观察变化对象的视图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PassthroughSubject&lt;/code&gt; 在技术上被称为 &lt;em&gt;publisher&lt;/em&gt; ，因为它对世界发布了变化的公告。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二: &lt;code&gt;PassthroughSubject&lt;/code&gt; 是 &lt;code&gt;Void&lt;/code&gt; 和 &lt;code&gt;Never&lt;/code&gt; 的泛型。

&lt;ul&gt;
&lt;li&gt;第一个参数 &lt;code&gt;Void&lt;/code&gt; 意味着 &amp;ldquo;&lt;strong&gt;我不发送任何值&lt;/strong&gt;&amp;ldquo;。在 SwiftUI 的情况下，我们不需要发送值，因为我们想要的是视图刷新 - 它将自动从 &lt;code&gt;@ObjectBinding&lt;/code&gt; 状态中获取新数据。&lt;/li&gt;
&lt;li&gt;第二个参数 &lt;code&gt;Never&lt;/code&gt;，意味着 &amp;ldquo;&lt;strong&gt;我永远不会抛出错误&lt;/strong&gt;&amp;ldquo;。如果你想，你可以定义一个自定义的错误类型，如 &lt;code&gt;NetworkError&lt;/code&gt;，并将其发送，但是通常会发现在可绑定对象内部本地处理错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三: 我们在 &lt;code&gt;UserSettings&lt;/code&gt; 的 &lt;em&gt;score&lt;/em&gt; 属性上附加了一个 &lt;code&gt;didSet&lt;/code&gt; 属性观察器，这样我们就可以在该值发生变化时运行代码。 在我们的示例代码中，每当得分发生变化时，我们都会调用 &lt;code&gt;didChange.send(())&lt;/code&gt;，这就是告诉 &lt;code&gt;didChange&lt;/code&gt; 发布者发布我们的数据已更改的消息，以便任何订阅的视图都可以刷新。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以在这样的视图中使用 &lt;code&gt;UserSettings&lt;/code&gt;类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @ObjectBinding var settings = UserSettings()
    
    var body: some View {
        VStack {
            Text(&amp;quot;Your score is \(settings.score)&amp;quot;)
            Button(action: {
                self.settings.score += 1
            }) {
                Text(&amp;quot;Increase Score&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你所看到的，除了使用带有 &lt;code&gt;@ObjectBinding&lt;/code&gt; 属性包装器的 &lt;em&gt;settings&lt;/em&gt; 之外，其他所有内容都或多或少看起来相同 - SwiftUI 负责处理我们的所有实现细节。
但是有一个重要区别: &lt;em&gt;settings&lt;/em&gt; 属性未声明为 &lt;code&gt;private&lt;/code&gt;。 这是因为绑定对象可以被多个视图使用，因此通常会公开共享它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;警告: 当您使用 publisher 宣布您的对象已更改时，这必须在主线程上发生。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>4.1_@ObjectBinding、@State 和 @EnvironmentObject三者之间的区别</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 28 Jul 2019 22:31:35 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-state&#34;&gt;1. &lt;code&gt;@State&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在任何现代应用程序中，&lt;strong&gt;状态（State）&lt;/strong&gt;都是不可避免的。&lt;/p&gt;

&lt;p&gt;但是对于 SwiftUI 来说，重要的是要记住:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们所有的视图都只是它们的状态的函数&lt;/li&gt;
&lt;li&gt;我们不会直接改变视图，而是操纵状态并让它决定结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SwiftUI 为我们提供了几种在应用程序中存储状态的方法，但是它们之间略有不同，理解它们之间的区别对于正确使用框架是很重要的。&lt;/p&gt;

&lt;p&gt;到目前为止，在我们所有的状态示例中，我们都使用 &lt;code&gt;@State&lt;/code&gt; 来创建如下属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    @State var score = 0
    // more code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码在视图中创建了一个属性，但它使用 &lt;code&gt;@State&lt;/code&gt; 属性包装器（property wrapper）来请求 SwiftUI 来管理内存。这一点很重要: 我们所有的视图都是结构体（structs），这意味着它们不能被改变，如果我们不能在一场比赛中给一个分数加1，那么这就不是一场比赛了。&lt;/p&gt;

&lt;p&gt;因此，当我们使用 &lt;code&gt;@State&lt;/code&gt; 创建一个属性时，就意味着将该属性的控制权交给了 SwiftUI，这样的话，只要视图存在，它就在内存中保持不变。当该状态发生变化时，SwiftUI 知道用最新的变化自动重新加载视图，以便反映其新信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@State&lt;/code&gt; 对于属于特定视图且从未在该视图之外使用的简单属性非常有用，因此通常最好将这些属性标记为私有属性，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@State private var score = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这再次强化了这样一种观点，即这种状态是专门设计的，永远不会脱离它的视图。简单理解，就是在视图内部使用的。&lt;/p&gt;

&lt;h3 id=&#34;2-objectbinding&#34;&gt;2. &lt;code&gt;@ObjectBinding&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;对于更复杂的属性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当你有一个要使用的自定义类型，该类型可能具有多个属性和方法&lt;/li&gt;
&lt;li&gt;可能在多个视图中共享时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，你应该使用 &lt;code&gt;@ObjectBinding&lt;/code&gt;。
这与 &lt;code&gt;@State&lt;/code&gt; 非常相似，只是现在我们使用的是外部引用类型，而不是简单地本地属性，如字符串或整数。我们仍然可以说视图取决于要更改的数据，除了我们负责管理自己的数据: 我们需要创建类的实例，创建自己的属性，等等。&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;@ObjectBinding&lt;/code&gt; 一起使用的任何类型都应该遵循 &lt;code&gt;BindableObject&lt;/code&gt; 协议，该协议只有一个要求: 您的类型必须实现某种类型的 &lt;code&gt;didchange&lt;/code&gt; 属性，该属性在数据发生更改时通知视图。&lt;/p&gt;

&lt;p&gt;这就是我的意思，当我说这是你负责管理自己的数据时——当你在绑定对象上设置一个属性时，你就可以决定是否应该强制视图刷新。你通常会的，但不是必须的。&lt;/p&gt;

&lt;p&gt;一个可绑定的对象可以使用 &lt;code&gt;Combine&lt;/code&gt; 框架中 &lt;em&gt;publisher&lt;/em&gt;  通知其视图重要数据已经更改。如果碰巧有几个视图使用可绑定对象的数据，那么它将自动通知所有这些视图。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;警告:&lt;/strong&gt; 当你使用 &lt;em&gt;publisher&lt;/em&gt; 宣布你的对象已更改，这个动作必须在主线程上执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;3-environmentobject&#34;&gt;3. &lt;code&gt;@EnvironmentObject&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们已经了解了如何通过 &lt;code&gt;@State&lt;/code&gt; 声明一个类型的简单属性，该类型数据在发生更改时自动导致视图更新，以及如何通过 &lt;code&gt;@Objectbinding&lt;/code&gt; 声明外部类型的属性，该属性在更改时可能会或可能不会导致视图更新。这两个都必须由我们的视图设置，但是 &lt;code&gt;@Objectbinding&lt;/code&gt; 可能与其他视图共享。&lt;/p&gt;

&lt;p&gt;针对这种情况，我们还有第三种类型的属性可供使用，即 &lt;code&gt;@EnvironmentObject&lt;/code&gt;。这是一个通过应用程序本身对视图可用的值 -&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它是每个视图都可以读取的共享数据，因此，如果你的应用程序有一些重要的模型数据，所有视图都需要读取，你可以把它从一个视图传递到另一个视图，或者把它放到每个视图都可以即时访问的环境中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们需要在应用程序中传递大量数据时，可以将 &lt;code&gt;@Environmentobject&lt;/code&gt; 视为一种极大的便利。由于所有视图都指向同一模型，因此如果一个视图更改模型，则所有视图都会立即更新 - 不会有使应用程序的不同部分不同的风险。&lt;/p&gt;

&lt;h3 id=&#34;4-总结差异&#34;&gt;4. 总结差异&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;@State&lt;/code&gt; 用于属于单个视图的简单属性。 它们通常应标记为 &lt;code&gt;private&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;@ObjectBinding&lt;/code&gt; 用于可能属于多个视图的复杂属性。 无论何时使用引用类型，都应该使用&lt;code&gt;@ObjectBinding&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 用于在应用程序中其他位置创建的属性，例如共享数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这三种方法中，您会发现 &lt;code&gt;@objectbinding&lt;/code&gt; 是最有用和最常用的，因此如果您不确定要使用哪种方法，请从那里开始。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.14_如何响应视图生命周期事件_appear_and_disappear</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/</link>
      <pubDate>Sun, 28 Jul 2019 20:37:20 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 以 &lt;code&gt;onAppear()&lt;/code&gt; 和 &lt;code&gt;onDisappear()&lt;/code&gt; 的形式为我们提供了 UIKit 的&lt;code&gt;viewDidAppear()&lt;/code&gt; 和 &lt;code&gt;viewDidDisappear()&lt;/code&gt; 的等价物。 您可以将任何代码附加到您想要的这两个事件，SwiftUI 将在它们发生时执行它们。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;注意：在当前的beta版本， onAppear() 工作得很好，但 onDisappear() 似乎没有被调用。
例如: 我们创建两个使用 onAppear() 和 onDisappear() 来打印消息的视图，并使用导航按钮在两者之间移动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView()) {
                Text(&amp;quot;Hello World&amp;quot;)
            }
        }.onAppear {
            print(&amp;quot;ContentView appeared!&amp;quot;)
        }.onDisappear {
            print(&amp;quot;ContentView disappeared!&amp;quot;)
        }
    }
}

struct DetailView : View {
    var body: some View {
        VStack {
            Text(&amp;quot;Second View&amp;quot;)
        }.onAppear {
            print(&amp;quot;DetailView appeared!&amp;quot;)
        }.onDisappear {
            print(&amp;quot;DetailView disappeared!&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_14_live_event_appear_disappear.gif&#34; alt=&#34;3_14_live_event_appear_disappear&#34; title=&#34;onAppear and onDisappear&#34; /&gt;
当代码运行时，我们应该能够在两个视图之间移动，并看到 Xcode 调试控制台中打印的消息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.13_如何给视图添加手势识别器</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/</link>
      <pubDate>Sun, 28 Jul 2019 19:59:32 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;任何 SwiftUI  视图都可以附加手势识别器，而这些手势识别器又可以附加闭包，在识别器被激活时执行闭包。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;有几个手势识别器可供使用，这里我们提供其中几个的代码示例，以帮助入门 - 我们将看到它们有多相似。&lt;/p&gt;

&lt;h4 id=&#34;2-1-tapgesture-点击手势&#34;&gt;2.1 &lt;code&gt;TapGesture&lt;/code&gt; 点击手势&lt;/h4&gt;

&lt;p&gt;创建 TapGesture 时，可以指定触发手势所需的 点击次数，然后附加将在手势发生时运行的 &lt;code&gt;onEnded&lt;/code&gt; 闭包。&lt;/p&gt;

&lt;p&gt;例如，我们来创建一个每次点击时都会变大的图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var scale: Length = 1
    
    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .scaleEffect(scale)
            .gesture(
                TapGesture()
                    .onEnded({ (_) in
                        self.scale += 0.1
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_13_tap_gesture_scale_image.gif&#34; alt=&#34;3_13_tap_gesture_scale_image&#34; title=&#34;Tap to scale a image&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-2-longpressgesture-长按手势&#34;&gt;2.2 &lt;code&gt;LongPressGesture&lt;/code&gt; 长按手势&lt;/h4&gt;

&lt;p&gt;LongPressGesture 可识别用户何时按下视图并保持至少一段用户指定的时间。
因此，我们创建一个图像视图，在按下该消息至少两秒时打印该消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {

    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .gesture(
                LongPressGesture(minimumDuration: 2.0)
                    .onEnded({ (_) in
                            print(&amp;quot;LongPressed!&amp;quot;)
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_13_long_press_gesture_duration_2s.gif&#34; alt=&#34;3_13_long_press_gesture_duration_2s&#34; title=&#34;Long pressed!&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-3-draggesture-拖拽手势&#34;&gt;2.3 &lt;code&gt;DragGesture&lt;/code&gt; 拖拽手势&lt;/h4&gt;

&lt;p&gt;最后，当用户按下视图并移动至少一定距离时，DragGesture 会触发。因此，我们创建一个带有拖动手势的图像，当它们移动至少50个点时会触发:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
 
    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .gesture(
                DragGesture(minimumDistance: 50)
                    .onEnded({ (_) in
                        print(&amp;quot;Dragged!&amp;quot;)
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/3_13_drag_gesture_distance_50.gif&#34; alt=&#34;3_13_drag_gesture_distance_50&#34; title=&#34;Drag gesture&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.12_如何设置tap和double Tap手势</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/</link>
      <pubDate>Sun, 28 Jul 2019 18:38:38 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;任何 SwiftUI 视图都可以附加 &lt;code&gt;点击操作(tap action)&lt;/code&gt;，我们可以指定在触发操作之前应该接收多少次点击。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个文本视图，在点击时将打印消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        Text(&amp;quot;Tap me!&amp;quot;)
            .tapAction {
                print(&amp;quot;Tapped&amp;quot;)
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/tap_gesture_tap_text.gif&#34; alt=&#34;tap_gesture_tap_text&#34; title=&#34;Tap a text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再创建一个图像视图，当双击时将打印消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        Image(&amp;quot;example-img&amp;quot;)
            .tapAction(count: 2) {
                print(&amp;quot;Double tapped!&amp;quot;)
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/tap_gesture_double_tap_image.gif&#34; alt=&#34;tap_gesture_double_tap_image&#34; title=&#34;Double tapped!&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.11_如何创建分段控件并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 10:16:45 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI中 的 &lt;code&gt;SegmentedControl&lt;/code&gt; 与 UIKit中的 &lt;code&gt;UISegmentedControl&lt;/code&gt; 的工作方式类似，但是它需要绑定到某种状态（state），并且必须确保为每个分段（segment）提供一个 tag 标记，以便能够识别它。&lt;strong&gt;分段(Segments) 可以是文本或者图片，其它任何东西都会自动失败&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;我们将创建一个分段控件，该控件使用 &lt;code&gt;favoriteColor&lt;/code&gt; 作为状态属性，并且在下面添加一个文本视图，用于显示所选的任何值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var favoriteColor = 0
    
    var body: some View {
        VStack {
            SegmentedControl(selection: $favoriteColor) {
                Text(&amp;quot;Red&amp;quot;).tag(0)
                Text(&amp;quot;Green&amp;quot;).tag(1)
                Text(&amp;quot;Blue&amp;quot;).tag(2)
            }
            Text(&amp;quot;Value: \(favoriteColor)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/segmented_control_favoritecolor.gif&#34; alt=&#34;segmented_control_favoritecolor&#34; title=&#34;Select a favorite color&#34; /&gt;
不过，在本例中，我们最好创建一个数组来存储各种颜色，然后使用 &lt;em&gt;foreach&lt;/em&gt; 在内部使用循环创建文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var favoriteColor = 0

    var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        VStack {
            SegmentedControl(selection: $favoriteColor) {
                ForEach(0..&amp;lt;colors.count) { index in
                    Text(self.colors[index]).tag(index)
                }
            }
            Text(&amp;quot;Value: \(colors[favoriteColor])&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/segmented_control_favoritecolor_string.gif&#34; alt=&#34;segmented_control_favoritecolor_string&#34; title=&#34;select a favorite color, display with string&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.10_如何创建DatePicker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 00:28:44 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;DatePicker&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UIDatePicker&lt;/code&gt;，它提供了各种选项来控制它的外观和工作方式。和所有存储值的控件一样，它也需要绑定到应用程序中的某种状态。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到 &lt;code&gt;birthDate&lt;/code&gt; 属性的日期选择器，然后显示日期选择器的值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        return formatter
    }
    
    @State var birthDate = Date()
    
    var body: some View {
        VStack {
            DatePicker($birthDate,
                       maximumDate: Date(),
                       displayedComponents: .date)
            Text(&amp;quot;Date is \(birthDate, formatter: dateFormatter)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/datepicker_select_birthdate.gif&#34; alt=&#34;datepicker_select_birthdate&#34; title=&#34;Select birth date&#34; /&gt;
可以看到我已经将 &lt;strong&gt;DisplayedComponents&lt;/strong&gt; 设置为 .Date，但您也可以使用 &lt;code&gt;.hourAndMinute&lt;/code&gt;来获取时间数据。
我还使用 &lt;em&gt;maximumDate&lt;/em&gt; 来阻止人们在将来指定出生日期，但是您可以指定 &lt;em&gt;minimumDate&lt;/em&gt; 来阻止人们指定早于您选择的日期。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.9_如何创建选择器Picker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:56:24 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Picker&lt;/code&gt; 视图将 UIPicker 和 UITableView 结合在一起。同时也适应其它操作系统上的其它样式。最棒的是我们真的不需要关系它是如何工作的 &amp;ndash; SwiftUI 可以很好的自动适应它的环境。
与大多数其它控件一样，必须将 picker 附加到某种 state，以跟踪 picker 的选择。例如: 这会创建一个 colors 数组和一个存储所选颜色的整数，然后将其与 picker，Text 视图一起使用，以便您可以看到正在读取的值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Orange&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Green&amp;quot;]
    @State private var selectedColor = 0
    
    var body: some View {
        VStack {
            Picker(selection: $selectedColor, label: Text(&amp;quot;Please choose a color&amp;quot;)) {
                ForEach(0..&amp;lt;colors.count) {
                    Text(self.colors[$0]).tag($0)
                }
            }
            Text(&amp;quot;You selected: \(colors[selectedColor]) &amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/picker_select_color.gif&#34; alt=&#34;picker_select_color&#34; title=&#34;Selected color&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意: 将选择器视图放在某个内容中非常重要，以确保它在iOS上以默认的轮子样式显示。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.8_如何创建Slider并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:40:23 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Slider&lt;/code&gt; 视图的工作原理与 &lt;code&gt;UISlider&lt;/code&gt; 非常相似，尽管您需要将其绑定到某个地方，以便存储其值。
当我们创建它时，可以提供多种参数，但我们可能最关心的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Value&lt;/code&gt;:  要绑定到的值是多少&lt;/li&gt;
&lt;li&gt;&lt;code&gt;From and To&lt;/code&gt;: 滑块的范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;By&lt;/code&gt;: 移动滑块时要更改多少值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到  Celsius 属性的滑块，然后在滑块移动时更新文本视图，以便在 &lt;strong&gt;Celsius(摄氏温度)&lt;/strong&gt; 和 &lt;strong&gt;Fahrenheit(华氏温度)&lt;/strong&gt; 之间进行转换:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var celsius: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $celsius, from: -100, through: 100, by: 0.1)
                .padding()
            Text(&amp;quot;\(celsius) Celsius is \(celsius * 9 / 5 + 32) Fahrenheit&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/slider_celsius_to_fahrenheit.gif&#34; alt=&#34;slider_celsius_to_fahrenheit&#34; title=&#34;celsius to fahrenheit&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.7_如何使用SecureField创建一个安全的文本输入框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 23:33:00 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;SecureTextField&lt;/code&gt; 的工作方式与常规的 &lt;code&gt;TextField&lt;/code&gt; 完全相同，只是为了保护隐私而屏蔽了字符。当然，它绑定的底层值（underlying value）仍然是一个普通的字符串，因此你可以根据需要检查它。
下面是一个示例，创建了一个绑定到本地 &lt;code&gt;@State&lt;/code&gt;  属性的 &lt;code&gt;SecureField&lt;/code&gt;，以便我们显示键入的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var password = &amp;quot;&amp;quot;
    
    var body: some View {
        VStack {
            SecureField($password, placeholder: Text(&amp;quot;Enter your password:&amp;quot;))
                .padding()
            Text(&amp;quot;Your entered: \(password)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/securefield_enter_password.gif&#34; alt=&#34;securefield_enter_password&#34; title=&#34;enter a password&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提示: 在 beta1 和 beta2 中，你应该使用:
SecureField($password)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.6_如何给TextField添加占位符</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</link>
      <pubDate>Sat, 27 Jul 2019 22:59:59 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 支持占位符文本，就像 &lt;code&gt;UITextField&lt;/code&gt; 一样 &amp;ndash; 当 TextField 为空时在 TextField 中显示灰色文本。要么使用提示（”Enter your password“），要么显示一些示例数据。&lt;/p&gt;

&lt;p&gt;要设置 placeholder，请将其作为 TextField 初始化设置的一部分传入，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var emailAddress = &amp;quot;&amp;quot;
    
    var body: some View {
        TextField($emailAddress, placeholder: Text(&amp;quot;test@gmail.com&amp;quot;))
            .textFieldStyle(.roundedBorder)
            .padding()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/textfield_placeholder.png &amp;quot;Set a placeholder for text field&#34; alt=&#34;textfield_placeholder&#34; /&gt;
这将在 TextField 中显示占位文本 &lt;code&gt;test@gmail.com&lt;/code&gt;，而 TextField 为空，但一旦用户在其中键入内容，占位文本就会消失。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.5_如何给TextField添加边框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 22:42:34 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更愿意在 &lt;code&gt;TextField&lt;/code&gt; 周围添加边框，以使其更清晰。
如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 &lt;code&gt;.textFieldStyle(.roundedBorder)&lt;/code&gt; 修饰符，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var text = &amp;quot;&amp;quot;
    var body: some View {
        TextField($text, placeholder: Text(&amp;quot;Enter some text&amp;quot;))
            .padding()
            .textFieldStyle(.roundedBorder)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/textfield_style_rounded_border.png&#34; alt=&#34;textfield_style_rounded_border&#34; title=&#34;textFieldStyle is roundedBorder style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.4_如何从TextField中读取文本</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</link>
      <pubDate>Sat, 27 Jul 2019 21:42:21 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UITextField&lt;/code&gt;，但是，在默认情况下 &lt;code&gt;TextField&lt;/code&gt; 看起来有点不同，并且它非常依赖于 &lt;strong&gt;状态绑定（binding to state）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-创建-textfield&#34;&gt;2. 创建 TextField&lt;/h3&gt;

&lt;p&gt;那么，要创建一个 TextField，我们应该给在 &lt;em&gt;text field&lt;/em&gt; 传入一个 &lt;code&gt;placeholder&lt;/code&gt;，再加上它应该绑定到的状态属性。&lt;/p&gt;

&lt;p&gt;例如: 现在，我们要创建一个 &lt;strong&gt;绑定到本地字符串的 TextField&lt;/strong&gt;，然后在其下面放置一个文本视图，在键入时显示 TextField 的输出:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var name = &amp;quot;Devin&amp;quot;
    
    var body: some View {
        VStack {
            TextField($name, placeholder: Text(&amp;quot;Enter your name&amp;quot;))
            Text(&amp;quot;Hello, \(name)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后，您应该能够在 TextField 中键入内容，并看到下面直接显示一条问候语。
运行效果:
&lt;img src=&#34;img/textfield_enter_your_name.gif&#34; alt=&#34;textfield_enter_your_name&#34; title=&#34;Enter your name&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提示: 在 beta1 和 beta2 中，应该改用 TextField($name)。
使用 TextField 时有两个重要的限制条件。首先，默认情况下，它没有边框，因此你可能看不到任何内容 &amp;ndash; 你需要大致点击其所在位置，以激活键盘。
其次，您可能会发现无法在布局的画布预览中键入内容。如果遇到这个问题，请按Cmd+R在模拟器中构建和运行代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.3_如何创建一个可点击的按钮</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</link>
      <pubDate>Sat, 27 Jul 2019 16:21:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-button-vs-uibutton&#34;&gt;1. Button vs UIButton&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;按钮(Button)&lt;/code&gt; 类似于 UIKit 中的 &lt;code&gt;UIButton&lt;/code&gt;，跟 UIButton 的区别在于:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在显示内容方面 SwiftUI 的按钮更为灵活&lt;/li&gt;
&lt;li&gt;SwiftUI 的按钮使用 &lt;code&gt;闭包&lt;/code&gt; 来实现其 action，而 UIButton 使用的是 &lt;code&gt;target/action&lt;/code&gt; 系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-button-初体验&#34;&gt;2. Button 初体验&lt;/h3&gt;

&lt;p&gt;那么，如何创建一个 SwiftUI 的按钮呢?，我们可以从以下代码开始:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Button(action: {
    // your action here
            
}) {
    Text(&amp;quot;Button title&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由以上代码可以看到，创建 Button 的的方法有两个参数，都是闭包，第一个闭包负责传入 action，第二个闭包负责传入按钮上的文本。&lt;/p&gt;

&lt;h3 id=&#34;3-button-简单用例&#34;&gt;3. Button 简单用例&lt;/h3&gt;

&lt;p&gt;例如: 我们可以创建一个按钮，在点击按钮时显示或隐藏一些详细信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showDetails = false
    
    var body: some View {
        VStack {
            Button(action: {
               self.showDetails.toggle()
            }) {
                Text(&amp;quot;Show detail information&amp;quot;)
            }
            
            if showDetails {
                Text(&amp;quot;You should follow me on M X Website&amp;quot;)
                    .font(.largeTitle)
                    .lineLimit(nil)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/button_show_detail_information.gif&#34; alt=&#34;button_show_detail_information&#34; title=&#34;Click button to show detail information&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-提示&#34;&gt;4. 提示&lt;/h3&gt;

&lt;p&gt;在学习框架时最常做的事情是分散调用 &lt;code&gt;print()&lt;/code&gt;，这样我们就可以看到什么时候发生了什么事情。 如果我们想通过按钮 action 来尝试，首先应右键单击预览画布中的播放按钮，然后选择 &lt;strong&gt;调试预览&lt;/strong&gt;，以便调用 &lt;code&gt;print()&lt;/code&gt; 工作。
按钮内的标题可以是任何类型的视图，因此您可以创建这样的图像按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Button(action: {
    self.showDetails.toggle()
}) {
    Image(&amp;quot;example-image&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/button_image_show_detail.gif&#34; alt=&#34;button_image_show_detail&#34; title=&#34;Set an image for button&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.2_如何创建拨动开关</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/</link>
      <pubDate>Sat, 27 Jul 2019 15:55:42 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;toggle&lt;/code&gt; 允许用户在 &lt;strong&gt;true&lt;/strong&gt; 和 &lt;strong&gt;false&lt;/strong&gt; 之间移动，就像 UIKit 中的 &lt;code&gt;UISwitch&lt;/code&gt; 一样。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;我们可以创建一个 &lt;em&gt;toggle&lt;/em&gt; ，然后根据 &lt;em&gt;toggle&lt;/em&gt; 是否启动来决定显示或者不显示消息。但是我们不希望手动跟踪 &lt;em&gt;toggle&lt;/em&gt; 的状态 &amp;ndash; 我们希望 SwiftUI 为我们做这件事。
与以往不同，在这里，我们应该定义一个 &lt;code&gt;@State Boolean&lt;/code&gt; 属性，用于存储 toggle 的当前值。然后我们可以使用它来显示或隐藏其它视图。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showGreeting = true
    
    var body: some View {
        VStack {
            Toggle(isOn: $showGreeting) {
                Text(&amp;quot;Show welcome message!&amp;quot;)
            }.padding()
            
            if showGreeting {
                Text(&amp;quot;Hello world&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/toggle_show_welcomemessage.gif&#34; alt=&#34;toggle_show_welcomemessage&#34; title=&#34;Show welcome message&#34; /&gt;
这段代码，只有当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;true&lt;/em&gt; 时才会返回文本视图，这意味着当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;false&lt;/em&gt; 时，&lt;code&gt;VStack&lt;/code&gt; 的大小会减小 - 它的堆栈中没有第二个视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.1_使用 state</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</link>
      <pubDate>Fri, 26 Jul 2019 22:48:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-概念&#34;&gt;1. 概念&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;所有应用程序都会改变状态。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户可能点击了一个按钮来显示更多信息&lt;/li&gt;
&lt;li&gt;用户可能已经在文本框中输入了一些文本&lt;/li&gt;
&lt;li&gt;用户从日期选择器中选择了一个日期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有涉及应用程序 &lt;strong&gt;从一种状态转变到另一种状态&lt;/strong&gt; 的事情，都叫做应用程序改变状态。&lt;/p&gt;

&lt;h3 id=&#34;2-问题所在&#34;&gt;2. 问题所在&lt;/h3&gt;

&lt;p&gt;状态的问题在于它是混乱的: &lt;strong&gt;当它发生变化时，我们需要发现变化并更新我们的布局来匹配变化&lt;/strong&gt;。 这个一开始听起来可能很简单，但是随着我们的状态的不断增长，它就会变得越来越难 - 因为这个时候，我们很容易忘记更新一件事，或者更新顺序出错，以致于用户界面状态达不到预期效果。&lt;/p&gt;

&lt;h3 id=&#34;3-swiftui-如何破解&#34;&gt;3. SwiftUI 如何破解？&lt;/h3&gt;

&lt;p&gt;SwiftUI 通过 &lt;strong&gt;从控件中移除状态&lt;/strong&gt; 来解决这个问题。&lt;/p&gt;

&lt;p&gt;当我们向视图添加属性时，这些属性实际上是惰性的 - 当然，它们有值，但是更改这些值并不会做任何事情。 但是如果我们在这些属性之前添加了特殊的&lt;code&gt;@State&lt;/code&gt; 来包装属性，SwiftUI将自动监视属性变化并更新使用该属性的视图的任何部分。&lt;/p&gt;

&lt;p&gt;示例代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@state var name: String = &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;code&gt;@state&lt;/code&gt; 这种语法称为 属性包装器，这里不作详细介绍，可以自行查找文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当涉及到某种状态时 - 例如，当切换开关（toggle switch）改变时告诉状态属性改变。
&lt;strong&gt;这里需要注意的是&lt;/strong&gt;: 我们不能直接引用这个属性属性。这是因为 Swift 会认为我们现在所指的是&lt;code&gt;&amp;quot;属性当前的值&amp;quot;&lt;/code&gt;，而不是说 &lt;code&gt;&amp;quot;请注意这件事情(属性状态变化)&amp;quot;&lt;/code&gt;。幸运的是，SwiftUI 的解决方案是在属性名称前放置一个&lt;code&gt;美元符号($)&lt;/code&gt;，这样的话，我们就可以引用属性本身而不是它当前的值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当然，这里一开始理解起有点令人困惑，但在当我们学习一两个示例之后就会理解，非常简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，请记住，SwiftUI 是声明性的，这意味着我们预先告诉它所有可能状态的所有布局，并让它知道当属性发生变化时如何在它们之间移动。我们称之为 &lt;strong&gt;&lt;em&gt;绑定（binding）&lt;/em&gt;&lt;/strong&gt; - 要求 SwiftUI 同步UI控件和底层属性之间的更改。
如果你已经习惯了一种更为迫切的编程风格，那么使用 state 一开始会让你头疼一些，但不要担心 - 一旦你完成了它，你就很明确了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.8_如何将视图放到安全区域之外</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</link>
      <pubDate>Fri, 26 Jul 2019 22:12:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;默认情况下，我们的 SwiftUI 视图将主要位于安全区域内 - 它将会到达屏幕底部，但不会靠近设备顶部的任何凹口。
如果我们想改变它 - 想让视图真正全屏，即使这意味着被一个缺口或其他硬件切口部分遮挡 - 那么我们应该使用 &lt;code&gt;edgesIgnoringSafeArea()&lt;/code&gt; 修饰符。
例如，这会创建一个红色文本视图，要求填充所有可用空间，然后将其设置为忽略任何安全区域，以使其真正边缘到边缘。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello World&amp;quot;)
        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)    
        .background(Color.red)
        .edgesIgnoringSafeArea(.all)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/edgesIgnoringSafeArea.png&#34; alt=&#34;edgesIgnoringSafeArea&#34; title=&#34;edgesIgnoringSafeArea all&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.7_如何使用size_classes创建不同的布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 26 Jul 2019 16:52:17 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 通过在环境中暴露 &lt;em&gt;size classes&lt;/em&gt; 来原生支持它。如果要使用它，我们首先需要创建一个 &lt;code&gt;@Environment&lt;/code&gt; 对象来存储其值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Environment(\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在我们需要时检查该属性的值，查找 &lt;code&gt;.compact&lt;/code&gt; 或 &lt;code&gt;.regular&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if horizontalSizeClass == .compact {
    return Text(&amp;quot;Compact&amp;quot;)
} else {
    return Text(&amp;quot;Regular&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将所有代码组合在一起，可以创建这样的视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @Environment(\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?
    
    var body: some View {
        if horizontalSizeClass == .compact {
            return Text(&amp;quot;Compact&amp;quot;)
        } else {
            return Text(&amp;quot;Regular&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:&lt;/p&gt;

&lt;p&gt;(1) 正向竖屏
&lt;img src=&#34;img/size_classes_compact.png&#34; alt=&#34;size_classes_compact&#34; title=&#34;Text - Compact&#34; /&gt;
(2) 横屏 - 刘海在右侧
&lt;img src=&#34;img/size_classes_regular01.png&#34; alt=&#34;size_classes_regular01&#34; title=&#34;Text - Regular01&#34; /&gt;
(3) 横屏 - 刘海在左侧
&lt;img src=&#34;img/size_classes_regular02.png&#34; alt=&#34;size_classes_regular02&#34; title=&#34;Text - Regular02&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
