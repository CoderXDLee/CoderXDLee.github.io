<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SwiftUI on M X</title>
    <link>https://coderxdlee.github.io/categories/swiftui/</link>
    <description>Recent content in SwiftUI on M X</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>M X ©{year}</copyright>
    <lastBuildDate>Sun, 28 Jul 2019 10:16:45 +0800</lastBuildDate>
    
	    <atom:link href="https://coderxdlee.github.io/categories/swiftui/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>3.11_如何创建分段控件并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 10:16:45 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>&lt;!-- more --&gt;
</description>
    </item>
    
    <item>
      <title>3.10_如何创建DatePicker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 00:28:44 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;DatePicker&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UIDatePicker&lt;/code&gt;，它提供了各种选项来控制它的外观和工作方式。和所有存储值的控件一样，它也需要绑定到应用程序中的某种状态。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到 &lt;code&gt;birthDate&lt;/code&gt; 属性的日期选择器，然后显示日期选择器的值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        return formatter
    }
    
    @State var birthDate = Date()
    
    var body: some View {
        VStack {
            DatePicker($birthDate,
                       maximumDate: Date(),
                       displayedComponents: .date)
            Text(&amp;quot;Date is \(birthDate, formatter: dateFormatter)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/datepicker_select_birthdate.gif&#34; alt=&#34;datepicker_select_birthdate&#34; title=&#34;Select birth date&#34; /&gt;
可以看到我已经将 &lt;strong&gt;DisplayedComponents&lt;/strong&gt; 设置为 .Date，但您也可以使用 &lt;code&gt;.hourAndMinute&lt;/code&gt;来获取时间数据。
我还使用 &lt;em&gt;maximumDate&lt;/em&gt; 来阻止人们在将来指定出生日期，但是您可以指定 &lt;em&gt;minimumDate&lt;/em&gt; 来阻止人们指定早于您选择的日期。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.9_如何创建选择器Picker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:56:24 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Picker&lt;/code&gt; 视图将 UIPicker 和 UITableView 结合在一起。同时也适应其它操作系统上的其它样式。最棒的是我们真的不需要关系它是如何工作的 &amp;ndash; SwiftUI 可以很好的自动适应它的环境。
与大多数其它控件一样，必须将 picker 附加到某种 state，以跟踪 picker 的选择。例如: 这会创建一个 colors 数组和一个存储所选颜色的整数，然后将其与 picker，Text 视图一起使用，以便您可以看到正在读取的值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Orange&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Green&amp;quot;]
    @State private var selectedColor = 0
    
    var body: some View {
        VStack {
            Picker(selection: $selectedColor, label: Text(&amp;quot;Please choose a color&amp;quot;)) {
                ForEach(0..&amp;lt;colors.count) {
                    Text(self.colors[$0]).tag($0)
                }
            }
            Text(&amp;quot;You selected: \(colors[selectedColor]) &amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/picker_select_color.gif&#34; alt=&#34;picker_select_color&#34; title=&#34;Selected color&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意: 将选择器视图放在某个内容中非常重要，以确保它在iOS上以默认的轮子样式显示。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.8_如何创建Slider并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:40:23 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Slider&lt;/code&gt; 视图的工作原理与 &lt;code&gt;UISlider&lt;/code&gt; 非常相似，尽管您需要将其绑定到某个地方，以便存储其值。
当我们创建它时，可以提供多种参数，但我们可能最关心的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Value&lt;/code&gt;:  要绑定到的值是多少&lt;/li&gt;
&lt;li&gt;&lt;code&gt;From and To&lt;/code&gt;: 滑块的范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;By&lt;/code&gt;: 移动滑块时要更改多少值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到  Celsius 属性的滑块，然后在滑块移动时更新文本视图，以便在 &lt;strong&gt;Celsius(摄氏温度)&lt;/strong&gt; 和 &lt;strong&gt;Fahrenheit(华氏温度)&lt;/strong&gt; 之间进行转换:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var celsius: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $celsius, from: -100, through: 100, by: 0.1)
                .padding()
            Text(&amp;quot;\(celsius) Celsius is \(celsius * 9 / 5 + 32) Fahrenheit&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/slider_celsius_to_fahrenheit.gif&#34; alt=&#34;slider_celsius_to_fahrenheit&#34; title=&#34;celsius to fahrenheit&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.7_如何使用SecureField创建一个安全的文本输入框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 23:33:00 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;SecureTextField&lt;/code&gt; 的工作方式与常规的 &lt;code&gt;TextField&lt;/code&gt; 完全相同，只是为了保护隐私而屏蔽了字符。当然，它绑定的底层值（underlying value）仍然是一个普通的字符串，因此你可以根据需要检查它。
下面是一个示例，创建了一个绑定到本地 &lt;code&gt;@State&lt;/code&gt;  属性的 &lt;code&gt;SecureField&lt;/code&gt;，以便我们显示键入的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var password = &amp;quot;&amp;quot;
    
    var body: some View {
        VStack {
            SecureField($password, placeholder: Text(&amp;quot;Enter your password:&amp;quot;))
                .padding()
            Text(&amp;quot;Your entered: \(password)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/securefield_enter_password.gif&#34; alt=&#34;securefield_enter_password&#34; title=&#34;enter a password&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提示: 在 beta1 和 beta2 中，你应该使用:
SecureField($password)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.6_如何给TextField添加占位符</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</link>
      <pubDate>Sat, 27 Jul 2019 22:59:59 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 支持占位符文本，就像 &lt;code&gt;UITextField&lt;/code&gt; 一样 &amp;ndash; 当 TextField 为空时在 TextField 中显示灰色文本。要么使用提示（”Enter your password“），要么显示一些示例数据。&lt;/p&gt;

&lt;p&gt;要设置 placeholder，请将其作为 TextField 初始化设置的一部分传入，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var emailAddress = &amp;quot;&amp;quot;
    
    var body: some View {
        TextField($emailAddress, placeholder: Text(&amp;quot;test@gmail.com&amp;quot;))
            .textFieldStyle(.roundedBorder)
            .padding()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/textfield_placeholder.png &amp;quot;Set a placeholder for text field&#34; alt=&#34;textfield_placeholder&#34; /&gt;
这将在 TextField 中显示占位文本 &lt;code&gt;test@gmail.com&lt;/code&gt;，而 TextField 为空，但一旦用户在其中键入内容，占位文本就会消失。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.5_如何给TextField添加边框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 22:42:34 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更愿意在 &lt;code&gt;TextField&lt;/code&gt; 周围添加边框，以使其更清晰。
如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 &lt;code&gt;.textFieldStyle(.roundedBorder)&lt;/code&gt; 修饰符，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var text = &amp;quot;&amp;quot;
    var body: some View {
        TextField($text, placeholder: Text(&amp;quot;Enter some text&amp;quot;))
            .padding()
            .textFieldStyle(.roundedBorder)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/textfield_style_rounded_border.png&#34; alt=&#34;textfield_style_rounded_border&#34; title=&#34;textFieldStyle is roundedBorder style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.4_如何从TextField中读取文本</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</link>
      <pubDate>Sat, 27 Jul 2019 21:42:21 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UITextField&lt;/code&gt;，但是，在默认情况下 &lt;code&gt;TextField&lt;/code&gt; 看起来有点不同，并且它非常依赖于 &lt;strong&gt;状态绑定（binding to state）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-创建-textfield&#34;&gt;2. 创建 TextField&lt;/h3&gt;

&lt;p&gt;那么，要创建一个 TextField，我们应该给在 &lt;em&gt;text field&lt;/em&gt; 传入一个 &lt;code&gt;placeholder&lt;/code&gt;，再加上它应该绑定到的状态属性。&lt;/p&gt;

&lt;p&gt;例如: 现在，我们要创建一个 &lt;strong&gt;绑定到本地字符串的 TextField&lt;/strong&gt;，然后在其下面放置一个文本视图，在键入时显示 TextField 的输出:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var name = &amp;quot;Devin&amp;quot;
    
    var body: some View {
        VStack {
            TextField($name, placeholder: Text(&amp;quot;Enter your name&amp;quot;))
            Text(&amp;quot;Hello, \(name)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后，您应该能够在 TextField 中键入内容，并看到下面直接显示一条问候语。
运行效果:
&lt;img src=&#34;img/textfield_enter_your_name.gif&#34; alt=&#34;textfield_enter_your_name&#34; title=&#34;Enter your name&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提示: 在 beta1 和 beta2 中，应该改用 TextField($name)。
使用 TextField 时有两个重要的限制条件。首先，默认情况下，它没有边框，因此你可能看不到任何内容 &amp;ndash; 你需要大致点击其所在位置，以激活键盘。
其次，您可能会发现无法在布局的画布预览中键入内容。如果遇到这个问题，请按Cmd+R在模拟器中构建和运行代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.3_如何创建一个可点击的按钮</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</link>
      <pubDate>Sat, 27 Jul 2019 16:21:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-button-vs-uibutton&#34;&gt;1. Button vs UIButton&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;按钮(Button)&lt;/code&gt; 类似于 UIKit 中的 &lt;code&gt;UIButton&lt;/code&gt;，跟 UIButton 的区别在于:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在显示内容方面 SwiftUI 的按钮更为灵活&lt;/li&gt;
&lt;li&gt;SwiftUI 的按钮使用 &lt;code&gt;闭包&lt;/code&gt; 来实现其 action，而 UIButton 使用的是 &lt;code&gt;target/action&lt;/code&gt; 系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-button-初体验&#34;&gt;2. Button 初体验&lt;/h3&gt;

&lt;p&gt;那么，如何创建一个 SwiftUI 的按钮呢?，我们可以从以下代码开始:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Button(action: {
    // your action here
            
}) {
    Text(&amp;quot;Button title&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由以上代码可以看到，创建 Button 的的方法有两个参数，都是闭包，第一个闭包负责传入 action，第二个闭包负责传入按钮上的文本。&lt;/p&gt;

&lt;h3 id=&#34;3-button-简单用例&#34;&gt;3. Button 简单用例&lt;/h3&gt;

&lt;p&gt;例如: 我们可以创建一个按钮，在点击按钮时显示或隐藏一些详细信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showDetails = false
    
    var body: some View {
        VStack {
            Button(action: {
               self.showDetails.toggle()
            }) {
                Text(&amp;quot;Show detail information&amp;quot;)
            }
            
            if showDetails {
                Text(&amp;quot;You should follow me on M X Website&amp;quot;)
                    .font(.largeTitle)
                    .lineLimit(nil)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/button_show_detail_information.gif&#34; alt=&#34;button_show_detail_information&#34; title=&#34;Click button to show detail information&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-提示&#34;&gt;4. 提示&lt;/h3&gt;

&lt;p&gt;在学习框架时最常做的事情是分散调用 &lt;code&gt;print()&lt;/code&gt;，这样我们就可以看到什么时候发生了什么事情。 如果我们想通过按钮 action 来尝试，首先应右键单击预览画布中的播放按钮，然后选择 &lt;strong&gt;调试预览&lt;/strong&gt;，以便调用 &lt;code&gt;print()&lt;/code&gt; 工作。
按钮内的标题可以是任何类型的视图，因此您可以创建这样的图像按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Button(action: {
    self.showDetails.toggle()
}) {
    Image(&amp;quot;example-image&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/button_image_show_detail.gif&#34; alt=&#34;button_image_show_detail&#34; title=&#34;Set an image for button&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.2_如何创建拨动开关</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/</link>
      <pubDate>Sat, 27 Jul 2019 15:55:42 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;toggle&lt;/code&gt; 允许用户在 &lt;strong&gt;true&lt;/strong&gt; 和 &lt;strong&gt;false&lt;/strong&gt; 之间移动，就像 UIKit 中的 &lt;code&gt;UISwitch&lt;/code&gt; 一样。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;我们可以创建一个 &lt;em&gt;toggle&lt;/em&gt; ，然后根据 &lt;em&gt;toggle&lt;/em&gt; 是否启动来决定显示或者不显示消息。但是我们不希望手动跟踪 &lt;em&gt;toggle&lt;/em&gt; 的状态 &amp;ndash; 我们希望 SwiftUI 为我们做这件事。
与以往不同，在这里，我们应该定义一个 &lt;code&gt;@State Boolean&lt;/code&gt; 属性，用于存储 toggle 的当前值。然后我们可以使用它来显示或隐藏其它视图。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showGreeting = true
    
    var body: some View {
        VStack {
            Toggle(isOn: $showGreeting) {
                Text(&amp;quot;Show welcome message!&amp;quot;)
            }.padding()
            
            if showGreeting {
                Text(&amp;quot;Hello world&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/toggle_show_welcomemessage.gif&#34; alt=&#34;toggle_show_welcomemessage&#34; title=&#34;Show welcome message&#34; /&gt;
这段代码，只有当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;true&lt;/em&gt; 时才会返回文本视图，这意味着当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;false&lt;/em&gt; 时，&lt;code&gt;VStack&lt;/code&gt; 的大小会减小 - 它的堆栈中没有第二个视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.1_使用 state</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</link>
      <pubDate>Fri, 26 Jul 2019 22:48:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-概念&#34;&gt;1. 概念&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;所有应用程序都会改变状态。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户可能点击了一个按钮来显示更多信息&lt;/li&gt;
&lt;li&gt;用户可能已经在文本框中输入了一些文本&lt;/li&gt;
&lt;li&gt;用户从日期选择器中选择了一个日期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有涉及应用程序 &lt;strong&gt;从一种状态转变到另一种状态&lt;/strong&gt; 的事情，都叫做应用程序改变状态。&lt;/p&gt;

&lt;h3 id=&#34;2-问题所在&#34;&gt;2. 问题所在&lt;/h3&gt;

&lt;p&gt;状态的问题在于它是混乱的: &lt;strong&gt;当它发生变化时，我们需要发现变化并更新我们的布局来匹配变化&lt;/strong&gt;。 这个一开始听起来可能很简单，但是随着我们的状态的不断增长，它就会变得越来越难 - 因为这个时候，我们很容易忘记更新一件事，或者更新顺序出错，以致于用户界面状态达不到预期效果。&lt;/p&gt;

&lt;h3 id=&#34;3-swiftui-如何破解&#34;&gt;3. SwiftUI 如何破解？&lt;/h3&gt;

&lt;p&gt;SwiftUI 通过 &lt;strong&gt;从控件中移除状态&lt;/strong&gt; 来解决这个问题。&lt;/p&gt;

&lt;p&gt;当我们向视图添加属性时，这些属性实际上是惰性的 - 当然，它们有值，但是更改这些值并不会做任何事情。 但是如果我们在这些属性之前添加了特殊的&lt;code&gt;@State&lt;/code&gt; 来包装属性，SwiftUI将自动监视属性变化并更新使用该属性的视图的任何部分。&lt;/p&gt;

&lt;p&gt;示例代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@state var name: String = &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;code&gt;@state&lt;/code&gt; 这种语法称为 属性包装器，这里不作详细介绍，可以自行查找文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当涉及到某种状态时 - 例如，当切换开关（toggle switch）改变时告诉状态属性改变。
&lt;strong&gt;这里需要注意的是&lt;/strong&gt;: 我们不能直接引用这个属性属性。这是因为 Swift 会认为我们现在所指的是&lt;code&gt;&amp;quot;属性当前的值&amp;quot;&lt;/code&gt;，而不是说 &lt;code&gt;&amp;quot;请注意这件事情(属性状态变化)&amp;quot;&lt;/code&gt;。幸运的是，SwiftUI 的解决方案是在属性名称前放置一个&lt;code&gt;美元符号($)&lt;/code&gt;，这样的话，我们就可以引用属性本身而不是它当前的值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当然，这里一开始理解起有点令人困惑，但在当我们学习一两个示例之后就会理解，非常简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，请记住，SwiftUI 是声明性的，这意味着我们预先告诉它所有可能状态的所有布局，并让它知道当属性发生变化时如何在它们之间移动。我们称之为 &lt;strong&gt;&lt;em&gt;绑定（binding）&lt;/em&gt;&lt;/strong&gt; - 要求 SwiftUI 同步UI控件和底层属性之间的更改。
如果你已经习惯了一种更为迫切的编程风格，那么使用 state 一开始会让你头疼一些，但不要担心 - 一旦你完成了它，你就很明确了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.8_如何将视图放到安全区域之外</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</link>
      <pubDate>Fri, 26 Jul 2019 22:12:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;默认情况下，我们的 SwiftUI 视图将主要位于安全区域内 - 它将会到达屏幕底部，但不会靠近设备顶部的任何凹口。
如果我们想改变它 - 想让视图真正全屏，即使这意味着被一个缺口或其他硬件切口部分遮挡 - 那么我们应该使用 &lt;code&gt;edgesIgnoringSafeArea()&lt;/code&gt; 修饰符。
例如，这会创建一个红色文本视图，要求填充所有可用空间，然后将其设置为忽略任何安全区域，以使其真正边缘到边缘。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello World&amp;quot;)
        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)    
        .background(Color.red)
        .edgesIgnoringSafeArea(.all)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/edgesIgnoringSafeArea.png&#34; alt=&#34;edgesIgnoringSafeArea&#34; title=&#34;edgesIgnoringSafeArea all&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.7_如何使用size_classes创建不同的布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 26 Jul 2019 16:52:17 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 通过在环境中暴露 &lt;em&gt;size classes&lt;/em&gt; 来原生支持它。如果要使用它，我们首先需要创建一个 &lt;code&gt;@Environment&lt;/code&gt; 对象来存储其值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Environment(\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在我们需要时检查该属性的值，查找 &lt;code&gt;.compact&lt;/code&gt; 或 &lt;code&gt;.regular&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if horizontalSizeClass == .compact {
    return Text(&amp;quot;Compact&amp;quot;)
} else {
    return Text(&amp;quot;Regular&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将所有代码组合在一起，可以创建这样的视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @Environment(\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?
    
    var body: some View {
        if horizontalSizeClass == .compact {
            return Text(&amp;quot;Compact&amp;quot;)
        } else {
            return Text(&amp;quot;Regular&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:&lt;/p&gt;

&lt;p&gt;(1) 正向竖屏
&lt;img src=&#34;img/size_classes_compact.png&#34; alt=&#34;size_classes_compact&#34; title=&#34;Text - Compact&#34; /&gt;
(2) 横屏 - 刘海在右侧
&lt;img src=&#34;img/size_classes_regular01.png&#34; alt=&#34;size_classes_regular01&#34; title=&#34;Text - Regular01&#34; /&gt;
(3) 横屏 - 刘海在左侧
&lt;img src=&#34;img/size_classes_regular02.png&#34; alt=&#34;size_classes_regular02&#34; title=&#34;Text - Regular02&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
