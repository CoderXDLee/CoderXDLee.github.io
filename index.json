[{"authors":["admin"],"categories":null,"content":" Revere Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","date":1565447470,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1565447470,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://coderxdlee.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":" Revere Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","tags":null,"title":"M X","type":"authors"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 拥有强大的标题功能，但也有许多较小的提示和技巧可以帮助我们编写更好的应用程序。\n1. 恢复实时预览(Resume the live preview) 在编写代码时对我们的布局进行实时预览是 Xcode 的一个很好的功能，但是我们通常会看到它暂停了，因为我们做了很多更改，而 Xcode 无法跟上。 这是 SwiftUI 开发者最重要的键盘快捷键: 按 Option + Cmd + P 可立即重新加载预览窗口，并恢复其实时更新，而不是一直通过触摸板来按 Resume。\n2. 使 @State 私有化(Make @State private) 3. 具有常量绑定的原型(Prototype with constant bindings) 4. 显示测试视图(Presenting test views) 5. 超过10个视图限制(Go past the 10 view limit) 6. 使用语义颜色(Use semantic colors) 7. 依靠自适应填充(Rely on adaptive padding) 8. 合并文本视图(Combine text views) 9. 如何使 print() 工作(How to make print() work) 10. 依赖隐式 HStack(Relying on the implicit HStack) 11. 分割大视图(Splitting up large views) 12. 更好的预览(Better previewing) 13. 创建自定义修改器(Create custom modifiers) 14.轻松设置更改动画(Animate changes easily) 15. 从绑定中发布新值(Publishing new values from a binding) 16. ","date":1565447470,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565447470,"objectID":"fc63bce51d1d74979fb6c2bcac8f4936","permalink":"https://coderxdlee.github.io/post/swiftui/14-swift_tips_and_tricks/14-swiftui%E7%9A%84%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7/","publishdate":"2019-08-10T22:31:10+08:00","relpermalink":"/post/swiftui/14-swift_tips_and_tricks/14-swiftui%E7%9A%84%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7/","section":"post","summary":" ","tags":["SwiftUI tips and tricks"],"title":"14_SwiftUI的提示和技巧","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 Xcode 的 Instruments 工具为 SwiftUI 提供了一套出色的分析功能，允许我们确定重新绘制视图的频率、计算视图主体的缓慢次数，甚至可以确定状态随时间的变化情况。\n2. 准备工作 首先，我们需要一些能够提供我们在 Instruments 中可以看到的有趣结果的东西。所以，这段代码创建了一个计时器，它每隔0.01秒触发一次，并且有一个显示随机UUID的Body视图和一个按钮，每当点击它时会增加它显示的值:\nimport Combine import SwiftUI class FrequentUpdater: ObservableObject, Identifiable { var didChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var timer: Timer? init() { timer = Timer.scheduledTimer( withTimeInterval: 0.01, repeats: true ) { _ in self.didChange.send(()) } } } struct ContentView : View { @ObservedObject var updater = FrequentUpdater() @State var tapCount = 0 var body: some View { VStack { Text(\u0026quot;\\(UUID().uuidString)\u0026quot;) Button(action: { self.tapCount += 1 }) { Text(\u0026quot;Tap count: \\(tapCount)\u0026quot;) } } } }  如果我们在模拟器中运行该代码，我们将看到它不断重绘，因为它的值始终在变化。\n 注意: 这是一个专门设计的压力测试，旨在使 SwiftUI 做很多工作，以便 Instruments 向我们展示有趣的数据 - 我们不想在实际应用中使用上述代码。\n 3. 检测我们的代码 现在按 Cmd + I 通过 Instruments 运行代码，然后选择 SwiftUI instruments。 出现时，按录制按钮使其启动应用程序并开始观看。 现在让它运行几秒钟，同时单击按钮十次左右，然后在仪器中按停止 - 我们有足够的数据可以使用。\n默认情况下，SwiftUI仪器会告诉我们很多事情:\n 在这段时间内创建了多少个视图以及创建这些视图需要多长时间（\u0026rdquo;View Body\u0026rdquo;）。 视图的属性是什么以及它们随时间的变化（\u0026rdquo;View Properties\u0026rdquo;）。 发生了多少个核心动画提交（\u0026rdquo;Core Animation Commits\u0026rdquo;）。 每个函数调用所用的确切时间（\u0026rdquo;Time Profiler\u0026rdquo;）。  这些工具中的每一个都可以帮助我们诊断和解决 SwiftUI 应用程序中的性能问题，因此值得花时间尝试一下。\n对于我们的小压力测试沙箱，您将看到 View Body，View Properties 和 Core Animation Commits 的纯色墙，这是一个直接的红旗。 它告诉我们，SwiftUI 不仅要不断重新创建我们的视图，而且我们的属性也在不断变化，因此 Core Animation 必须加班加点才能跟上。\n效果预览: 4. 监控主题调用 如果我们选择 View Body 轨道 - 这是 instruments 列表中的第一行 - 我们应该能够看到 instruments 将结果分解为 SwiftUI 和 我们的项目，前者是原始类型，如文本视图和按钮，后者包含我们的自定义视图类型。 在我们的例子中，这意味着 \u0026ldquo;ContentView\u0026rdquo; 应该出现在自定义视图中，因为这是我们视图的名称。\n现在，在这里我们将看不到一个完美的代码到 SwiftUI 视图的一对一映射，因为 SwiftUI 会积极地折叠其视图层次结构，以尽可能少地进行工作。所以，不要期望在代码中看到任何 VStack 创建——这对于这个应用程序来说是免费的。\n在这个屏幕上，重要的数字是 计数(Count)和 平均持续时间(Avg Duration) - 每件事创建的次数，以及花费的时间。 因为这是一个压力测试我们应该看到非常高的数字，但我们的布局是微不足道的，所以平均持续时间可能是几十微秒。\n效果预览: 5. 跟踪状态变化 接下来，选择 View Properties 轨道，这是 instruments 列表中的第二行。 这将显示所有视图的所有属性，包括其当前值和所有先前值。\n我们的示例应用程序有一个按钮，通过在数字中给一个数字加1来更改其标签，并且在此工具中可见 - 请查看视图类型 ContentView 和 属性类型 @State\u0026lt;Int\u0026gt;。\n遗憾的是，Instruments 还没有（还能）向我们展示那里的确切属性名称，如果你跟踪了几个整数状态，这可能会更加令人困惑。然而，它确实有一个不同的技巧：在记录窗口的顶部是一个标记当前视图位置的箭头，如果你拖动它，你会看到应用程序状态随时间的变化 - 每次你点击按钮，你会看到状态整数上升一个，你可以前进和后退来看它发生。\n这可以解锁大量的功能，因为它可以让我们直接看到状态变化导致慢速重绘或其他工作 - 这几乎就像是在时间机器中，您可以在运行期间的每个点检查应用程序的确切状态。 6. 识别缓慢绘制 虽然 SwiftUI 能够直接下载到 Metal 以提高性能，但大多数情况下它更喜欢使用 Core Animation 进行渲染。 这意味着我们会自动从 Instruments 获取内置的 Core Animation分析工具，包括检测昂贵提交的能力。\n当多个更改一起放入一个组（称为事务）时，Core Animation 的效果最佳。 我们在一个事务中有效地堆叠了一系列工作，然后要求CA继续渲染工作 - 称为提交事务。\n因此，当 Instruments 向我们展示昂贵的 Core Animation 提交时，它真正向我们展示的是SwiftUI 因为更新而被迫重绘屏幕上的像素的次数。 理论上，这应该只在我们的应用程序的实际状态导致不同的视图层次结构时发生，因为 SwiftUI 应该能够将我们的 body 属性的新输出与先前的输出进行比较。 7. 查找缓慢的函数调用 最后一个重要的轨道是最后一个，Time Profiler，它向我们展示了在代码的每个部分花费了多少时间。 这与乐器中的常规时间分析器完全相同，但如果您之前没有尝试过，那么您至少需要知道：\n 右边的扩展细节窗口显示了默认情况下最重的堆栈跟踪，这是运行时间最长的一段代码。亮代码（白色或黑色，取决于您的MacOS颜色方案）是您编写的代码；暗代码（灰色）是系统库代码。 在左边，您可以看到所有创建的线程，以及让您深入到它们调用的函数和那些被调用的函数的公开指示器，等等。大部分工作将在“开始”中进行。 为了避免混乱，您可能需要单击底部的调用树按钮，然后选择隐藏系统库。这只会显示您编写的代码，但是如果您的问题是您使用的系统库不好，这可能没有帮助。 为了直接了解具体的细节，您还可以单击Call Tree并选择Invert Call Tree来翻转内容，这样叶子函数（位于树的末尾）就会显示在顶部，而披露指标现在可以让您向下钻取（向上钻取？）调用它们的函数。  虽然时间分析器对于识别性能问题非常有用，但通常仅查看最重的堆栈跟踪将突出显示最大的问题。\n8. 最后的提示 在您收取配置自己的代码之前，有一些事情需要注意：\n 在检查应用程序性能的一小部分时，您应该单击并拖动相关范围，以便仅查看该应用程序部分的统计信息。这使您可以专注于特定操作的性能，例如响应按下按钮。 即使你在仪器中看到纯色条，它们只是从远处看起来那样 - 你可以通过按住 Cmd 并按 - 和+来查看更多细节 要获得最准确的数字，请始终在真实设备上进行配置。 如果要通过分析代码进行更改，请始终一次进行一项更改。如果你进行两次更改，可能会使你的性能提高20％而另一种会降低10％，但是将它们合在一起意味着你可能会认为它们整体性能提高了10％。 Instruments 在发布模式下运行您的代码，从而实现 Swift 的所有优化。这也会影响您添加到代码中的任何调试标志，因此请小心。  ","date":1565230446,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565230446,"objectID":"d0614be5ba14a9797e7aa119ef1fed4b","permalink":"https://coderxdlee.github.io/post/swiftui/13-tooling/13.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8instruments%E6%9D%A5%E5%88%86%E6%9E%90swiftui%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%AF%86%E5%88%AB%E7%BC%93%E6%85%A2%E7%9A%84%E5%B8%83%E5%B1%80/","publishdate":"2019-08-08T10:14:06+08:00","relpermalink":"/post/swiftui/13-tooling/13.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8instruments%E6%9D%A5%E5%88%86%E6%9E%90swiftui%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%AF%86%E5%88%AB%E7%BC%93%E6%85%A2%E7%9A%84%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["Tooling"],"title":"13.5_如何使用Instruments来分析SwiftUI代码并识别缓慢的布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果我们设计了一个视图，我们知道它将作为导航堆栈的一部分显示，但本身不包含导航视图，那么默认情况下，我们将看不到它的导航栏标题或按钮。\n幸运的是，我们可以将视图添加到预览中的导航视图中——这模拟了在顶部有一个导航栏，而实际上没有为实时代码添加一个导航栏，因此我们可以准确地看到它的外观。\n例如，此视图没有导航视图，但配置为在作为一个视图的一部分呈现时以特定方式显示 - 即从另一个视图推送:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) .navigationBarTitle(Text(\u0026quot;Welcome\u0026quot;)) } }  要在导航视图中预览，只需在预览中的内容视图周围添加 NavigationView，如下所示:\n#if DEBUG struct ContentView_Previews: PreviewProvider { static var previews: some View { NavigationView { ContentView() } } } #endif  这使我们可以准确地查看视图的外观，而无需修改视图的实际布局。\n","date":1565229759,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565229759,"objectID":"6a78beae22280ba19530e5bd1a23818a","permalink":"https://coderxdlee.github.io/post/swiftui/13-tooling/13.4_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","publishdate":"2019-08-08T10:02:39+08:00","relpermalink":"/post/swiftui/13-tooling/13.4_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["Tooling"],"title":"13.4_如何在导航视图中预览布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 Xcode 的 SwiftUI 预览允许我们使用 .previewDevice() 修改器同时以多种屏幕尺寸显示我们的设计。 这需要提供设备的确切名称，如 Xcode 的目的地菜单中所示，例如， \u0026ldquo;iPhone XS Max\u0026rdquo;。\n2. 在 iPhone SE 上预览 例如，下面代码显示了 iPhone SE上的预览:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) .background(Color.red) } } #if DEBUG struct ContentView_Previews: PreviewProvider { static var previews: some View { Group { ContentView() .previewDevice(PreviewDevice(rawValue: \u0026quot;iPhone SE\u0026quot;)) } } } #endif  效果预览: 3. 显示设备名称 使用特定设备进行预览时，我们可能会发现添加 .previewDisplayName() 修改器非常有用，它允许我们在预览窗口中的设备下添加名称。\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) .background(Color.red) } } #if DEBUG struct ContentView_Previews: PreviewProvider { static var previews: some View { Group { ContentView() .previewDevice(PreviewDevice(rawValue: \u0026quot;iPhone SE\u0026quot;)) .previewDisplayName(\u0026quot;iPhone SE\u0026quot;) } } } #endif  效果预览: 4. 创建多个设备的预览 例如，下面代码会为两个不同的设备创建两个预览，添加每个设备的名称以明确发生了什么:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) .background(Color.red) } } #if DEBUG struct ContentView_Previews: PreviewProvider { static var previews: some View { Group { ContentView() .previewDevice(PreviewDevice(rawValue: \u0026quot;iPhone SE\u0026quot;)) .previewDisplayName(\u0026quot;iPhone SE\u0026quot;) ContentView() .previewDevice(PreviewDevice(rawValue: \u0026quot;iPhone XS Max\u0026quot;)) .previewDisplayName(\u0026quot;iPhone XS Max\u0026quot;) } } } #endif  ","date":1565228535,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565228535,"objectID":"7fdf6b377d498a01f0f9ead6e2cd2635","permalink":"https://coderxdlee.github.io/post/swiftui/13-tooling/13.3_%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","publishdate":"2019-08-08T09:42:15+08:00","relpermalink":"/post/swiftui/13-tooling/13.3_%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["Tooling"],"title":"13.3_如何在不同设备中预览布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"Apple的大多数操作系统都支持亮模式和暗模式用户界面，因此 SwiftUI 内置支持此功能也就不足为奇了。\n更好的是，一旦我们设计了界面，Xcode 允许我们通过在预览中设置 \\.colorScheme 环境值来以任一颜色方案预览布局。\n例如，下面显示使用暗模式的预览:\n#if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { Group { ContentView() .environment(\\.colorScheme, .dark) } } } #endif  如果我们要并排查看明暗模式，请在组中放置多个预览，如下所示:\n#if DEBUG struct ContentView_Previews: PreviewProvider { static var previews: some View { Group { ContentView() .environment(\\.colorScheme, .light) ContentView() .environment(\\.colorScheme, .dark) } } } #endif  效果预览:  提示: 如果我们的预览已缩放，则应滚动或缩小到其他预览。\n ","date":1565173514,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565173514,"objectID":"310eac54a8a4d3503bd0d3c985a9f71d","permalink":"https://coderxdlee.github.io/post/swiftui/13-tooling/13.2_%E5%A6%82%E4%BD%95%E5%9C%A8light%E5%92%8Cdark%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","publishdate":"2019-08-07T18:25:14+08:00","relpermalink":"/post/swiftui/13-tooling/13.2_%E5%A6%82%E4%BD%95%E5%9C%A8light%E5%92%8Cdark%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["Tooling"],"title":"13.2_如何在light和dark模式下预览布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"构建应用程序时，确保布局在所有动态类型范围内都能正常运行至关重要。 这部分是因为 SwiftUI 本身支持它，部分原因是许多人使用较小的字体大小，因为他们需要更高的信息密度，但主要是因为许多具有可访问性需求的人都依赖它。\n幸运的是，SwiftUI 的所有组件本身都适应动态类型大小，通过在预览中使用 \\.sizeCategory 环境值，可以轻松预览各种大小的设计。\n例如，如果我们想要查看视图如何使用额外的小文本，我们可以将 .environment（\\.size Category，.extra Small) 添加到内容视图预览中，如下所示:\n#if DEBUG struct ContentView_Previews: PreviewProvider { static var previews: some View { Group { ContentView() .environment(\\.sizeCategory, .extraSmall) } } } #endif  我们还可以发回一组预览，所有预览都使用不同的大小类别。 这使我们可以并排查看各种字体大小的相同设计。\n因此，此代码显示了超小尺寸，常规尺寸和最大尺寸的设计:\n#if DEBUG struct ContentView_Previews: PreviewProvider { static var previews: some View { Group { ContentView() .environment(\\.sizeCategory, .extraSmall) ContentView() ContentView() .environment(\\.sizeCategory, .accessibilityExtraExtraExtraLarge) } } } #endif  效果预览: 如果我们的设计在所有这三个方面都很有效，那么我们很高兴。\n 提示: 如果我们的预览已缩放，则应滚动或缩小到其他预览。\n ","date":1565172891,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565172891,"objectID":"5f9d1e89276175a415a68e321c83d068","permalink":"https://coderxdlee.github.io/post/swiftui/13-tooling/13.1_%E5%A6%82%E4%BD%95%E4%BB%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","publishdate":"2019-08-07T18:14:51+08:00","relpermalink":"/post/swiftui/13-tooling/13.1_%E5%A6%82%E4%BD%95%E4%BB%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["Tooling"],"title":"13.1_如何以不同的动态类型大小预览布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 如果您发现自己不断地将同一组修改器附加到一个视图上（例如，给它一个背景色、一些填充、一个特定的字体等等），那么您可以通过创建一个封装所有这些更改的自定义视图修改器来避免重复。所以，与其说“让它变红，使用大字体”等等，你可以说“让它看起来像一个警告”，然后应用一组预先制作的修改器。\n如果要创建自己的结构，请定义符合 ViewModifier 协议的结构。 此协议要求您接受 body（content:) 方法，该方法可以根据需要转换某种内容，并返回结果。\n2. 实践 例如，我们将创建一个新的 PrimaryLabel 修改器，用于添加填充，红色背景，白色文本和大字体:\nstruct PrimaryLabel: ViewModifier { func body(content: Content) -\u0026gt; some View { content .padding() .background(Color.red) .foregroundColor(.white) .font(.largeTitle) } }  要在我们的一个视图中使用它，请添加 .modifier（PrimaryLabel())修饰符，如下所示:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .modifier(PrimaryLabel()) } }  效果预览: ","date":1565169962,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565169962,"objectID":"6e8c31be3e9cd0800f05d3b652191518","permalink":"https://coderxdlee.github.io/post/swiftui/12-composing_views/12.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E5%99%A8/","publishdate":"2019-08-07T17:26:02+08:00","relpermalink":"/post/swiftui/12-composing_views/12.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E5%99%A8/","section":"post","summary":" ","tags":["Composing views"],"title":"12.4_如何创建自定义修改器","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果我们有多个嵌套在另一个视图中的视图，我们可能会发现为其中一些或全部视图创建属性非常有用，以使我们的布局代码更容易。 然后，我们可以在视图代码中内联引用这些属性，从而帮助保持代码的清晰。\n例如，下面代码会创建两个文本视图作为属性，然后将它们放在VStack中:\nstruct ContentView: View { let title = Text(\u0026quot;M X\u0026quot;) .font(.largeTitle) let subtitle = Text(\u0026quot;Admin\u0026quot;) .foregroundColor(.secondary) var body: some View { VStack { title subtitle } } }  效果预览: 如您所见，我们只需在堆栈中写入属性名称就足以放置它们。\n但是，更好的是我们可以将修改器附加到这些属性名称，如下所示:\nstruct ContentView: View { let title = Text(\u0026quot;M X\u0026quot;) .font(.largeTitle) let subtitle = Text(\u0026quot;Admin\u0026quot;) .foregroundColor(.secondary) var body: some View { VStack { title .foregroundColor(.red) subtitle } } }  效果预览: 这不会改变标题的基本风格，只会改变它的一个特定用法。\n","date":1565169278,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565169278,"objectID":"e172f865bfe2e26c8fda03332fa5d244","permalink":"https://coderxdlee.github.io/post/swiftui/12-composing_views/12.3_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E4%B8%BA%E5%B1%9E%E6%80%A7/","publishdate":"2019-08-07T17:14:38+08:00","relpermalink":"/post/swiftui/12-composing_views/12.3_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E4%B8%BA%E5%B1%9E%E6%80%A7/","section":"post","summary":" ","tags":["Composing views"],"title":"12.3_如何将视图存储为属性","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 的文本视图会重载 + 运算符，以便我们可以将它们组合在一起以创建新的文本视图。\n当我们需要在视图中使用不同的格式时，这很有用，因为我们可以使每个文本视图看起来完全符合我们的要求，然后将它们连接在一起以创建单个组合文本视图。 更好的是，VoiceOver 在阅读它们时会自动将它们识别为单个文本。\n2. 组合3个文本视图 - 不同字体 例如，下面代码会创建三个文本视图，然后使用 + 将它们连接到要返回的单个文本视图中:\nstruct ContentView: View { var body: some View { Text(\u0026quot;SwiftUI\u0026quot;) .font(.largeTitle) + Text(\u0026quot;is \u0026quot;) .font(.headline) + Text(\u0026quot;awesome\u0026quot;) .font(.footnote) } }  效果预览: 3. 组合3个文本视图 - 不同文本颜色 struct ContentView: View { var body: some View { Text(\u0026quot;SwiftUI \u0026quot;) .foregroundColor(.red) + Text(\u0026quot;is \u0026quot;) .foregroundColor(.orange) + Text(\u0026quot;awesome\u0026quot;) .foregroundColor(.blue) } }  效果预览:  提示: 像这样组合文本视图与我们在 SwiftUI 中组合字符串一样接近。\n ","date":1565167570,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565167570,"objectID":"fee83dfb8d3f6589f46127a767d6a706","permalink":"https://coderxdlee.github.io/post/swiftui/12-composing_views/12.2_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/","publishdate":"2019-08-07T16:46:10+08:00","relpermalink":"/post/swiftui/12-composing_views/12.2_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/","section":"post","summary":" ","tags":["Composing views"],"title":"12.2_如何将文本视图组合在一起","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 的核心原则之一是组合，这意味着它是为我们设计的，可以创建许多小视图，然后将它们组合在一起以创建更大的视图。 这使得我们能够大规模地重用视图，这意味着我们的工作量减少了。 更好的是，组合小的子视图几乎没有运行时开销，因此我们可以自由地使用它们。\n2. 实践 关键是要从小做起，逐步提升。\n第1步: 定义 User 模型 例如，许多应用程序必须与看起来像这样的用户一起工作:\nstruct User { var name: String var jobTitle: String var emailAddress: String var profilePicture: String }  第2步: 定义 ProfilePicture 视图 如果我们希望在应用程序中为用户配置文件图片提供一致的设计，可以创建一个具有圆形的100x100图像视图:\nstruct ProfilePicture: View { var imageName: String var body: some View { Image(imageName) .resizable() .frame(width: 100, height: 100) .clipShape(Circle()) } }  第3步: 定义 EmailAddress 视图 我们的设计师可能会告诉我们，只要看到电子邮件地址，我们就应该在其旁边显示一个小信封图标作为视觉提示，这样我们就可以创建一个 EmailAddress 视图:\nstruct EmailAdress: View { var address: String var body: some View { HStack { Image(systemName: \u0026quot;envelope\u0026quot;) Text(address) } }  第4步: 定义 UserDetail 视图 在显示用户的详细信息时，我们可以创建一个视图，该视图的名称和职务格式整齐，并使用我们的EmailAddress 视图通过其电子邮件地址进行备份，如下所示:\nstruct UserDetail: View { var user: User var body: some View { VStack(alignment: .leading) { Text(user.name) .font(.largeTitle) .foregroundColor(Color.red) Text(user.jobTitle) .foregroundColor(Color.gray) EmailAdress(address: user.emailAddress) } } }  第5步: 定义 UserView 视图 我们甚至可以创建一个更大的视图，将 ProfilePicture 放在 UserDetail 旁边，以便为用户提供单一的可视化表示，如下所示:\nstruct UserView: View { var user: User var body: some View { VStack { ProfilePicture(imageName: user.profilePicture) UserDetail(user: user) } } }  第6步: 组合 有了这种结构，我们现在有几种方式向用户展示：\n 只是他们的照片 只是他们的电邮地址 只是他们的工作细节 在同一时间展示所有信息  更重要的是，这意味着当涉及到使用所有这些工作时，我们的主要内容视图不必担心用户的外观或应如何对待它们 - 所有这些工作都融入到我们较小的视图中。\n这意味着我们可以使用示例用户创建一个 UserView 并使其正常工作:\nstruct ContentView: View { let user = User(name: \u0026quot;M X\u0026quot;, jobTitle: \u0026quot;Admin, M X WEBSITE\u0026quot;, emailAddress: \u0026quot;test@gmail.com\u0026quot;, profilePicture: \u0026quot;avatar\u0026quot;) var body: some View { UserView(user: user) } }  效果预览: ","date":1565163891,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565163891,"objectID":"732a4c1246018c4b065bd3fc29cbf8c4","permalink":"https://coderxdlee.github.io/post/swiftui/12-composing_views/12.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E6%92%B0%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-07T15:44:51+08:00","relpermalink":"/post/swiftui/12-composing_views/12.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E6%92%B0%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Composing views"],"title":"12.1_如何创建和撰写自定义视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 允许我们在添加视图时指定一个转换，在删除视图时指定另一个转换，所有转换都使用 asymmetric() 转换类型完成。\n例如，我们可以创建一个使用非对称过渡的文本视图，以便在添加时从前缘移入，并在移除时向下移动到底边，如下所示:\nText(\u0026quot;Details go here.\u0026quot;).transition(.asymmetric(insertion: .move(edge: .leading), removal: .move(edge: .bottom)))  ","date":1565162098,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565162098,"objectID":"93fa0106556b731da3b59256b68c88c4","permalink":"https://coderxdlee.github.io/post/swiftui/11-animation/11.7_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E8%BD%AC%E6%8D%A2/","publishdate":"2019-08-07T15:14:58+08:00","relpermalink":"/post/swiftui/11-animation/11.7_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E8%BD%AC%E6%8D%A2/","section":"post","summary":" ","tags":["Animation"],"title":"11.7_如何创建非对称转换","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"添加或删除视图时，SwiftUI 允许我们使用 combined(with:) 方法组合 转换 以创建新的动画样式。\n例如，我们可以同时将视图移动（一次转换）和淡入淡出（第二次转换），如下所示:\nText(\u0026quot;Details go here...\u0026quot;) .transition(AnyTransition.opacity.combined(with: .slide))  为了使组合转换更易于使用和重用，我们可以在 AnyTransition 上将它们创建为扩展，如下所示:\nextension AnyTransition { static var moveAndScale: AnyTransition { AnyTransition.move(edge: .bottom).combined(with: .scale) } }  有了这个，我们现在可以使用以下内容添加或删除文本视图:\nText(\u0026quot;Details go here...\u0026quot;) .transition(.moveAndScale)  ","date":1565142218,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565142218,"objectID":"21bff9a09eca612de50a0444312fb48d","permalink":"https://coderxdlee.github.io/post/swiftui/11-animation/11.6_%E5%A6%82%E4%BD%95%E7%BB%84%E5%90%88transactions/","publishdate":"2019-08-07T09:43:38+08:00","relpermalink":"/post/swiftui/11-animation/11.6_%E5%A6%82%E4%BD%95%E7%BB%84%E5%90%88transactions/","section":"post","summary":" ","tags":["Animation"],"title":"11.6_如何组合transactions","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 我们可以使用常规的 Swift 条件在设计中包含或排除某个视图。\n1. 默认动画 - fade 例如，当点击按钮时，这会添加或删除一些详细信息文本:\nstruct ContentView: View { @State private var showDetails = false var body: some View { VStack { Button(action: { withAnimation { self.showDetails.toggle() } }, label: { Text(\u0026quot;Tap to show details\u0026quot;) }) if showDetails { Text(\u0026quot;Details go here.\u0026quot;) } } } }  效果预览: 2. 使用 transition 控制视图从底部滑入 默认情况下，SwiftUI 使用 fade淡入淡出动画 来插入或删除视图，但如果需要，可以通过将transition() 修改器附加到视图来更改它。 例如，我们可以将详细信息文本视图从底部滑入或滑出，如下所示:\nstruct ContentView: View { @State private var showDetails = false var body: some View { VStack { Button(action: { withAnimation { self.showDetails.toggle() } }, label: { Text(\u0026quot;Tap to show details\u0026quot;) }) if showDetails { Text(\u0026quot;Details go here.\u0026quot;) .transition(.move(edge: .bottom)) } } } }  效果预览: 3. 使用 transaction(.slide) 还有 .slide 过渡，它导致视图从其前导中动画化并在其后缘上动画化:\nstruct ContentView: View { @State private var showDetails = false var body: some View { VStack { Button(action: { withAnimation { self.showDetails.toggle() } }, label: { Text(\u0026quot;Tap to show details\u0026quot;) }) if showDetails { Text(\u0026quot;Details go here.\u0026quot;) .transition(.slide) } } } }  效果预览: 4. 设置 transition(.scale) 以及 .scale 转换，它使视图在进入时从零缩放到全尺寸，然后在退出时返回到零：\nstruct ContentView: View { @State private var showDetails = false var body: some View { VStack { Button(action: { withAnimation { self.showDetails.toggle() } }, label: { Text(\u0026quot;Tap to show details\u0026quot;) }) if showDetails { Text(\u0026quot;Details go here.\u0026quot;) .transition(.scale) } } } }  效果预览: ","date":1565086289,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565086289,"objectID":"6b4706626f49eb01a24731b2a443267e","permalink":"https://coderxdlee.github.io/post/swiftui/11-animation/11.5_%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%A6%E6%9C%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-06T18:11:29+08:00","relpermalink":"/post/swiftui/11-animation/11.5_%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%A6%E6%9C%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Animation"],"title":"11.5_如何添加和删除带有转换的视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 如果将动画修改器附加到一个视图上，最终会得到 隐式动画 - 即使我们只是递增整数或切换布尔值，更改视图中其他位置的某些状态也可能会使用动画。\n另一种方法是使用显式动画，在这种情况下，您不会将修改器附加到相关视图，而是要求SwiftUI为您要进行的精确更改设置动画。 为此，请在对 withAnimation() 的调用中包装更改。\n2. 简单显式动画 例如，下面代码使用显式动画使每次点击时按钮逐渐消失:\nstruct ContentView: View { @State private var opacity: Double = 1 var body: some View { Button(action: { withAnimation { self.opacity -= 0.2 } }, label: { Text(\u0026quot;Tap here!\u0026quot;) .padding() .opacity(opacity) }) } }  效果预览: 3. 设置显式动画类型 withAnimation() 接收一个指定所需动画类型的参数，因此我们可以创建一个三秒钟的线性动画，如下所示:\nstruct ContentView: View { @State private var opacity: Double = 1 var body: some View { Button(action: { withAnimation(.linear(duration: 3), { self.opacity -= 0.2 }) }, label: { Text(\u0026quot;Tap here!\u0026quot;) .padding() .opacity(opacity) }) } }  效果预览: ![11.4_explicit_animation_linear_opacity](img/11.4_explicit_animation_linear_opacity.gif \u0026ldquo;Set a explicit linear animation for opacity\u0026rdquo;\n4. 总结 显式动画通常很有用，因为它们会使每个受影响的视图都出现动画，而不仅仅是那些附加了隐式动画的视图。 例如，如果视图A必须为视图B腾出空间作为动画的一部分，但只有视图B附加了动画，那么除非使用显式动画，否则视图A将跳转到其新位置而不进行动画处理。\n","date":1565084172,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565084172,"objectID":"c4b9a53a9061b49185392c4610692a54","permalink":"https://coderxdlee.github.io/post/swiftui/11-animation/11.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%98%BE%E5%BC%8F%E5%8A%A8%E7%94%BB/","publishdate":"2019-08-06T17:36:12+08:00","relpermalink":"/post/swiftui/11-animation/11.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%98%BE%E5%BC%8F%E5%8A%A8%E7%94%BB/","section":"post","summary":" ","tags":["Animation"],"title":"11.4_如何创建显式动画","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的双向绑定让我们可以调整程序的状态，我们可以通过调整视图层次结构来响应它。 例如，我们可能会使某些文本显示或消失，或调整视图的不透明度。\n我们可以通过向绑定添加 animation() 来对绑定进行修改而引起的更改进行动画处理，而不是立即进行状态更改。例如，此视图有一个切换按钮，根据切换的阶段显示或隐藏文本视图:\nstruct ContentView: View { @State private var showingWelcome = false var body: some View { VStack { Toggle(isOn: $showingWelcome, label: { Text(\u0026quot;Toggle label\u0026quot;) }) if showingWelcome { Text(\u0026quot;Hellow SwiftUI\u0026quot;) } } } }  效果预览: 如果没有动画，文本视图将立即显示或消失，从而导致视觉跳跃。 如果我们修改了 toggle ，那么它被绑定到 $showingWelcome.animation() ，那么文本视图将平滑滑入:\nstruct ContentView: View { @State private var showingWelcome = false var body: some View { VStack { Toggle(isOn: $showingWelcome.animation(), label: { Text(\u0026quot;Toggle label\u0026quot;) }) if showingWelcome { Text(\u0026quot;Hellow SwiftUI\u0026quot;) } } } }  效果预览: 如果希望对动画有更多的控制，可以将参数传递给影响转换方式的 animation()。例如，下面代码将使文本与弹簧动画一起出现:\n 效果预览: ","date":1565083007,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565083007,"objectID":"e0d365261366857cca96cb8e5574fd46","permalink":"https://coderxdlee.github.io/post/swiftui/11-animation/11.3_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%80%BC%E6%9B%B4%E6%94%B9%E7%9A%84%E5%8A%A8%E7%94%BB/","publishdate":"2019-08-06T17:16:47+08:00","relpermalink":"/post/swiftui/11-animation/11.3_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%80%BC%E6%9B%B4%E6%94%B9%E7%9A%84%E5%8A%A8%E7%94%BB/","section":"post","summary":" ","tags":["Animation"],"title":"11.3_如何设置绑定值更改的动画","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 内置了对弹性动画的支持，这些动画可以移动到目标点，越过一点，然后反弹。\n1. 简单演示 如果只单独使用 .spring()，而没有参数，则会得到一个合理的默认值。因此，下面代码将创建一个弹性动画，每次点击按钮时，它将旋转45度:\nstruct ContentView: View { @State private var angle: Double = 0 var body: some View { Button(action: { self.angle += 45 }, label: { Text(\u0026quot;Tap here!\u0026quot;) .padding() .rotationEffect(.degrees(angle)) .animation(.spring()) }) } }  效果预览: 2. 细粒度控制弹性动画 如果我们想要对弹性动画进行细粒度的控制，可以发送任何我们感兴趣的参数: 对象的质量、弹簧的刚度、弹性减慢的速度以及它在启动时开始移动的速度。\n例如，下面代码会创建一个弹性阻尼非常低的按钮，这意味着它会在达到目标角度之前长时间反弹:\nstruct ContentView: View { @State private var angle: Double = 0 var body: some View { Button(action: { self.angle += 45 }, label: { Text(\u0026quot;Tap here!\u0026quot;) .padding() .rotationEffect(.degrees(angle)) .animation(.interpolatingSpring(mass: 1, stiffness: 1, damping: 0.1, initialVelocity: 10)) }) } }  效果预览: ","date":1565081930,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565081930,"objectID":"a73d73ed9461cde990b97cd0a6c13c8c","permalink":"https://coderxdlee.github.io/post/swiftui/11-animation/11.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%BC%B9%E6%80%A7%E5%8A%A8%E7%94%BB/","publishdate":"2019-08-06T16:58:50+08:00","relpermalink":"/post/swiftui/11-animation/11.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%BC%B9%E6%80%A7%E5%8A%A8%E7%94%BB/","section":"post","summary":" ","tags":["Animation"],"title":"11.2_如何创建弹性动画","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI 通过其 animation() 修改器内置了对动画的支持。 要使用此修改器，请将其放在视图的任何其它修改器之后，并告诉它我们想要什么样的动画。\n2. 缩放动画 例如，下面代码创建一个按钮，每次按下它时，其缩放效果会增加1:\nstruct ContentView: View { @State private var scale: CGFloat = 1 var body: some View { Button(action: { self.scale += 1 }, label: { Text(\u0026quot;Tap here!\u0026quot;) .scaleEffect(scale) .animation(.default) }) } }  效果预览: 2. 设置动画持续时间 如果需要，我们可以为动画指定精确的持续时间。 例如，下面代码会在三秒钟内激活缩放效果:\nstruct ContentView: View { @State private var scale: CGFloat = 1 var body: some View { Button(action: { self.scale += 1 }, label: { Text(\u0026quot;Tap here!\u0026quot;) .scaleEffect(scale) .animation(.linear(duration: 3)) }) } }  效果预览: 3. 曲线动画 我们也可以指定曲线动画，在 .easeIn, .easeOut, .easeInOut, and .custom 之间进行选择，后者允许我们指定自己的控制点。\n例如，下面代码会激活缩放效果，使其开始慢并逐渐变快:\nstruct ContentView: View { @State private var scale: CGFloat = 1 var body: some View { Button(action: { self.scale += 1 }, label: { Text(\u0026quot;Tap here!\u0026quot;) .scaleEffect(scale) .animation(.easeIn) }) } }  效果预览: 4. 设置多个动画变量 我们可以为许多其他修改器设置动画，例如2D和3D旋转，不透明度，边框等。 例如，下面代码会使按钮旋转并在每次点击时增加其边框:\nstruct ContentView: View { @State private var angle: Double = 0 @State private var borderThickness: CGFloat = 1 var body: some View { Button(action: { self.angle += 45 self.borderThickness += 1 }, label: { Text(\u0026quot;Tap here\u0026quot;) .padding() .border(Color.red, width: borderThickness) .rotationEffect(.degrees(angle)) .animation(.default) }) } }  效果预览: ","date":1565079415,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565079415,"objectID":"4736340b5ca209a47faa8ae21f1d5b0b","permalink":"https://coderxdlee.github.io/post/swiftui/11-animation/11.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E5%8A%A8%E7%94%BB/","publishdate":"2019-08-06T16:16:55+08:00","relpermalink":"/post/swiftui/11-animation/11.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E5%8A%A8%E7%94%BB/","section":"post","summary":" ","tags":["Animation"],"title":"11.1_如何创建基本动画","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 允许我们通过使用各种修改器来调整视图的亮度、色调、色调、饱和度等等来精细地控制视图的外观。\n1. 给图像视图着色 例如，下面代码会创建一个图像视图并将整个事物着色为红色:\nstruct ContentView: View { var body: some View { Image(\u0026quot;avatar\u0026quot;) .resizable() .frame(width: 300, height: 300) .colorMultiply(.red) } }  效果预览: 2. 调整视图饱和度 我们可以将视图的饱和度调整为任意数量，其中0.0为完全灰色，1.0为其原始颜色:\nstruct ContentView: View { var body: some View { Image(\u0026quot;avatar\u0026quot;) .resizable() .frame(width: 300, height: 300) .saturation(0.5) } }  效果预览: 3. 动态调整视图对比度 甚至可以使用 contrast() 修改器动态调整视图的对比度。如果值为0.0，则不会产生对比度（浅灰色图像），1.0将提供原始图像，高于1.0的所有内容都会添加对比度。\nstruct ContentView: View { var body: some View { Image(\u0026quot;avatar\u0026quot;) .resizable() .frame(width: 300, height: 300) .contrast(0.5) } }  效果预览: ","date":1565078386,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565078386,"objectID":"72613ba99975abb25ce0879cbecd9a16","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.17_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%9D%80%E8%89%B2%E5%92%8C%E5%8E%BB%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%AD%89%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-06T15:59:46+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.17_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%9D%80%E8%89%B2%E5%92%8C%E5%8E%BB%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%AD%89%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.17_如何通过着色和去饱和度等调整视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"将一个视图放在另一个视图上时，可以使用 blendMode() 修改器控制它们重叠的方式。 这包含多种可以将颜色混合在一起的方法，例如使用它们的差异或使用颜色刻录 - 如果您之前使用过 Core Graphics 或类似 Photoshop，这些方法会很熟悉。\n为了证明这一点，我们可以创建一个内部有两个图像的 ZStack ，其中第二个具有 .multiply 混合模式，以便使其后面的颜色变暗:\nstruct ContentView: View { var body: some View { ZStack { Image(\u0026quot;stripes\u0026quot;) Image(\u0026quot;example-image\u0026quot;) .blendMode(.multiply) } } }  效果预览: ","date":1565077759,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565077759,"objectID":"84a61ec2fde43550d4caaf368c0b0ebb","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.16_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%B7%B7%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/","publishdate":"2019-08-06T15:49:19+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.16_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%B7%B7%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.16_如何将视图混合在一起","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 blur() 修改器允许我们根据自己的选择对视图应用实时高斯模糊。\n2. 给图像设置模糊 例如: 下面代码会创建一个 300x300 的个人资料图片，然后添加一个20点的高斯模糊:\nstruct ContentView: View { var body: some View { Image(\u0026quot;avatar\u0026quot;) .resizable() .frame(width: 300, height: 300) .blur(radius: 20) } }  效果预览: 3. 给文本设置模糊 我们可以模糊我们想要的任何内容，包括文本视图:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Welcome to my SwiftUI app\u0026quot;) .blur(radius: 2) } }  效果预览: ","date":1565077069,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565077069,"objectID":"54a287c0198b0705498157123ccaffc8","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.15_%E5%A6%82%E4%BD%95%E6%A8%A1%E7%B3%8A%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-06T15:37:49+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.15_%E5%A6%82%E4%BD%95%E6%A8%A1%E7%B3%8A%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.15_如何模糊视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 为我们提供了 mask() 修改器，用于将一个图像作为另一个视图的蒙版，这意味着我们可以使用文本来作为图像的蒙版，或使用图像作为图像的蒙版，或更多。\n例如，下面代码会创建一个 300x300 的条纹图像，然后使用文本 \u0026ldquo;SWIFT!\u0026rdquo; 对其进行遮罩，以便字母充当图像的剪切区域:\nstruct ContentView: View { var body: some View { Image(\u0026quot;stripes\u0026quot;) .resizable() .frame(width: 300, height: 300) .mask( Text(\u0026quot;SWIFT!\u0026quot;) .font(Font.system(size: 72, weight: .black, design: .serif)) ) } }  效果预览: ","date":1565075816,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565075816,"objectID":"bbc693a45315ed9dd13e226b91c19e85","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.14_%E5%A6%82%E4%BD%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E9%81%AE%E7%BD%A9%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-06T15:16:56+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.14_%E5%A6%82%E4%BD%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E9%81%AE%E7%BD%A9%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.14_如何用另一个视图遮罩一个视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"iOS 使用 tints colors 为应用程序提供协调的主题，SwiftUI 中的 accent colors 也提供了相同的功能。就像在 UIKit 中一样，当您设置一个视图的 accent color 时，它会影响其中的所有内容，因此如果您设置顶级控件的 accent color，那么一切都会变色。\n例如，下面代码会在 VStack 中创建一个按钮，然后给它一个橙色的强调颜色:\nstruct ContentView: View { var body: some View { VStack { Button(action: {}, label: { Text(\u0026quot;Tap here\u0026quot;) }) } .accentColor(Color.orange) } }  效果预览: ","date":1565073343,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565073343,"objectID":"9b9a9f895520dbb849e1ca75841d81c7","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.13_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%B0%83%E8%89%B2/","publishdate":"2019-08-06T14:35:43+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.13_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%B0%83%E8%89%B2/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.13_如何调整视图的强调色","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"通过 opacity() 修改器，我们可以将任何 SwiftUI 视图设置成部分或全部透明。它接收 0(完全不可见) 到 1(完全不透明) 之间的值。就像 UIKit 中 UIView 的 alpha 属性一样。\n例如: 下面代码创建一个带有红色背景的文本视图，然后给它30％的不透明度:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Now you see me\u0026quot;) .padding() .background(Color.red) .opacity(0.3) } }  效果预览: ","date":1565072362,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565072362,"objectID":"c349a70e8385d73e83e004278e87d723","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.12_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6/","publishdate":"2019-08-06T14:19:22+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.12_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.12_如何调整视图的不透明度","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"通过 cornerRadius() 修改器，我们可以给任何 SwiftUI 视图设置圆角。这需要一个简单地值来限定如何明确地成圆。\n因此，我们可以创建一个25点圆角的文本视图，如下所示:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Round me\u0026quot;) .padding() .background(Color.red) .cornerRadius(20) } }  效果预览: ","date":1565071611,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565071611,"objectID":"79a478d26f4b0f140c9b17294433d1f9","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/","publishdate":"2019-08-06T14:06:51+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.11_如何给视图设置圆角","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI的 scaleEffect() 修改器允许我们自由地增大或减小视图的大小。\n2. 放大视图 例如，我们可以将文本视图设置为常规大小的五倍，如下所示:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Up we go\u0026quot;) .scaleEffect(5) } }  3. 独立缩放XY 如果需要，可以独立缩放X和Y尺寸，从而可以挤压以下视图:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Up we go\u0026quot;) .scaleEffect(x: 1, y: 5) } }  4. 设置锚点 如果您想要更多控制，可以为此缩放指定锚点，如下所示:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Up we go\u0026quot;) .scaleEffect(2, anchor: UnitPoint(x: 1, y: 1)) } }  这使得文本视图两倍于常规大小，从右下角缩放。\n","date":1565068403,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565068403,"objectID":"5c439dff80f643fbd1078bce8b34aa96","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.10_%E5%A6%82%E4%BD%95%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%E7%BC%A9%E6%94%BE%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-06T13:13:23+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.10_%E5%A6%82%E4%BD%95%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%E7%BC%A9%E6%94%BE%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.10_如何向上或向下缩放视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI 的 rotation3DEffect() 修改器让我们可以在三维空间中旋转视图，几乎不需要任何代码就可以创建漂亮的效果。\n这个修改器接受两个参数:\n 旋转的角度（以度或弧度为单位）。 加上包含X，Y和Z轴的元组，围绕该轴执行旋转。  重要提示: 如果你以前从未进行过三维旋转，那么你应该将X/Y/Z轴视为视图中的扦子。X轴是水平的，所以如果你在X轴上旋转，就像是在你的视图中放置一个水平的扦子 — 任何旋转都会使顶部或底部更近或更远，但不会调整前缘和后缘。\n2. 围绕X轴旋转视图 因此，如果要围绕X轴将某些文本旋转45度（这将导致文本顶部比底部看得更远），可以编写以下命令:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .foregroundColor(.yellow) .rotation3DEffect(.degrees(-45), axis: (x: 1, y: 0, z: 0)) } }  效果预览: ","date":1565066302,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565066302,"objectID":"f12f9b4ae77c92dc351d2da9c874dd1e","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.9_%E5%A6%82%E4%BD%95%E5%9C%A83d%E4%B8%AD%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-06T12:38:22+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.9_%E5%A6%82%E4%BD%95%E5%9C%A83d%E4%B8%AD%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.9_如何在3D中旋转视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI的 rotationEffect() 修改器让我们可以使用度数或弧度自由旋转视图。\n2. 使用角度旋转视图 例如，如果我们想将某些文本旋转-90度以使其向上读取，我们可以使用：\nstruct ContentView: View { var body: some View { Text(\u0026quot;Up we go\u0026quot;) .rotationEffect(.degrees(-90)) } }  效果预览: 3. 使用弧度旋转视图 如果我们更喜欢使用弧度，只需传入 .radians() 作为参数，如下所示：\nstruct ContentView: View { var body: some View { Text(\u0026quot;Up we go\u0026quot;) .rotationEffect(.radians(.pi)) } }  效果预览: 4. 使用滑块交互 视图旋转速度如此之快，以至于实际上是自由的，所以如果需要，甚至可以使用滑块进行交互:\nstruct ContentView: View { @State private var rotation: Double = 0 var body: some View { VStack { Slider(value: $rotation, in: 0...360, step: 1) { _ in print(self.rotation) } Text(\u0026quot;Up we go\u0026quot;) .rotationEffect(.degrees(rotation)) } } }  效果预览: 5. 设置旋转锚点 默认情况下，视图围绕其中心旋转，但如果要从特定点固定旋转，则可以为其添加额外参数。 例如，如果你想让旋转器围绕视图的左上角旋转旋转，你可以这样写：\n默认情况下，视图围绕其中心旋转，但如果要从特定点固定旋转，可以为此添加一个额外参数。例如，如果要使上方的滑块围绕视图左上角旋转，可以编写以下命令:\nstruct ContentView: View { @State private var rotation: Double = 0 var body: some View { VStack { Slider(value: $rotation, in: 0...360, step: 1) { _ in print(self.rotation) } Text(\u0026quot;Up we go\u0026quot;) .rotationEffect(.degrees(rotation), anchor: UnitPoint(x: 0, y: 0)) } } }  效果预览: ","date":1565061382,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565061382,"objectID":"e13a6aeec947cbffd940350befcfcf79","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.8_%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-06T11:16:22+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.8_%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.8_如何旋转视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 通过使用 clipShape() 修改器，SwiftUI允许我们剪切任何视图以控制其形状。\n2. 创建圆形按钮 例如: 下面的代码使用系统图像 bolt.fill 创建一个按钮，给它一些填充和背景颜色，然后使用圆形剪裁它，以便我们得到一个圆形按钮:\nstruct ContentView: View { var body: some View { Button(action: { print(\u0026quot;Button tapped!\u0026quot;) }, label: { Image(systemName: \u0026quot;bolt.fill\u0026quot;) .foregroundColor(.white) .padding() .background(Color.green) .clipShape(Circle()) }) } }  效果预览: Circle 剪辑形状将始终从视图中创建圆圈，即使它们的宽度和高度不相等 - 它只会裁剪较大的值以匹配较小的值。\n3. 除了 Circle 之外，还有 Capsule，它可以看到圆形的菱形形状。 例如，下面的代码使用 Capsule 形状创建相同的按钮:\nstruct ContentView: View { var body: some View { Button(action: { print(\u0026quot;Button tapped!\u0026quot;) }, label: { Image(systemName: \u0026quot;bolt.fill\u0026quot;) .foregroundColor(.white) .padding(EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20)) .background(Color.green) .clipShape(Capsule()) }) } }  效果预览: ","date":1565060470,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565060470,"objectID":"f82443f914103b27db49a395a8b009eb","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.7_%E5%A6%82%E4%BD%95%E5%89%AA%E8%A3%81%E8%A7%86%E5%9B%BE%E4%BD%BF%E5%85%B6%E5%8F%AA%E6%9C%89%E9%83%A8%E5%88%86%E5%8F%AF%E8%A7%81/","publishdate":"2019-08-06T11:01:10+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.7_%E5%A6%82%E4%BD%95%E5%89%AA%E8%A3%81%E8%A7%86%E5%9B%BE%E4%BD%BF%E5%85%B6%E5%8F%AA%E6%9C%89%E9%83%A8%E5%88%86%E5%8F%AF%E8%A7%81/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.7_如何剪裁视图使其只有部分可见","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 为我们提供了一个专用的 shadow() 修改器，用于在视图周围绘制阴影。 我们可以控制阴影的颜色、半径和位置，还可以通过调整修改器顺序来控制视图的哪些部分被阴影遮盖。\n2. 通过模糊半径绘制阴影 在其基本形式中，我们只需指定模糊的半径即可添加阴影，如下所示:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .padding() .shadow(radius: 5) .border(Color.red, width: 4) } }  效果预览: 这段代码添加了一个非常轻微的阴影，以文本为中心的5点模糊。\n3. 绘制红色阴影 我们还可以指定所需的颜色以及原始视图的X和Y偏移。 例如，下面的代码会创建一个强烈的红色阴影，其中包含5点模糊，以文本为中心：\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .padding() .shadow(color: Color.red, radius: 5) .border(Color.red, width: 4) } }  效果预览: 4. 为阴影设置偏移量 如果要为阴影指定偏移，请将 x 和/或 y 参数添加到修改器，如下所示:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .padding() .shadow(color: Color.red, radius: 5, x: 20, y: 20) .border(Color.red, width: 4) } }  效果预览: 5. 为边框绘制阴影 请记住，SwiftUI 按照列出修改器的顺序来应用它们，因此如果我们希望可以将阴影应用于边框，只需将边框修改器放在阴影修改器之前:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .padding() .border(Color.red, width: 4) .shadow(color: Color.red, radius: 5, x: 20, y: 20) } }  ","date":1565059046,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565059046,"objectID":"2d14832a5dc7fe6985b55749dc861342","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.6_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1/","publishdate":"2019-08-06T10:37:26+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.6_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.6_如何在视图周围绘制阴影","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 为我们提供了一个专用的 border 修改器，用于在视图周围绘制边框。根据我们是要指定笔划宽度(a stroke width)还是圆角半径(a corner radius)，它有一些变化，因此下面是几个示例:\n2. 绘制1个点的边框 下面的代码在文本视图周围绘制1个点的黑色边框:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .border(Color.black) } }  效果预览: 3. 先添加填充再绘制边框 如果要使边框不位于视图边缘，请先添加一些填充：\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .padding() .border(Color.black) } }  效果预览: 4. 添加4个点的红色边框 struct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .padding() .border(Color.red, width: 4) } }  效果预览: ","date":1565057874,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565057874,"objectID":"ac4504b28e7b4d6f9e10ad78e2e5f01c","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.5_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E8%BE%B9%E6%A1%86/","publishdate":"2019-08-06T10:17:54+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.5_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E8%BE%B9%E6%A1%86/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.5_如何在视图周围绘制边框","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"我们添加到视图中的每个修改器都会调整其前面的内容，并且可以多次重复使用修改器。\n例如，我们可以在文本视图周围添加填充和背景色，然后添加更多的填充和不同的背景色，然后添加更多的填充和第三种背景色，所有这些都可以产生特定的效果:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Forecast: Sun\u0026quot;) .font(.largeTitle) .foregroundColor(Color.white) .padding() .background(Color.red) .padding() .background(Color.orange) .padding() .background(Color.yellow) } }  效果预览: ","date":1565057271,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565057271,"objectID":"6b9f66a97f60307f558aba63013422f5","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.4_%E5%A6%82%E4%BD%95%E5%A0%86%E5%8F%A0%E4%BF%AE%E6%94%B9%E5%99%A8%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%95%88%E6%9E%9C/","publishdate":"2019-08-06T10:07:51+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.4_%E5%A6%82%E4%BD%95%E5%A0%86%E5%8F%A0%E4%BF%AE%E6%94%B9%E5%99%A8%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%95%88%E6%9E%9C/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.4_如何堆叠修改器以创建更高级的效果","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 padding() 修饰符允许我们在视图周围添加一些空间，background() 修饰符允许我们设置背景颜色。 但是，我们使用它们的方式很重要，因此明确我们的目标以获得最佳结果非常重要。\n2. 先着色后填充 例如，下面的代码将创建一个具有黑色背景和白色前景的文本视图，然后向其添加系统默认填充:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.black) .foregroundColor(Color.white) .padding() } }  效果预览: 3. 先填充后着色 例如，下面的代码将为文本视图添加系统默认填充，然后再为其设置红色背景和白色前景:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .padding() .background(Color.red) .foregroundColor(Color.white) } }  效果预览: 4. 总结 这两段代码可能看起来很相似，但是它们会产生不同的结果，因为应用修饰符的顺序很重要。在第二个示例中，视图先被填充，然后被着色，这意味着填充也被着色为红色。与此相反，第一个示例是先着色，然后填充，因此填充保持未着色。\n因此，如果我们希望某些文本的背景色比文本本身更宽，请确保使用第二个代码示例 – 先填充后着色。\n","date":1565055979,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565055979,"objectID":"ff94db0852be0f4a8f34a531d3878104","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.3_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E5%A1%AB%E5%85%85%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/","publishdate":"2019-08-06T09:46:19+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.3_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E5%A1%AB%E5%85%85%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.3_如何为视图周围的填充设置颜色","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"所有视图在层次结构中都有一个自然位置，但是我们可以通过 offset() 修改器相对于其自然位置来移动它们。\n重要说明: 使用 offset() 将导致视图相对于其自然位置进行移动，但是不会影响其它视图的位置。这意味着我们可以使一个视图与另一个视图重叠，因为通常情况下它们可能彼此相邻，而这可能不是我们想要的。\n例如，在这个 VStack 中，我们可以使用 offset() 将第二个项目向下移动15个点，以便它开始与第三个项目重叠:\nstruct ContentView: View { var body: some View { VStack { Text(\u0026quot;Home\u0026quot;) Text(\u0026quot;Options\u0026quot;) .offset(y: 15) Text(\u0026quot;Help\u0026quot;) } } }  效果预览: 通常，我们可以使用 padding() 和 offset() 来得到我们期望的结果，因为这样可以移动一个视图，同时挑着做那个它旁边的视图以使其匹配。\n例如: 我们将第二个项目向下移动15个点，但在其底边添加15个填充点，使其不会与下面的文本视图重叠:\nstruct ContentView: View { var body: some View { VStack { Text(\u0026quot;Home\u0026quot;) Text(\u0026quot;Options\u0026quot;) .offset(y: 15) .padding(.bottom, 15) Text(\u0026quot;Help\u0026quot;) } } }  效果预览: ","date":1565054247,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565054247,"objectID":"224dd3add8c6fcc91a980bde6d4b1b30","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.2_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE/","publishdate":"2019-08-06T09:17:27+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.2_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.2_如何调整视图的位置","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"默认情况下，视图只占用自己所需的空间，但是如果我们想要更改它，可以使用 frame() 修饰符告诉 SwiftUI 我们想要的尺寸范围(size range)。\n例如，可以创建一个具有 200x200 可点击区域的按钮，如下所示:\nstruct ContentView: View { var body: some View { Button(action: { print(\u0026quot;Button tapped\u0026quot;) }, label: { Text(\u0026quot;Welcome\u0026quot;) .frame(minWidth: 0, maxWidth: 200, minHeight: 0, maxHeight: 200, alignment: .center) .font(.largeTitle) }) } }  效果预览: 或者，我们可以通过指定一个 frame 来使文本视图填充整个屏幕，这个 frame 的最小宽度和最小高度为0，最大宽度和最大高度是无穷大。如下所示:\nstruct ContentView: View { var body: some View { Text(\u0026quot;Please login\u0026quot;) .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center) .font(.largeTitle) .foregroundColor(Color.white) .background(Color.red) } }  效果预览: ","date":1565021971,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565021971,"objectID":"ba91d3ae5187ba7c4789b3c480598418","permalink":"https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.1_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89frame/","publishdate":"2019-08-06T00:19:31+08:00","relpermalink":"/post/swiftui/10-transforming_views/10.1_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89frame/","section":"post","summary":" ","tags":["Transforming views"],"title":"10.1_如何为视图提供自定义frame","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 PresentationLink 用于以现有视图控制器的基础上以模态方式呈现新视图控制器，例如在 UIViewController 上调用 present()。 要使用一个，给它一些要显示的内容（一些文本、一个图像等）加上一个目的地，然后让 SwiftUI 处理其余的内容。\n 提示: 在beta 1和beta 2中，它被命名为 PresentationButton。\n 例如，如果我们有这样的详细视图:\nstruct DetailView: View { var body: some View { Text(\u0026quot;Detail\u0026quot;) } }  然后你我们可以这样呈现:\n ","date":1564999913,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564999913,"objectID":"5300edd4e6200ffae9520828bc2e42a1","permalink":"https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8presentationlink%E5%91%88%E7%8E%B0%E6%96%B0%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-05T18:11:53+08:00","relpermalink":"/post/swiftui/9-presenting_views/9.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8presentationlink%E5%91%88%E7%8E%B0%E6%96%B0%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Presenting views"],"title":"9.3_如何使用PresentationLink呈现新视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 中没有 UITableView 的 didSelectRowAt 方法的直接等价物，但它不需要这样的方法，因为我们可以将 NavigationLink 与列表行结合起来并免费获取这种 behavior。\n我们需要将列表与我们可以使用的一些内容放在一起。 首先，我们需要某种数据来显示:\nstruct Restaurant: Identifiable { var id = UUID() var name: String }  我们需要一个列表行视图，一次显示一个餐厅:\nstruct RestaurantRow: View { var restaurant: Restaurant var body: some View { Text(restaurant.name) } }  最后，我们需要一个视图，其中包含可用餐厅的列表:\nstruct ContentView: View { var body: some View { let first = Restaurant(name: \u0026quot;Joe's Original\u0026quot;) let restaurants = [first] return NavigationView { List(restaurants, rowContent: { restaurant in RestaurantRow(restaurant: restaurant) }).navigationBarTitle(Text(\u0026quot;Select a restaurant\u0026quot;)) } } }  效果预览: 这段代码在列表中显示一家餐馆，但是不可选。\n为了使点击一行显示详细视图，我们首先需要一个可以显示餐厅的详细视图。 例如，像这样:\nstruct RestaurantRow: View { var restaurant: Restaurant var body: some View { Text(\u0026quot;Come and eat at \\(restaurant.name)\u0026quot;) .font(.largeTitle) } }  有了它，我们现在可以在 NavigationLink 中包装 RestaurantRow 行，如下所示:\nstruct ContentView: View { var body: some View { let first = Restaurant(name: \u0026quot;Joe's Original\u0026quot;) let restaurants = [first] return NavigationView { List(restaurants, rowContent: { restaurant in NavigationLink(destination: RestaurantRow(restaurant: restaurant)) { RestaurantRow(restaurant: restaurant) } }).navigationBarTitle(Text(\u0026quot;Select a restaurant\u0026quot;)) } } }  效果预览: 如您所见，使用 RestaurantRow(restaurant: restaurant) 作为行点击事件的目的地，因此将创建 RestaurantView 并传递附加到列表行的餐厅。\n请注意，我们是如何在导航按钮中添加列表行的 — SwiftUI 凭借其出色的构图能力使其工作正常。\n","date":1564998040,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564998040,"objectID":"af6b1e9a58c8eb72afefb02742dc90f0","permalink":"https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.2_%E7%82%B9%E5%87%BB%E5%88%97%E8%A1%A8%E8%A1%8C%E6%97%B6%E5%A6%82%E4%BD%95push%E6%96%B0%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-05T17:40:40+08:00","relpermalink":"/post/swiftui/9-presenting_views/9.2_%E7%82%B9%E5%87%BB%E5%88%97%E8%A1%A8%E8%A1%8C%E6%97%B6%E5%A6%82%E4%BD%95push%E6%96%B0%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Presenting views"],"title":"9.2_点击列表行时如何push新视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果我们有一个导航视图，并且希望将一个新视图 push 到 SwiftUI 的导航堆栈上，那么我们应该使用 NavigationLink，在 beta 1和2 中使用的是 NavigationButton。这将一个目标作为它的第一个参数，以及在按钮内部显示什么作为它的第二个参数（或者作为一个尾随闭包），并负责将新视图和动画一起 push 到堆栈上。\n例如: 如果我们有这样一个 详细视图:\nstruct DetailView: View { var body: some View { Text(\u0026quot;Detail\u0026quot;) } }  然后我们可以这样呈现它:\nstruct ContentView: View { var body: some View { NavigationView { NavigationLink(destination: DetailView(), label: { Text(\u0026quot;Click!\u0026quot;) .background(Color.red) }) .navigationBarTitle(Text(\u0026quot;Navigation\u0026quot;)) } } }  效果预览: ","date":1564995515,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564995515,"objectID":"3f03ca7c92d07779da7625c976c4b028","permalink":"https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.1_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%B0%E8%A7%86%E5%9B%BEpush%E5%88%B0navigationview/","publishdate":"2019-08-05T16:58:35+08:00","relpermalink":"/post/swiftui/9-presenting_views/9.1_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%B0%E8%A7%86%E5%9B%BEpush%E5%88%B0navigationview/","section":"post","summary":" ","tags":["Presenting views"],"title":"9.1_如何将新视图push到NavigationView","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 为我们提供了 ActionSheet 视图，用于创建供用户选择的操作表。但是，我们确实需要确保在它被解除时重置我们的状态，否则，我们将无法再次显示它。\n稍后，我们再展示所有代码，现在我们首先将其分解，因为这并不容易。\n首先，我们需要定义一个属性来跟踪是否需要显示操作表:\n@State private var showingSheet = false  接下来，我们应该创建一个属性来存储操作表。这需要标题和消息文本，但也应该提供一个按钮数组。如下所示:\nvar sheet = ActionSheet(title: Text(\u0026quot;Action\u0026quot;), message: Text(\u0026quot;Quote mark\u0026quot;), buttons: [.default(Text(\u0026quot;Show sheet\u0026quot;))])  完成后，我们可以使用显示工作表的演示文稿将操作表附加到视图中，或者根据showsSheet的值执行任何操作，如下所示:\nstruct ContentView: View { @State private var showingSheet = false var sheet = ActionSheet(title: Text(\u0026quot;Action\u0026quot;), message: Text(\u0026quot;Quote mark\u0026quot;), buttons: [.default(Text(\u0026quot;Show sheet\u0026quot;))]) var body: some View { Button(action: { self.showingSheet = true }, label: { Text(\u0026quot;Woo\u0026quot;) }) .actionSheet(isPresented: $showingSheet, content: { self.sheet }) } }  效果预览: ","date":1564992882,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564992882,"objectID":"2dc205110ed0fec202be6749a61a3b40","permalink":"https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.4_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAaction_sheet/","publishdate":"2019-08-05T16:14:42+08:00","relpermalink":"/post/swiftui/8-alerts_and_action_sheets/8.4_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAaction_sheet/","section":"post","summary":" ","tags":["Alerts and action sheets"],"title":"8.4_如何显示一个action_sheet","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"基本的 SwiftUI alert 如下所示:\nAlert(title: Text(\u0026quot;Important message\u0026quot;), message: Text(\u0026quot;Wear sunscreen\u0026quot;), dismissButton: .default(Text(\u0026quot;Got it!\u0026quot;)))  但是，我们经常需要将操作附加到按钮上，以便在点击按钮时执行特定操作。要做到这一点，请在按钮上附加一个闭包，当按钮被点击时闭包将被调用，如下所示:\nstruct ContentView: View { @State private var showAlert = false var body: some View { Button(action: { self.showAlert = true }, label: { Text(\u0026quot;Show alert\u0026quot;) }) .alert(isPresented: $showAlert, content: { Alert(title: Text(\u0026quot;Are you sure you want to delete this?\u0026quot;), message: Text(\u0026quot;There is no undo.\u0026quot;), primaryButton: .destructive(Text(\u0026quot;Delete\u0026quot;), action: { print(\u0026quot;Deleting...\u0026quot;) }), secondaryButton: .cancel()) }) } }  效果预览:  提示: 在预览视图中，点击 Delete 按钮，控制台没有日志输出。\n ","date":1564991668,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564991668,"objectID":"1550884610d605e937d6d8f7e5824e44","permalink":"https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.3_%E5%A6%82%E4%BD%95%E5%90%91alert_buttons%E6%B7%BB%E5%8A%A0actions/","publishdate":"2019-08-05T15:54:28+08:00","relpermalink":"/post/swiftui/8-alerts_and_action_sheets/8.3_%E5%A6%82%E4%BD%95%E5%90%91alert_buttons%E6%B7%BB%E5%8A%A0actions/","section":"post","summary":" ","tags":["Alerts and action sheets"],"title":"8.3_如何向alert_buttons添加actions","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"创建一个基本的 SwiftUI alert 的代码如下:\nAlert(title: Text(\u0026quot;Important message\u0026quot;), message: Text(\u0026quot;Wear sunscreen\u0026quot;), dismissButton: .default(Text(\u0026quot;Got it!\u0026quot;)))  它定义了一个标题和消息，就像我们在 UIAlertController 中看到的那样，然后添加了一个带有默认样式的 dismiss 按钮和文本 \u0026ldquo;Got it!\u0026ldquo;。\n要显示该 alert，我们需要定义某种可绑定条件，以确定 alert 是否可见。然后将其作为演示附加到主视图中，在 alert 条件变为 true 的时候，立即显示 alert。\n例如: 下面的代码创建一个 showingAlert 的布尔值，用于跟踪是否应该显示 \u0026ldquo;sunscreen message\u0026rdquo;，在点击按钮时将该布尔值设置为 true，然后使用该布尔值创建并附加一个 alert 视图，以便在点击按钮时显示:\nstruct ContentView: View { @State private var showingAlert = false var body: some View { Button(action: { self.showingAlert = true }, label: { Text(\u0026quot;Show alert\u0026quot;) }) .alert(isPresented: $showingAlert, content: { Alert(title: Text(\u0026quot;Important message\u0026quot;), message: Text(\u0026quot;Wear sunscreen\u0026quot;), dismissButton: .default(Text(\u0026quot;Got it!\u0026quot;))) }) } }  效果演示:  提示: 通过这种方式展示一个 alert，当按下关闭按钮时，会自动将 showingAlert 设置回 false。\n ","date":1564989819,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564989819,"objectID":"ac33631a57805546e7c957194ac135e9","permalink":"https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.2_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAalert/","publishdate":"2019-08-05T15:23:39+08:00","relpermalink":"/post/swiftui/8-alerts_and_action_sheets/8.2_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAalert/","section":"post","summary":" ","tags":["Alerts and action sheets"],"title":"8.2_如何显示一个alert","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的声明性编程方法意味着我们不会像在 UIKit 中那样创建和呈现 警报(Alerts) 和 操作表(Action sheets)。 相反，我们定义了它们应该什么条件下显示，告诉它它们应该是什么样子，然后让它自己计算出其余部分。\n这一切都是通过使用 presentation() 修饰符来完成的，该修饰符将新 UI 附加到我们的视图中，当满足某个条件时将显示该 UI。我们可以根据需要附加任意多个，并且它们实际上会等待观察，直到它们的状态变为真(true)，这个时候，它们显示自己的 UI。例如: 我们可以在按下按钮时切换一个布尔值，这会触发要显示的警报(alerts)。\n我们可以将演示文稿附加到主视图或其任何子视图，甚至是可以调整状态的按钮，以便触发演示文稿。这是一个微妙的区别，但重要的是要理解，这些演示文稿并没有附加到按钮上，因为它是一个按钮，也就是说，由于点按了按钮，所以不会以任何方式显示警报(alerts)。相反，我们将它附加到我们的视图层次结构中，以便 SwiftUI 知道它可能在任何时候显示。\n","date":1564977242,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564977242,"objectID":"865830384981a1627c98b80779c25dd1","permalink":"https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.1_%E4%BD%BF%E7%94%A8presentations/","publishdate":"2019-08-05T11:54:02+08:00","relpermalink":"/post/swiftui/8-alerts_and_action_sheets/8.1_%E4%BD%BF%E7%94%A8presentations/","section":"post","summary":" ","tags":["Alerts and action sheets"],"title":"8.1_使用presentations","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果我们需要将多个视图作为一个视图，例如: 一起转换。那么，我们应该使用 SwiftUI 的 Group 视图。这一点尤为重要，因为出于底层的技术原因，我们一次性最多只能向父视图添加十个子视图。\nstruct ContentView: View { var body: some View { VStack { Text(\u0026quot;line - 0\u0026quot;) Text(\u0026quot;line - 1\u0026quot;) Text(\u0026quot;line - 2\u0026quot;) Text(\u0026quot;line - 3\u0026quot;) Text(\u0026quot;line - 4\u0026quot;) Text(\u0026quot;line - 5\u0026quot;) Text(\u0026quot;line - 6\u0026quot;) Text(\u0026quot;line - 7\u0026quot;) Text(\u0026quot;line - 8\u0026quot;) Text(\u0026quot;line - 9\u0026quot;) } } }  效果预览: 一切正常，但是，当我们尝试添加第11行文本的时候，就会报错:\nAmbiguous reference to member 'buildBlock'  错误预览: 后面是一串这样的错误信息:\nContentView.swift:10:16: Found this candidate (SwiftUI.ViewBuilder)  这是因为 SwiftUI 的视图构建系统中有各种各样的代码设计，可以让我们添加1个视图、2个视图、2个视图、3个视图、4个视图、5个视图、6个视图、7个视图、8个视图、9个视图和10个视图，但是不适用于11个或更多视图 - 这不起作用。\n幸运的是，我们可以像这样使用 group:\nstruct ContentView: View { var body: some View { VStack { Group { Text(\u0026quot;line - 0\u0026quot;) Text(\u0026quot;line - 1\u0026quot;) Text(\u0026quot;line - 2\u0026quot;) Text(\u0026quot;line - 3\u0026quot;) Text(\u0026quot;line - 4\u0026quot;) Text(\u0026quot;line - 5\u0026quot;) } Group { Text(\u0026quot;line - 6\u0026quot;) Text(\u0026quot;line - 7\u0026quot;) Text(\u0026quot;line - 8\u0026quot;) Text(\u0026quot;line - 9\u0026quot;) Text(\u0026quot;line - 10\u0026quot;) } } } }  效果预览: 这产生了完全相同的结果，现在我们可以超过10个视图的限制，因为 VStack 中只包含两个视图——两个组。\n","date":1564975347,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564975347,"objectID":"33d04aa393896c532dfe7ecaf0f16316","permalink":"https://coderxdlee.github.io/post/swiftui/7-container/7.4_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/","publishdate":"2019-08-05T11:22:27+08:00","relpermalink":"/post/swiftui/7-container/7.4_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/","section":"post","summary":" ","tags":["Container"],"title":"7.4_如何将视图组合在一起","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"通过 navigationBarItems() 修饰符，我们可以在导航视图的 前缘(leading) 和 后缘(trailing) 添加 bar items。这些 bar items 可能是一个可点击的按钮，但没有任何限制 - 您可以添加任何类型的视图。\n例如: 我们可以在导航视图的后缘(trailing)添加一个 帮助按钮:\nstruct ContentView: View { var body: some View { NavigationView { Text(\u0026quot;Hello SwiftUI\u0026quot;) .navigationBarTitle(Text(\u0026quot;Welcome\u0026quot;)) .navigationBarItems(trailing: Button(action: { print(\u0026quot;Help tapped!\u0026quot;) }, label: { Text(\u0026quot;Help\u0026quot;) }) ) } } }  效果预览: ","date":1564974391,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564974391,"objectID":"5b42b87a7709d97da8bb5898004df85d","permalink":"https://coderxdlee.github.io/post/swiftui/7-container/7.3_%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0bar_items/","publishdate":"2019-08-05T11:06:31+08:00","relpermalink":"/post/swiftui/7-container/7.3_%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0bar_items/","section":"post","summary":" ","tags":["Container"],"title":"7.3_如何给导航视图添加bar_items","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 中的 NavigationView 几乎等同于 UIKit 中的 UINavigationController，因为它不仅可以呈现内容，而且它能够处理视图之间的导航，并在屏幕顶部放置一个导航栏。\n2. 嵌入文本视图 接下来，我们以最简单的形式，将文本视图放入导航视图中，如下所示:\nstruct ContentView: View { var body: some View { NavigationView { Text(\u0026quot;Hello SwiftUI\u0026quot;) } } }  效果预览: 3. 设置导航栏标题 但是这样，顶部的导航栏为空。因此，通常在嵌入的内容上使用 navigationBarTitle() 修饰符，因此，我们可以在屏幕顶部添加标题，如下所示:\nNavigationView { Text(\u0026quot;Hello SwiftUI\u0026quot;) .navigationBarTitle(Text(\u0026quot;Welcome\u0026quot;)) }  效果预览: 4. 自定义导航标题 navigationBarTitle() 修饰符为我们提供了一些自定义选项。\n例如: 默认情况下，它将从呈现它的任何视图继承大型标题显示模式，或者如果它是初始视图，那么它将使用大型标题。但是，如果我们想强制启用或禁用大标题，那么我们应该使用 inline 参数，如下所示:\n.navigationBarTitle(Text(\u0026quot;Welcome\u0026quot;), displayMode: .inline)  效果预览: ","date":1564741102,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564741102,"objectID":"c18b93fad07a8c0a03e6b5f19ea08036","permalink":"https://coderxdlee.github.io/post/swiftui/7-container/7.2_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%A7%86%E5%9B%BE/","publishdate":"2019-08-02T18:18:22+08:00","relpermalink":"/post/swiftui/7-container/7.2_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["Container"],"title":"7.2_如何在导航视图中嵌入视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 设计为开箱即用，这意味着我们可以根据需要将一个视图放在另一个视图中。\n这在处理我们习惯的主要容器视图（如导航控制器和选项卡栏控制器）时特别有用。我们可以将想要的任何视图直接放置到另一个容器视图中，Swiftui将自动调整其布局。\n在这方面，Swiftui自己的容器—— NavigationView、TabbedView、Group 等等——与我们用自己的视图组合制作的容器没有什么不同。\n","date":1564740403,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564740403,"objectID":"1a92b0027c50f5e2d966160ad4dfd7f7","permalink":"https://coderxdlee.github.io/post/swiftui/7-container/7.1_%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8/","publishdate":"2019-08-02T18:06:43+08:00","relpermalink":"/post/swiftui/7-container/7.1_%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8/","section":"post","summary":" ","tags":["Container"],"title":"7.1_使用容器","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 允许我们可以根据需要在表单中添加和删除项目，当我们希望调整基于先前选项可见的选项列表时，特别有用。\n例如，这会显示单个 toggle ，提示用户是否要显示更多高级选项。启用该 toggle 后，会出现第二个 toggle ，允许他们启用日志记录:\nstruct ContentView : View { @State var showingAdvancedOptions = false @State var enableLogging = false var body: some View { Form { Section { Toggle(isOn: $showingAdvancedOptions) { Text(\u0026quot;Show advanced options\u0026quot;) } if showingAdvancedOptions { Toggle(isOn: $enableLogging) { Text(\u0026quot;Enable logging\u0026quot;) } } } } } }  运行效果: 与其他绑定一样，可以要求 SwiftUI 对绑定更改导致的视图更改使用隐式动画，如下所示:\nstruct ContentView: View { @State var showingAdvancedOptions = false @State var enableLogging = false var body: some View { Form { Section { Toggle(isOn: $showingAdvancedOptions.animation()) { Text(\u0026quot;Showing Advanced Options\u0026quot;) } } if showingAdvancedOptions { Toggle(isOn: $enableLogging) { Text(\u0026quot;Enable Logging\u0026quot;) } } } } }  运行效果: ","date":1564730821,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564730821,"objectID":"4081f4bd0ba99f0dfed2df34beebaac8","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.6_%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E8%A1%8C/","publishdate":"2019-08-02T15:27:01+08:00","relpermalink":"/post/swiftui/6-forms/6.6_%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E8%A1%8C/","section":"post","summary":" ","tags":["Forms"],"title":"6.6_显示或隐藏表单行","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 允许我们通过使用 disabled() 修饰符来禁用表单的任何部分甚至整个表单。这需要一个布尔值来定义是否应禁止使用该元素。表单元素的样式会自动更新以反映其状态-例如，buttons 和 toggles 变为灰色。\n例如，这将创建一个包含两个 sections 的表单：一个 section 包含 Toggle ，另一个 section 包含仅在切换打开时才启用的 Button：\nstruct ContentView : View { @State var agreedToTerms = false var body: some View { NavigationView { Form { Section { Toggle(isOn: $agreedToTerms) { Text(\u0026quot;Agree to terms and conditions\u0026quot;) } } Section { Button(action: { // show next screen here }) { Text(\u0026quot;Continue\u0026quot;) } .disabled(!agreedToTerms) } } .navigationBarTitle(Text(\u0026quot;Welcome\u0026quot;)) } } }  运行效果: 如您所见，只需将禁用 (!agreeToTerms) 添加到修改器列表中即可禁用该按钮。\n与许多其他SwiftIUI修饰符一样，您可以提升 disabled()，以便它在 Section 上运行，甚至在整个表单上运行，这取决于您想要的行为——例如，只需移动 disabled(!agreedToTerms) 使它位于该 section 之后:\nSection { Button(action: { // show next screen here }) { Text(\u0026quot;Continue\u0026quot;) } } .disabled(!agreedToTerms)  ","date":1564729449,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564729449,"objectID":"6f38748a5514eb32502747bb8d0c90fc","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/","publishdate":"2019-08-02T15:04:09+08:00","relpermalink":"/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/","section":"post","summary":" ","tags":["Forms"],"title":"6.5_启用和禁用表单中的元素","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"在表单内部，SwiftUI 的 选择器视图 具有特殊的行为，可根据我们使用它们的平台自动进行调整。在 iOS 上，这种行为尤其令人印象深刻，因为选择器可以折叠到一个列表行，该行导航到一个新的可能选项列表中——这是处理许多选项的一种非常自然的方式。\n例如，这将创建一个带有选择器的表单，并为其项使用数组：\nstruct ContentView : View { var strengths = [\u0026quot;Mild\u0026quot;, \u0026quot;Medium\u0026quot;, \u0026quot;Mature\u0026quot;] @State var selectedStrength = 0 var body: some View { NavigationView { Form { Section { Picker(selection: $selectedStrength, label: Text(\u0026quot;Text strength\u0026quot;)) { ForEach(0..\u0026lt;strengths.count) { Text(self.strengths[$0]).tag($0) } } } } .navigationBarTitle(Text(\u0026quot;Select your cheese\u0026quot;)) } } }  运行效果: 表单中的选择器 在 iOS 上，这将显示为一个单独的列表行，您可以点击该行进入一个新屏幕，显示所有可能的选项—— Mild、Medium 和 Mature。您当前的选择旁边将有一个复选标记，当您选择一个新选项时，它将返回上一个屏幕，并显示当前的选项。\n如果要禁用此行为，可以使用.PickerStyle(.wheel)修饰符强制选取器采用其常规样式，如下所示：\nPicker(selection: $selectedStrength, label: Text(\u0026quot;Text strength\u0026quot;)) { ForEach(0..\u0026lt;strengths.count) { Text(self.strengths[$0]).tag($0) } } .pickerStyle(WheelPickerStyle())  运行效果: ","date":1564724999,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564724999,"objectID":"5d9a1e55ef75ff2b84b96b0fddee6775","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","publishdate":"2019-08-02T13:49:59+08:00","relpermalink":"/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","summary":" ","tags":["Forms"],"title":"6.4_表单中选择器的使用","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的表单通常在分成多个部分时效果最好，就像常规的内容列表一样。 如何将它们分组取决于你，但是通常情况下，按照它们的目的进行分组效果最好 - 如果它是一个订单页面你可以将项目放在一个组中，在另一个组中进行定制，并在第三个组中进行交付。 很有帮助的是，表单 sections 与列表 sections 相同，这意味着您可以在两个地方重复使用相同的代码。因此，您可以向 sections 中添加 header 和/或 footer ，或者两者都不使用，只需在 sections 之间获得一些屏幕上的间距。\n例如，这将创建一个包含两个 section 的表单，第一个 section 带有 segmented control 和 toggle ，第二个 section 带有保存按钮:\nstruct ContentView : View { @State var enableLogging = false @State var selectedColor = 0 @State var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Blue\u0026quot;] var body: some View { Form { Section(footer: Text(\u0026quot;Note: Enabling logging may slow down the app\u0026quot;)) { SegmentedControl(selection: $selectedColor) { ForEach(0..\u0026lt;colors.count) { Text(self.colors[$0]).tag($0) } } Toggle(isOn: $enableLogging) { Text(\u0026quot;Enable logging\u0026quot;) } } Section { Button(action: { }) { Text(\u0026quot;Save changes\u0026quot;) } } } .navigationBarTitle(Text(\u0026quot;Settings\u0026quot;)) } }  运行效果: ","date":1564718476,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564718476,"objectID":"dc78807f5ff8179160f7b5f9ba32b7de","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/","publishdate":"2019-08-02T12:01:16+08:00","relpermalink":"/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/","section":"post","summary":" ","tags":["Forms"],"title":"6.3_将表单分成几个sections","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 中的 表单(forms) 可以当作容器使用，就像 HStack 和 VStack 一样，这意味着我们可以根据需要在其中添加其它视图。 但是，表单会自动调整某些控件的行为和样式，以便它们更好地适应表单环境。 例如，我们将创建一个带有 _toggle_、segmentedControl 和 button 的表单:\nstruct ContentView : View { @State var enableLogging = false @State var selectedColor = 0 @State var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Blue\u0026quot;] var body: some View { NavigationView { Form { Picker(selection: $selectedColor, label: Text(\u0026quot;\u0026quot;)) { ForEach(0..\u0026lt;colors.count) { Text(self.colors[$0]).tag($0) } } .pickerStyle(SegmentedPickerStyle()) Toggle(isOn: $enableLogging) { Text(\u0026quot;Enable logging!\u0026quot;) } Button(action: { // activate theme! }) { Text(\u0026quot;Save changes\u0026quot;) } } .navigationBarTitle(Text(\u0026quot;Settings\u0026quot;)) } } }  运行效果: 当代码运行时，我们将看到两件对表单行为至关重要的事情:\n 在 iOS 上，表单自动采用 分组列表 的样式，因此用户可以看到滚动选项。 按钮已经调整了自己，看起来像一个可操作的列表行—— 左对齐，蓝色。   注意: 我们可以根据需要在表单中包含尽可能多的行，但如果需要超过10，请记住使用组(groups)。\n ","date":1564677427,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564677427,"objectID":"f5fd8348b8576268223baf2fd2709fa5","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/","publishdate":"2019-08-02T00:37:07+08:00","relpermalink":"/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/","section":"post","summary":" ","tags":["Forms"],"title":"6.2_基本表单设计","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 简介  SwiftUI 专注于声明性用户界面，因此它为我们提供了一种构建 表单(Form) 的绝佳机制也就不足为奇了。 表单(Form) 指的是用于收集信息的用户输入控件的集合，例如 订单表单 或 设置界面 。 更好的是，在表单中，SwiftUI 的几个部分会自适应放置——它们的外观和行为会发生变化，因此它们与其它输入控件组一起工作得更好。  如果你认为这很聪明，你会喜欢这个: 实际上 SwiftUI 会动态地调整布局，以便它可以根据代码运行的平台自动为我们生成全新的页面 - 它完全将控件的目的与它们的视觉效果分离开来。 这意味着我们描述了我们想要的东西，SwiftUI 找出了在当前平台上实现这一目标的惯用方法。\n 提示: Form 和 VStack 一样是常规容器，因此我们可以根据需要在这两者之间自由切换。\n ","date":1564676492,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564676492,"objectID":"3398a50e9915101695fcaca8082c3d4e","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","publishdate":"2019-08-02T00:21:32+08:00","relpermalink":"/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","section":"post","summary":" ","tags":["Forms"],"title":"6.1_表单的使用介绍","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果创建一个动态列表并在每行中放置多个内容，会发生什么情况？SwiftUI 的解决方案简单、灵活，并且在默认情况下为我们提供了良好的行为: 它创建了一个隐式的 HStack 来保存您的项目，因此它们会自动进行水平布局。 例如，如果我们想要创建一行，其中左侧有一张小图片，剩余的空间分配给一个文本字段，那么我们将从一个结构开始，这样保存数据:\nstruct User: Identifiable { var id = UUID() var username = \u0026quot;Anonymous\u0026quot; }  我已经给出了这两个默认值，以便简化示例。 完成后，我们可以创建一个包含三个用户的数组，并在动态列表中显示它们，如下所示：\nstruct ContentView : View { let users = [User(), User(), User()] var body: some View { List(users) { user in Image(\u0026quot;paul-hudson\u0026quot;) .resizable() .frame(width: 40, height: 40) Text(user.username) } } }  运行效果: ","date":1564673006,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564673006,"objectID":"0bcec38ca5651ba8151dcbd9c3d86a70","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/","publishdate":"2019-08-01T23:23:26+08:00","relpermalink":"/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/","section":"post","summary":" ","tags":["List"],"title":"5.9_如何使用隐式叠加","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 List 支持 grouped 或 plain 样式，就像 UITableView 一样。默认为 plain 样式，但如果要改为 grouped 样式，则应使用 列表 的 .listStyle(.grouped) 修饰符。 例如，这里定义了一个示例行，并将其放置在分组列表中：\nstruct ExampleRow : View { var body: some View { Text(\u0026quot;Example Row\u0026quot;) } } struct ContentView : View { var body: some View { List { Section(header: Text(\u0026quot;Examples\u0026quot;)) { ExampleRow() ExampleRow() ExampleRow() } }.listStyle(.grouped) } }  运行效果: ","date":1564672935,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564672935,"objectID":"d620cb9ff8acc28b957dc223843f3e44","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/","publishdate":"2019-08-01T23:22:15+08:00","relpermalink":"/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/","section":"post","summary":" ","tags":["List"],"title":"5.8_如何制作分组列表","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的列表视图内置了对 sections 和 section headers 的支持，就像 UIKit 中的 UITableView 一样。若要给某些 cells 添加一个 _section_，首先在其周围放置一个 Section，也可以添加 header 和 _footer_。 举个例子，这里有一行包含提醒应用的任务数据：\nstruct TaskRow: View { var body: some View { Text(\u0026quot;Task data goes here\u0026quot;) } }  我们要做的是创建一个列表视图，它有两个Sections：一个用于重要任务，另一个用于次要任务。这是它的样子：\nstruct ContentView : View { var body: some View { List { Section(header: Text(\u0026quot;Important task\u0026quot;)) { TaskRow() TaskRow() TaskRow() } Section(header: Text(\u0026quot;Other task\u0026quot;)) { TaskRow() TaskRow() } } } }  运行效果: ","date":1564672873,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564672873,"objectID":"f0a49fa7ff7024c6785a623bc8471cae","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/","publishdate":"2019-08-01T23:21:13+08:00","relpermalink":"/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/","section":"post","summary":" ","tags":["List"],"title":"5.7_如何向列表中添加sections","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果您已配置 SwiftUI 列表视图以支持删除或编辑其项目，则可以允许用户通过在某个地方添加 EditButton 来切换列表视图的编辑模式。 例如，这个 ContentView 结构定义了一个用户数组，附加了一个 OnDelete() 方法，然后在导航栏中添加了一个编辑按钮:\nstruct ContentView : View { @State var users = [\u0026quot;Paul\u0026quot;, \u0026quot;Taylor\u0026quot;, \u0026quot;Adele\u0026quot;] var body: some View { NavigationView { List { ForEach(users.identified(by: \\.self)) { user in Text(user) } .onDelete(perform: delete) } .navigationBarItems(trailing: EditButton()) } } func delete(at offsets: IndexSet) { if let first = offsets.first { users.remove(at: first) } } }  运行后，您会发现您可以点击编辑按钮来启用或禁用列表中项目的编辑模式。\n","date":1564504813,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564504813,"objectID":"09062a50ca232f471f444aa7a512869c","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/","publishdate":"2019-07-31T00:40:13+08:00","relpermalink":"/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/","section":"post","summary":" ","tags":["List"],"title":"5.6_如何使用EditButton在列表上启用编辑","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 为我们提供了简单地列表挂钩（hooks），让我们可以移动行(rows)，尽管 WWDC 上演示的一些功能在当前的测试版中实际上不可用，所以我们需要一个变通的解决方法。 我们可以将 onMove(perform:) 修饰符附加到列表中的项目，并让它在移动操作发生时调用我们选择的方法。 该方法需要接受 source IndexSet 和 destination Int，如下所示：\nfunc move(from source: IndexSet, to destination: Int) {  移动多个项目时，最好先移动后一个项目，这样可以避免移动其他项目并混淆索引 例如，我们可以创建一个 ContentView 结构，它设置一个由三个用户名字符串组成的数组，并要求SwiftUI在调用 move()方法时移动它们。为了激活“移动”（即显示拖动手柄），它还向导航视图添加了一个编辑按钮，以便用户切换编辑模式。 这是代码:\nstruct ContentView : View { @State var users = [\u0026quot;Paul\u0026quot;, \u0026quot;Taylor\u0026quot;, \u0026quot;Adele\u0026quot;] var body: some View { NavigationView { List { ForEach(users, id: \\.self, content: { user in Text(user) }) .onMove(perform: move) } .navigationBarItems(trailing: EditButton()) } } func move(from source: IndexSet, to destination: Int) { // sort the indexes low to high let reverseSource = source.sorted() // then loop from the back to avoid reordering problems for index in reverseSource.reversed() { // for each item, remove it and insert it at the destination users.insert(users.remove(at: index), at: destination) } } }  运行效果: 在WWDC会话演示中，他们的 move() 方法只是一行代码，因为它在 Swift 数组上使用了一个对我们不可用的扩展——希望它很快就会到来！\n","date":1564503980,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564503980,"objectID":"df5508d053cc8fe9fe049ef34359b904","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/","publishdate":"2019-07-31T00:26:20+08:00","relpermalink":"/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/","section":"post","summary":" ","tags":["List"],"title":"5.5_如何让用户移动列表中的行","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"通过将 OnDelete(perform:) 处理程序附加到部分或全部数据，SwiftUI 可以方便地让用户滑动以删除行。此处理程序需要具有一个特定签名，它可以接受多个索引以删除，如:\nfunc delete(at offsets: IndexSet) {  在这里，您可以循环访问集合中的每个索引，或者只读取第一个索引（如果您只想处理它的话）。因为SwiftUI 正在监视您的状态，所以您所做的任何更改都将自动反映在您的UI中。 注意：此功能的 WWDC 演示使用了一个名为 remove(atOffsets:) 的不存在的Swift数组方法，它为我们完成了所有这些工作 - 希望这将在未来版本中出现。 例如，此代码创建一个包含三个项目列表的 ContentView 结构，然后附加一个 OnDelete(perform:) 修饰符，用于删除列表中的任何项目:\nstruct ContentView: View { @State var users = [\u0026quot;Paul\u0026quot;, \u0026quot;Taylor\u0026quot;, \u0026quot;Adele\u0026quot;] var body: some View { List { ForEach(users, id: \\.self) { user in Text(user) } .onDelete(perform: delete) } } func delete(at offsets: IndexSet) { if let first = offsets.first { users.remove(at: first) } } }  运行效果: 如果您运行该代码，您会发现可以滑动以删除列表中的任何行。\n","date":1564502131,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564502131,"objectID":"9a653dced5a1cfc86a9aaddba974f132","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/","publishdate":"2019-07-30T23:55:31+08:00","relpermalink":"/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/","section":"post","summary":" ","tags":["List"],"title":"5.4_如何让用户从列表中删除行","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"为了处理动态项目，我们必须首先告诉 SwiftUI 如何识别哪个项目是哪个。 这是使用 Identifiable 协议完成的，该协议只有一个要求: 某种类型的 id 值，SwiftUI 可以使用它来查看哪个项目是哪个。 例如，我们可以创建一个 Restaurant 结构体，该结构表示餐馆具有 ID 和 name ，ID 是一个随机标识符，以便 SwiftUI 知道哪个是哪个:\nstruct Restaurant: Identifiable { var id = UUID() var name: String }  接下来，我们将定义列表行的外观。在我们的例子中，我们将定义一个 Restaurantrow 视图，该视图存储一个餐厅并在文本视图中打印其名称:\nstruct RestaurantRow : View { var restaurant: Restaurant var body: some View { Text(\u0026quot;Come and eat at \\(restaurant.name)\u0026quot;) } }  最后，我们可以创建一个列表视图来显示所有内容。这意味着创建一些示例数据，将其放入数组中，然后将其传递到要呈现的列表中:\nstruct ContentView : View { var body: some View { let first = Restaurant(name: \u0026quot;Joe's Original\u0026quot;) let second = Restaurant(name: \u0026quot;The Real Joe's Original\u0026quot;) let third = Restaurant(name: \u0026quot;Original Joe's\u0026quot;) let restaurants = [first, second, third] return List(restaurants) { restaurant in RestaurantRow(restaurant: restaurant) } } }  其中大部分只是创建数据——最后一部分是实际操作的地方:\nreturn List(restaurants) { restaurant in RestaurantRow(restaurant: restaurant) }  它从 restaurants 数组创建一个列表，对数组中的每个项目执行一次闭包。每次执行闭包时，餐厅的输入都将由数组中的一个项目填充，因此我们使用它来创建一个 Restaurantrow。 事实上，在这种小case下，我们可以使代码更短:\nreturn List(restaurants, rowContent: RestaurantRow.init)  运行效果: ","date":1564496763,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564496763,"objectID":"8555c24417af7f523a4567dcdc656847","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/","publishdate":"2019-07-30T22:26:03+08:00","relpermalink":"/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/","section":"post","summary":" ","tags":["List"],"title":"5.3_如何创建动态项目列表","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"要创建静态项目列表，首先需要定义列表中每行的外观。 这是一个与其他视图一样的视图，因此您可以编写如下的视图:\nstruct RestaurantRow : View { var name: String var body: some View { Text(\u0026quot;Restaurant: \\(name)\u0026quot;) } }  既然已经定义了每一行的外观，那么就可以创建一个 List，根据需要创建任意数量的行，如下所示:\nstruct ContentView : View { var body: some View { List { RestaurantRow(name: \u0026quot;Joe's Original\u0026quot;) RestaurantRow(name: \u0026quot;The Real Joe's Original\u0026quot;) RestaurantRow(name: \u0026quot;Original Joe's\u0026quot;) } } }  运行效果: 当该代码运行时，您将在表中看到三行，就像您在 UIKit 中使用 UITableView 一样。 您不需要使每一行使用相同的视图类型，因此您可以根据需要混合和匹配行视图。\n","date":1564417382,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564417382,"objectID":"649672d6167f0ef3d5ff8cbbf5ee77b3","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/","publishdate":"2019-07-30T00:23:02+08:00","relpermalink":"/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/","section":"post","summary":" ","tags":["List"],"title":"5.2_如何创建静态项列表","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 List 视图类似于 UITableView，它可以根据您的需要显示静态或动态表视图单元格(table view cells)。 但是，它使用起来要简单得多:\n 我们不需要在 storyboard 中创建原型cell( prototype cell ); 也不需要在代码中注册 Cell; 我们不需要告诉它有多少行; 我们不需要手动出列(dequeue)和配置单元格等等。  相反，SwiftUI 的列表是为可组合性而设计的 - 旨在能够从较小的东西构建更大的东西。 因此，SwiftUI 不需要一个手动配置单元的大视图控制器，而是让我们构建小视图，知道如何将自己配置为列表行，然后使用它们。\n在代码大小方面（如果没有其他的话），差异是惊人的——您可以删除几乎所有的表视图代码，仍然可以获得与您习惯的相同的出色外观和感觉。\n","date":1564335608,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564335608,"objectID":"6b909d78b771bef1e4bb11b1ae612ad1","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/","publishdate":"2019-07-29T01:40:08+08:00","relpermalink":"/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/","section":"post","summary":" ","tags":["List"],"title":"5.1_使用List","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 对于应该与整个应用程序中所有视图共享的数据，SwiftUI 为我们提供了 @EnvironmentObject 。这使我们可以在任何需要的地方共享模型数据，同时确保当模型数据发生变化时，我们的视图自动保持更新。\n可以将 @EnvironmentObject 看作是在多个视图中使用 @ObjectBinding 的一种更智能、更简单的方法。而不是在视图 A 中创建一些数据，然后将其传递给视图 B，然后查看视图 C，然后在最终使用数据之前查看视图 D，我们可以在视图中创建它并将其放入环境（environment）中，这样的话，视图B、C、D将会自动访问它。\n 注意: 环境对象必须由祖先视图（ancestor view）提供 \u0026ndash; 如果 SwiftUI 找不到正确类型的环境对象，将会导致崩溃（crash），这也适用于预览，所以要小心。\n 2. 示例 例如: 这里有一个可绑定对象，用于存储用户设置:\nimport Combine import SwiftUI ​ class UserSettings: BindableObject { var didChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var score = 0 { didSet { didChange.send(()) } } }  是的，它只存储一个值，但是没关系 \u0026ndash; 重要的是: 当值发生改变时，PassthroughSubject 会告诉所有使用它（这个值）的的视图进行刷新。\n用户设置 是我们可能希望能够在应用程序的任何地方共享的一个合理的数据，这样我们就不再需要手动处理同步。\n因此，当我们的应用程序首次启动时，我们将创建一个 UserSettings 的实例。以便在我们的应用程序中随处都可以访问共享实例。\n如果打开 Scenedelegate.swift ，您将在 （_:willConnectTo:options:）方法：中找到这两行代码\nlet window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: ContentView())  第二行代码创建我们的初始内容视图（ContentView）并将其显示到屏幕上。这就是我们需要传入我们创建的任何环境对象的地方，以便 SwiftUI 可以在 ContentView 以及它使用的任何其它视图中使用我们创建的环境对象。\n首先，将其添加为 SceneDelegate 的一个属性:\nvar settings = UserSettings()  这会创建一个 settings 实例，并安全地存储它。现在回到刚才展示的那两行代码，并更改第二行，以便将我们的 settings 属性作为环境对象传递给 ContentView，如下所示:\nwindow.rootViewController = UIHostingController(rootView: ContentView().environmentObject(settings))  完成后，共享的 UserSettings 实例可用于 ContentView 以及它承载（hosts）或展现（presents）的任何其它视图。你只需要使用 @EnvironmentObject 属性包装器创建一个属性，如下所示:\n@EnvironmentObject var settings: UserSettings  这不需要使用默认值进行初始化，因为它将自动从环境中读取。\n因此，我们可以创建一个 ContentView 结构来增加我们的分数设置，甚至使它呈现出一个显示分数设置的 Detailview，所有这些都不需要创建或传递任何 UserSettings 的本地实例 \u0026ndash; 它总是使用环境。\n以下是实现这一目标的代码:\nstruct ContentView : View { @EnvironmentObject var settings: UserSettings var body: some View { NavigationView { VStack { Button(action: { self.settings.score += 1 }) { Text(\u0026quot;Increase score\u0026quot;) } NavigationButton(destination: DetailView()) { Text(\u0026quot;Show Detail View\u0026quot;) } } } } } ​ struct DetailView : View { @EnvironmentObject var settings: UserSettings var body: some View { // A text view that reads from the environment settings Text(\u0026quot;Score: \\(settings.score)\u0026quot;) } }  因此，一旦你将一个对象注入到环境中，你就可以立即在顶层视图中或者在下面的十层视图中使用它——这并不重要。最重要的是，每当任何视图改变环境时，依赖它的所有视图都会自动刷新，从而保持同步。\n如你所见，我们不需要将场景代理（scene delegate）中的 UserSettings 实例与我们两个视图中的 settings 属性显式关联 - SwiftUI 会自动发现它在环境中有一个 UserSettings 实例，因此这就是要使用的实例。\n 警告：既然我们的视图依赖于存在的环境对象，那么您还必须更新预览代码以提供一些要使用的示例设置。例如，使用 ContentView().EnvironmentObject(UserSettings()) 进行预览应该可以做到这一点。\n ","date":1564334245,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564334245,"objectID":"d7c53467083300299cef722449189967","permalink":"https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/","publishdate":"2019-07-29T01:17:25+08:00","relpermalink":"/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/","section":"post","summary":" ","tags":["Advanced state"],"title":"4.3_如何使用@EnvironmentObject在视图之间共享数据","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 两件重要的事情 当使用对象绑定时，我们需要处理两个细微不同的东西:\n BindableObject 协议，用于一些可以存储数据的类。 @ObjectBinding 属性包装器，在视图中用于存储可绑定对象实例。  2. 示例 举个例子，这是一个遵循 BindableObject 协议的 UserSettings 类:\nimport Combine import SwiftUI class UserSettings: BindableObject { var didChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var score = 0 { didSet { didChange.send(()) } } }  这段代码代码量很小，但是却包含了相当多的知识点，接下来我们逐一解释:\n 第一: didChange是 PassthroughSubject 的一个实例。  这个类来自 Combine 框架，我们需要添加 import Combine 以使我们的代码能够编译。 passthrough subject 的工作很简单: 每当我们想要告诉世界我们的对象发生了变化，我们就要求 passthrough subject 为我们做这件事情。它被称为 pass through ，因为我们传递给它的值实际上会传递给任何正在观察变化对象的视图。 PassthroughSubject 在技术上被称为 publisher ，因为它对世界发布了变化的公告。  第二: PassthroughSubject 是 Void 和 Never 的泛型。  第一个参数 Void 意味着 \u0026ldquo;我不发送任何值\u0026ldquo;。在 SwiftUI 的情况下，我们不需要发送值，因为我们想要的是视图刷新 - 它将自动从 @ObjectBinding 状态中获取新数据。 第二个参数 Never，意味着 \u0026ldquo;我永远不会抛出错误\u0026ldquo;。如果你想，你可以定义一个自定义的错误类型，如 NetworkError，并将其发送，但是通常会发现在可绑定对象内部本地处理错误。  第三: 我们在 UserSettings 的 score 属性上附加了一个 didSet 属性观察器，这样我们就可以在该值发生变化时运行代码。 在我们的示例代码中，每当得分发生变化时，我们都会调用 didChange.send(())，这就是告诉 didChange 发布者发布我们的数据已更改的消息，以便任何订阅的视图都可以刷新。  我们可以在这样的视图中使用 UserSettings类:\nstruct ContentView: View { @ObjectBinding var settings = UserSettings() var body: some View { VStack { Text(\u0026quot;Your score is \\(settings.score)\u0026quot;) Button(action: { self.settings.score += 1 }) { Text(\u0026quot;Increase Score\u0026quot;) } } } }  正如你所看到的，除了使用带有 @ObjectBinding 属性包装器的 settings 之外，其他所有内容都或多或少看起来相同 - SwiftUI 负责处理我们的所有实现细节。 但是有一个重要区别: settings 属性未声明为 private。 这是因为绑定对象可以被多个视图使用，因此通常会公开共享它。\n 警告: 当您使用 publisher 宣布您的对象已更改时，这必须在主线程上发生。\n ","date":1564330164,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564330164,"objectID":"ca9c9c1a2591882da7e410d5071269fe","permalink":"https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/","publishdate":"2019-07-29T00:09:24+08:00","relpermalink":"/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/","section":"post","summary":" ","tags":["Advanced state"],"title":"4.2_如何使用@ObjectBinding创建对象绑定","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. @State 在任何现代应用程序中，状态（State）都是不可避免的。\n但是对于 SwiftUI 来说，重要的是要记住:\n 我们所有的视图都只是它们的状态的函数 我们不会直接改变视图，而是操纵状态并让它决定结果  SwiftUI 为我们提供了几种在应用程序中存储状态的方法，但是它们之间略有不同，理解它们之间的区别对于正确使用框架是很重要的。\n到目前为止，在我们所有的状态示例中，我们都使用 @State 来创建如下属性:\nstruct ContentView : View { @State var score = 0 // more code }  这段代码在视图中创建了一个属性，但它使用 @State 属性包装器（property wrapper）来请求 SwiftUI 来管理内存。这一点很重要: 我们所有的视图都是结构体（structs），这意味着它们不能被改变，如果我们不能在一场比赛中给一个分数加1，那么这就不是一场比赛了。\n因此，当我们使用 @State 创建一个属性时，就意味着将该属性的控制权交给了 SwiftUI，这样的话，只要视图存在，它就在内存中保持不变。当该状态发生变化时，SwiftUI 知道用最新的变化自动重新加载视图，以便反映其新信息。\n@State 对于属于特定视图且从未在该视图之外使用的简单属性非常有用，因此通常最好将这些属性标记为私有属性，如下所示:\n@State private var score = 0  这再次强化了这样一种观点，即这种状态是专门设计的，永远不会脱离它的视图。简单理解，就是在视图内部使用的。\n2. @ObjectBinding 对于更复杂的属性:\n 当你有一个要使用的自定义类型，该类型可能具有多个属性和方法 可能在多个视图中共享时  那么，你应该使用 @ObjectBinding。 这与 @State 非常相似，只是现在我们使用的是外部引用类型，而不是简单地本地属性，如字符串或整数。我们仍然可以说视图取决于要更改的数据，除了我们负责管理自己的数据: 我们需要创建类的实例，创建自己的属性，等等。\n与 @ObjectBinding 一起使用的任何类型都应该遵循 BindableObject 协议，该协议只有一个要求: 您的类型必须实现某种类型的 didchange 属性，该属性在数据发生更改时通知视图。\n这就是我的意思，当我说这是你负责管理自己的数据时——当你在绑定对象上设置一个属性时，你就可以决定是否应该强制视图刷新。你通常会的，但不是必须的。\n一个可绑定的对象可以使用 Combine 框架中 publisher 通知其视图重要数据已经更改。如果碰巧有几个视图使用可绑定对象的数据，那么它将自动通知所有这些视图。\n 警告: 当你使用 publisher 宣布你的对象已更改，这个动作必须在主线程上执行。\n 3. @EnvironmentObject 我们已经了解了如何通过 @State 声明一个类型的简单属性，该类型数据在发生更改时自动导致视图更新，以及如何通过 @Objectbinding 声明外部类型的属性，该属性在更改时可能会或可能不会导致视图更新。这两个都必须由我们的视图设置，但是 @Objectbinding 可能与其他视图共享。\n针对这种情况，我们还有第三种类型的属性可供使用，即 @EnvironmentObject。这是一个通过应用程序本身对视图可用的值 -\n 它是每个视图都可以读取的共享数据，因此，如果你的应用程序有一些重要的模型数据，所有视图都需要读取，你可以把它从一个视图传递到另一个视图，或者把它放到每个视图都可以即时访问的环境中。\n 当我们需要在应用程序中传递大量数据时，可以将 @Environmentobject 视为一种极大的便利。由于所有视图都指向同一模型，因此如果一个视图更改模型，则所有视图都会立即更新 - 不会有使应用程序的不同部分不同的风险。\n4. 总结差异  将 @State 用于属于单个视图的简单属性。 它们通常应标记为 private。 将 @ObjectBinding 用于可能属于多个视图的复杂属性。 无论何时使用引用类型，都应该使用@ObjectBinding。 将 @EnvironmentObject 用于在应用程序中其他位置创建的属性，例如共享数据。  在这三种方法中，您会发现 @objectbinding 是最有用和最常用的，因此如果您不确定要使用哪种方法，请从那里开始。\n","date":1564324295,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564324295,"objectID":"4ab05b3531ff232d121b14870c542c81","permalink":"https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/","publishdate":"2019-07-28T22:31:35+08:00","relpermalink":"/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/","section":"post","summary":" ","tags":["Advanced state"],"title":"4.1_@ObjectBinding、@State 和 @EnvironmentObject三者之间的区别","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 以 onAppear() 和 onDisappear() 的形式为我们提供了 UIKit 的viewDidAppear() 和 viewDidDisappear() 的等价物。 您可以将任何代码附加到您想要的这两个事件，SwiftUI 将在它们发生时执行它们。\n2. 示例 注意：在当前的beta版本， onAppear() 工作得很好，但 onDisappear() 似乎没有被调用。 例如: 我们创建两个使用 onAppear() 和 onDisappear() 来打印消息的视图，并使用导航按钮在两者之间移动：\nstruct ContentView : View { var body: some View { NavigationView { NavigationLink(destination: DetailView()) { Text(\u0026quot;Hello World\u0026quot;) } }.onAppear { print(\u0026quot;ContentView appeared!\u0026quot;) }.onDisappear { print(\u0026quot;ContentView disappeared!\u0026quot;) } } } struct DetailView : View { var body: some View { VStack { Text(\u0026quot;Second View\u0026quot;) }.onAppear { print(\u0026quot;DetailView appeared!\u0026quot;) }.onDisappear { print(\u0026quot;DetailView disappeared!\u0026quot;) } } }  运行效果: 当代码运行时，我们应该能够在两个视图之间移动，并看到 Xcode 调试控制台中打印的消息。\n","date":1564317440,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564317440,"objectID":"8f314f08560aabefab6576fcc2aea91e","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/","publishdate":"2019-07-28T20:37:20+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.14_如何响应视图生命周期事件_appear_and_disappear","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 任何 SwiftUI 视图都可以附加手势识别器，而这些手势识别器又可以附加闭包，在识别器被激活时执行闭包。\n2. 示例 有几个手势识别器可供使用，这里我们提供其中几个的代码示例，以帮助入门 - 我们将看到它们有多相似。\n2.1 TapGesture 点击手势 创建 TapGesture 时，可以指定触发手势所需的 点击次数，然后附加将在手势发生时运行的 onEnded 闭包。\n例如，我们来创建一个每次点击时都会变大的图像:\nstruct ContentView: View { @State private var scale: Length = 1 var body: some View { Image(\u0026quot;example-image\u0026quot;) .scaleEffect(scale) .gesture( TapGesture() .onEnded({ (_) in self.scale += 0.1 }) ) } }  运行效果: 2.2 LongPressGesture 长按手势 LongPressGesture 可识别用户何时按下视图并保持至少一段用户指定的时间。 因此，我们创建一个图像视图，在按下该消息至少两秒时打印该消息:\nstruct ContentView: View { var body: some View { Image(\u0026quot;example-image\u0026quot;) .gesture( LongPressGesture(minimumDuration: 2.0) .onEnded({ (_) in print(\u0026quot;LongPressed!\u0026quot;) }) ) } }  运行效果: 2.3 DragGesture 拖拽手势 最后，当用户按下视图并移动至少一定距离时，DragGesture 会触发。因此，我们创建一个带有拖动手势的图像，当它们移动至少50个点时会触发:\nstruct ContentView: View { var body: some View { Image(\u0026quot;example-image\u0026quot;) .gesture( DragGesture(minimumDistance: 50) .onEnded({ (_) in print(\u0026quot;Dragged!\u0026quot;) }) ) } }  ","date":1564315172,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564315172,"objectID":"3364903379c9c273bb5481b517b2ecad","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/","publishdate":"2019-07-28T19:59:32+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.13_如何给视图添加手势识别器","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 任何 SwiftUI 视图都可以附加 点击操作(tap action)，我们可以指定在触发操作之前应该接收多少次点击。\n2. 示例 例如: 我们创建一个文本视图，在点击时将打印消息:\nstruct ContentView : View { var body: some View { Text(\u0026quot;Tap me!\u0026quot;) .tapAction { print(\u0026quot;Tapped\u0026quot;) } } }  运行效果: 再创建一个图像视图，当双击时将打印消息:\nstruct ContentView : View { var body: some View { Image(\u0026quot;example-img\u0026quot;) .tapAction(count: 2) { print(\u0026quot;Double tapped!\u0026quot;) } }  运行效果: ","date":1564310318,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564310318,"objectID":"55e3ef6773fc6b10e994bc4aa484b72b","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/","publishdate":"2019-07-28T18:38:38+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.12_如何设置tap和double Tap手势","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI中 的 SegmentedControl 与 UIKit中的 UISegmentedControl 的工作方式类似，但是它需要绑定到某种状态（state），并且必须确保为每个分段（segment）提供一个 tag 标记，以便能够识别它。分段(Segments) 可以是文本或者图片，其它任何东西都会自动失败。\n2. 示例 我们将创建一个分段控件，该控件使用 favoriteColor 作为状态属性，并且在下面添加一个文本视图，用于显示所选的任何值:\nstruct ContentView : View { @State private var favoriteColor = 0 var body: some View { VStack { SegmentedControl(selection: $favoriteColor) { Text(\u0026quot;Red\u0026quot;).tag(0) Text(\u0026quot;Green\u0026quot;).tag(1) Text(\u0026quot;Blue\u0026quot;).tag(2) } Text(\u0026quot;Value: \\(favoriteColor)\u0026quot;) } } }  运行效果: 不过，在本例中，我们最好创建一个数组来存储各种颜色，然后使用 foreach 在内部使用循环创建文本视图:\nstruct ContentView : View { @State private var favoriteColor = 0 var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Blue\u0026quot;] var body: some View { VStack { SegmentedControl(selection: $favoriteColor) { ForEach(0..\u0026lt;colors.count) { index in Text(self.colors[index]).tag(index) } } Text(\u0026quot;Value: \\(colors[favoriteColor])\u0026quot;) } } }  运行效果: ","date":1564280205,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564280205,"objectID":"61d4493272264ab2d0d062d71dec74d2","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-28T10:16:45+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.11_如何创建分段控件并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI 中的 DatePicker 视图类似于 UIkit 中的 UIDatePicker，它提供了各种选项来控制它的外观和工作方式。和所有存储值的控件一样，它也需要绑定到应用程序中的某种状态。\n2. 示例 例如: 我们创建一个绑定到 birthDate 属性的日期选择器，然后显示日期选择器的值，如下所示:\nstruct ContentView : View { var dateFormatter: DateFormatter { let formatter = DateFormatter() formatter.dateStyle = .long return formatter } @State var birthDate = Date() var body: some View { VStack { DatePicker($birthDate, maximumDate: Date(), displayedComponents: .date) Text(\u0026quot;Date is \\(birthDate, formatter: dateFormatter)\u0026quot;) } } }  运行效果: 可以看到我已经将 DisplayedComponents 设置为 .Date，但您也可以使用 .hourAndMinute来获取时间数据。 我还使用 maximumDate 来阻止人们在将来指定出生日期，但是您可以指定 minimumDate 来阻止人们指定早于您选择的日期。\n","date":1564244924,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564244924,"objectID":"4cddfa543f0ee080e0ac194513780cad","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-28T00:28:44+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.10_如何创建DatePicker并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 Picker 视图将 UIPicker 和 UITableView 结合在一起。同时也适应其它操作系统上的其它样式。最棒的是我们真的不需要关系它是如何工作的 \u0026ndash; SwiftUI 可以很好的自动适应它的环境。 与大多数其它控件一样，必须将 picker 附加到某种 state，以跟踪 picker 的选择。例如: 这会创建一个 colors 数组和一个存储所选颜色的整数，然后将其与 picker，Text 视图一起使用，以便您可以看到正在读取的值:\nstruct ContentView: View { var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Orange\u0026quot;, \u0026quot;Yellow\u0026quot;, \u0026quot;Green\u0026quot;] @State private var selectedColor = 0 var body: some View { VStack { Picker(selection: $selectedColor, label: Text(\u0026quot;Please choose a color\u0026quot;)) { ForEach(0..\u0026lt;colors.count) { Text(self.colors[$0]).tag($0) } } Text(\u0026quot;You selected: \\(colors[selectedColor]) \u0026quot;) } } }  运行效果: 注意: 将选择器视图放在某个内容中非常重要，以确保它在iOS上以默认的轮子样式显示。\n","date":1564242984,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564242984,"objectID":"95d8ab883b2ca60edb613b9212c745e8","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-27T23:56:24+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.9_如何创建选择器Picker并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 的 Slider 视图的工作原理与 UISlider 非常相似，尽管您需要将其绑定到某个地方，以便存储其值。 当我们创建它时，可以提供多种参数，但我们可能最关心的是:\n Value: 要绑定到的值是多少 From and To: 滑块的范围 By: 移动滑块时要更改多少值  2. 示例 例如: 我们创建一个绑定到 Celsius 属性的滑块，然后在滑块移动时更新文本视图，以便在 Celsius(摄氏温度) 和 Fahrenheit(华氏温度) 之间进行转换:\nstruct ContentView : View { @State var celsius: Double = 0 var body: some View { VStack { Slider(value: $celsius, from: -100, through: 100, by: 0.1) .padding() Text(\u0026quot;\\(celsius) Celsius is \\(celsius * 9 / 5 + 32) Fahrenheit\u0026quot;) } } }  运行效果: ","date":1564242023,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564242023,"objectID":"6e0dfc5aeee85c0ba579fc57c08604fc","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-27T23:40:23+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.8_如何创建Slider并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 SecureTextField 的工作方式与常规的 TextField 完全相同，只是为了保护隐私而屏蔽了字符。当然，它绑定的底层值（underlying value）仍然是一个普通的字符串，因此你可以根据需要检查它。 下面是一个示例，创建了一个绑定到本地 @State 属性的 SecureField，以便我们显示键入的内容:\nstruct ContentView : View { @State private var password = \u0026quot;\u0026quot; var body: some View { VStack { SecureField($password, placeholder: Text(\u0026quot;Enter your password:\u0026quot;)) .padding() Text(\u0026quot;Your entered: \\(password)\u0026quot;) } } }  运行效果: 提示: 在 beta1 和 beta2 中，你应该使用: SecureField($password)\n","date":1564241580,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564241580,"objectID":"3d6ecacd3c6855a02c680a90954675d3","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/","publishdate":"2019-07-27T23:33:00+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.7_如何使用SecureField创建一个安全的文本输入框","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 TextField 支持占位符文本，就像 UITextField 一样 \u0026ndash; 当 TextField 为空时在 TextField 中显示灰色文本。要么使用提示（”Enter your password“），要么显示一些示例数据。\n要设置 placeholder，请将其作为 TextField 初始化设置的一部分传入，如下所示:\nstruct ContentView : View { @State var emailAddress = \u0026quot;\u0026quot; var body: some View { TextField($emailAddress, placeholder: Text(\u0026quot;test@gmail.com\u0026quot;)) .textFieldStyle(.roundedBorder) .padding() } }  运行效果: 这将在 TextField 中显示占位文本 test@gmail.com，而 TextField 为空，但一旦用户在其中键入内容，占位文本就会消失。\n","date":1564239599,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564239599,"objectID":"0e3882801ea545ed88f41f5dee0dc56c","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/","publishdate":"2019-07-27T22:59:59+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.6_如何给TextField添加占位符","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 TextField 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更愿意在 TextField 周围添加边框，以使其更清晰。 如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 .textFieldStyle(.roundedBorder) 修饰符，如下所示:\nstruct ContentView : View { @State var text = \u0026quot;\u0026quot; var body: some View { TextField($text, placeholder: Text(\u0026quot;Enter some text\u0026quot;)) .padding() .textFieldStyle(.roundedBorder) } }  运行效果: ","date":1564238554,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564238554,"objectID":"c5921d17d28e606592038104bf6e7930","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/","publishdate":"2019-07-27T22:42:34+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.5_如何给TextField添加边框","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 的 TextField 视图类似于 UIkit 中的 UITextField，但是，在默认情况下 TextField 看起来有点不同，并且它非常依赖于 状态绑定（binding to state）。\n2. 创建 TextField 那么，要创建一个 TextField，我们应该给在 text field 传入一个 placeholder，再加上它应该绑定到的状态属性。\n例如: 现在，我们要创建一个 绑定到本地字符串的 TextField，然后在其下面放置一个文本视图，在键入时显示 TextField 的输出:\nstruct ContentView : View { @State var name = \u0026quot;Devin\u0026quot; var body: some View { VStack { TextField($name, placeholder: Text(\u0026quot;Enter your name\u0026quot;)) Text(\u0026quot;Hello, \\(name)\u0026quot;) } } }  运行后，您应该能够在 TextField 中键入内容，并看到下面直接显示一条问候语。 运行效果: 提示: 在 beta1 和 beta2 中，应该改用 TextField($name)。 使用 TextField 时有两个重要的限制条件。首先，默认情况下，它没有边框，因此你可能看不到任何内容 \u0026ndash; 你需要大致点击其所在位置，以激活键盘。 其次，您可能会发现无法在布局的画布预览中键入内容。如果遇到这个问题，请按Cmd+R在模拟器中构建和运行代码。\n","date":1564234941,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564234941,"objectID":"bc2d48638948cb5663d60f788ef39370","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/","publishdate":"2019-07-27T21:42:21+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.4_如何从TextField中读取文本","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. Button vs UIButton SwiftUI 的 按钮(Button) 类似于 UIKit 中的 UIButton，跟 UIButton 的区别在于:\n 在显示内容方面 SwiftUI 的按钮更为灵活 SwiftUI 的按钮使用 闭包 来实现其 action，而 UIButton 使用的是 target/action 系统  2. Button 初体验 那么，如何创建一个 SwiftUI 的按钮呢?，我们可以从以下代码开始:\nButton(action: { // your action here }) { Text(\u0026quot;Button title\u0026quot;) }  由以上代码可以看到，创建 Button 的的方法有两个参数，都是闭包，第一个闭包负责传入 action，第二个闭包负责传入按钮上的文本。\n3. Button 简单用例 例如: 我们可以创建一个按钮，在点击按钮时显示或隐藏一些详细信息:\nstruct ContentView : View { @State var showDetails = false var body: some View { VStack { Button(action: { self.showDetails.toggle() }) { Text(\u0026quot;Show detail information\u0026quot;) } if showDetails { Text(\u0026quot;You should follow me on M X Website\u0026quot;) .font(.largeTitle) .lineLimit(nil) } } } }  运行效果: 4. 提示 在学习框架时最常做的事情是分散调用 print()，这样我们就可以看到什么时候发生了什么事情。 如果我们想通过按钮 action 来尝试，首先应右键单击预览画布中的播放按钮，然后选择 调试预览，以便调用 print() 工作。 按钮内的标题可以是任何类型的视图，因此您可以创建这样的图像按钮:\nButton(action: { self.showDetails.toggle() }) { Image(\u0026quot;example-image\u0026quot;) }  运行效果: ","date":1564215682,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564215682,"objectID":"d20c00144e66723398bd9ac6d31dff6c","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/","publishdate":"2019-07-27T16:21:22+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.3_如何创建一个可点击的按钮","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 中的 toggle 允许用户在 true 和 false 之间移动，就像 UIKit 中的 UISwitch 一样。\n例如:\n我们可以创建一个 toggle ，然后根据 toggle 是否启动来决定显示或者不显示消息。但是我们不希望手动跟踪 toggle 的状态 \u0026ndash; 我们希望 SwiftUI 为我们做这件事。 与以往不同，在这里，我们应该定义一个 @State Boolean 属性，用于存储 toggle 的当前值。然后我们可以使用它来显示或隐藏其它视图。\n例如:\nstruct ContentView : View { @State var showGreeting = true var body: some View { VStack { Toggle(isOn: $showGreeting) { Text(\u0026quot;Show welcome message!\u0026quot;) }.padding() if showGreeting { Text(\u0026quot;Hello world\u0026quot;) } } } }  运行效果: 这段代码，只有当 showGreeting 为 true 时才会返回文本视图，这意味着当 showGreeting 为 false 时，VStack 的大小会减小 - 它的堆栈中没有第二个视图。\n","date":1564214142,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564214142,"objectID":"3c1e66f81817090b3b3c051810d18775","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/","publishdate":"2019-07-27T15:55:42+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.2_如何创建拨动开关","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 概念 所有应用程序都会改变状态。\n例如:\n 用户可能点击了一个按钮来显示更多信息 用户可能已经在文本框中输入了一些文本 用户从日期选择器中选择了一个日期  所有涉及应用程序 从一种状态转变到另一种状态 的事情，都叫做应用程序改变状态。\n2. 问题所在 状态的问题在于它是混乱的: 当它发生变化时，我们需要发现变化并更新我们的布局来匹配变化。 这个一开始听起来可能很简单，但是随着我们的状态的不断增长，它就会变得越来越难 - 因为这个时候，我们很容易忘记更新一件事，或者更新顺序出错，以致于用户界面状态达不到预期效果。\n3. SwiftUI 如何破解？ SwiftUI 通过 从控件中移除状态 来解决这个问题。\n当我们向视图添加属性时，这些属性实际上是惰性的 - 当然，它们有值，但是更改这些值并不会做任何事情。 但是如果我们在这些属性之前添加了特殊的@State 来包装属性，SwiftUI将自动监视属性变化并更新使用该属性的视图的任何部分。\n示例代码:\n@state var name: String = \u0026quot;\u0026quot;   注意: @state 这种语法称为 属性包装器，这里不作详细介绍，可以自行查找文档。\n 当涉及到某种状态时 - 例如，当切换开关（toggle switch）改变时告诉状态属性改变。 这里需要注意的是: 我们不能直接引用这个属性属性。这是因为 Swift 会认为我们现在所指的是\u0026quot;属性当前的值\u0026quot;，而不是说 \u0026quot;请注意这件事情(属性状态变化)\u0026quot;。幸运的是，SwiftUI 的解决方案是在属性名称前放置一个美元符号($)，这样的话，我们就可以引用属性本身而不是它当前的值。\n 当然，这里一开始理解起有点令人困惑，但在当我们学习一两个示例之后就会理解，非常简单。\n 最后，请记住，SwiftUI 是声明性的，这意味着我们预先告诉它所有可能状态的所有布局，并让它知道当属性发生变化时如何在它们之间移动。我们称之为 绑定（binding） - 要求 SwiftUI 同步UI控件和底层属性之间的更改。 如果你已经习惯了一种更为迫切的编程风格，那么使用 state 一开始会让你头疼一些，但不要担心 - 一旦你完成了它，你就很明确了。\n","date":1564152499,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564152499,"objectID":"60ad908be8392124a7932d32de1fad67","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/","publishdate":"2019-07-26T22:48:19+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.1_使用 state","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"默认情况下，我们的 SwiftUI 视图将主要位于安全区域内 - 它将会到达屏幕底部，但不会靠近设备顶部的任何凹口。 如果我们想改变它 - 想让视图真正全屏，即使这意味着被一个缺口或其他硬件切口部分遮挡 - 那么我们应该使用 edgesIgnoringSafeArea() 修饰符。 例如，这会创建一个红色文本视图，要求填充所有可用空间，然后将其设置为忽略任何安全区域，以使其真正边缘到边缘。\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity) .background(Color.red) .edgesIgnoringSafeArea(.all) }  运行效果: ","date":1564150370,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564150370,"objectID":"2d7ef1463d807d926bce34ac48fcf79f","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/","publishdate":"2019-07-26T22:12:50+08:00","relpermalink":"/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/","section":"post","summary":" ","tags":["View layout"],"title":"2.8_如何将视图放到安全区域之外","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 通过在环境中暴露 size classes 来原生支持它。如果要使用它，我们首先需要创建一个 @Environment 对象来存储其值，如下所示:\n@Environment(\\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?  然后在我们需要时检查该属性的值，查找 .compact 或 .regular，如下所示:\nif horizontalSizeClass == .compact { return Text(\u0026quot;Compact\u0026quot;) } else { return Text(\u0026quot;Regular\u0026quot;) }  将所有代码组合在一起，可以创建这样的视图:\nstruct ContentView: View { @Environment(\\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass? var body: some View { if horizontalSizeClass == .compact { return Text(\u0026quot;Compact\u0026quot;) } else { return Text(\u0026quot;Regular\u0026quot;) } } }  运行效果:\n(1) 正向竖屏 (2) 横屏 - 刘海在右侧 (3) 横屏 - 刘海在左侧 ","date":1564131137,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564131137,"objectID":"b019851a2ebb1462e1c5b879efc221ee","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/","publishdate":"2019-07-26T16:52:17+08:00","relpermalink":"/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["View layout"],"title":"2.7_如何使用size_classes创建不同的布局","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 我们通常会发现，我们需要循环一个序列来创建视图，而在 SwiftUI 中，这是通过 ForEach 来完成的。\n重要提示: 我们很容易一看到 ForEach 就认为它与 Swift 序列中的 forEach() 方法相同，但事实并非如你所见。\n SwiftUI 中的 ForEach 本身是一个视图结构，这就意味着我们可以根据需要直接从视图 Body 返回它。 我们为它提供一系列项目，可能还需要告诉 SwiftUI 它如何唯一地标识每个项目，以便 SwiftUI 知道如何在值更改时更新它们。 我们还传递一个要运行的闭包，来为循环中的每个项创建一个视图。 对于范围内的简单循环，您可以将范围直接传递给ForEach。  1. 循环 1\u0026hellip;10 创建文本视图 例如，这从10减少到1然后在最后添加一条消息：\nvar body: some View { VStack(alignment: .leading) { ForEach((1...10).reversed()) { Text(\u0026quot;\\($0)…\u0026quot;) } Text(\u0026quot;Ready or not, here I come!\u0026quot;) } }  运行效果: 2. ForEach colors 对于简单类型数组（如字符串、整数、颜色等）的循环，可以在数组上使用 .identified(by: \\.self)，让 SwiftUI 使用值本身作为标识符。因此，如果您的数组是 [\u0026quot;cat\u0026quot;, \u0026quot;Dog\u0026quot;, \u0026quot;monkey\u0026quot;]，那么 SwiftUI 会将这些字符串本身作为您的视图的标识符。 因此，此代码创建一个包含三种颜色的数组，在它们上面循环，并使用每个颜色名称和颜色值创建文本视图：\nlet colors: [Color] = [.red, .green, .blue] var body: some View { VStack { ForEach(colors.identified(by: \\.self)) { color in Text(color.description.capitalized) .padding() .background(color) } } }  运行效果: 3. ForEach custom type 如果您的数组中有自定义类型，则应使用 .identified(by:) 与您的类型中的任何属性唯一标识它。 例如，这是一个存储测试结果的结构，如下所示：\nstruct Result { var id = UUID() var score: Int }  它有一个带有 UUID 的 id 属性，这意味着它保证是唯一的 - 完美的用于我们的目的。 如果我们想循环一个结果数组，创建一个显示 VStack 中每个结果的文本视图，那么我们将使用它：\nlet results = [Result(score: 8), Result(score: 5), Result(score: 10)] var body: some View { VStack { ForEach(results.identified(by: \\.id)) { result in Text(\u0026quot;Result: \\(result.score)\u0026quot;) } } }  运行效果: 这告诉 SwiftUI 它可以通过查看它们的 id 属性来区分 ForEach 中的视图。 提示：如果您使 Result 符合 Identifiable protocol，您只需编写 ForEach（Result）。 符合此协议意味着添加唯一标识每个对象的 id 属性，在我们的示例中我们已经拥有，因此您只需编写 struct Result：Identifiable {！\n","date":1564071700,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564071700,"objectID":"44f7c36133de110ed7eedcbf7f02adf5","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/","publishdate":"2019-07-26T00:21:40+08:00","relpermalink":"/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["View layout"],"title":"2.6_如何使用ForEach在循环中创建视图","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 当我们从视图的 body 返回 some View 的时候，Swift 理解这意味着我们有一个特定的返回类型。\n例如: 如果我们想掷硬币并显示 \u0026ldquo;你赢了!\u0026ldquo;，但是我们不能这样写: 要么返回一个 Image，要么返回一个 Text，写着 \u0026ldquo;下次祝你好运\u0026rdquo;:\nvar body: some View { if Bool.random() { Image(\u0026quot;example-image\u0026quot;) } else { Text(\u0026quot;Better luck next time\u0026quot;) } }  这段代码会报错: 因为它可能返回 Image 或者 Text ，这是不允许的 \u0026ndash; 我们必须精确返回一种类型。 有两种方法可以解决这个问题。\n1. Group 第一种方法是将输出包装在一个 group 中，这样无论我们发送图像视图还是文本视图，它们都将返回到一个 group 中:\nvar body: some View { Group { if Bool.random() { Image(\u0026quot;example-image\u0026quot;) } else { Text(\u0026quot;Better luck next time\u0026quot;) } } }  运行效果: 2. AnyView 第二种方法，SwiftUI 提供了一个名为 AnyView 的类型，我们可以返回这种类型:\nvar body: AnyView { if Bool.random() { return AnyView(Image(\u0026quot;example-image\u0026quot;)) } else { return AnyView(Text(\u0026quot;Better luck next time\u0026quot;)) } }  如果你还没有听说过这个概念，它会强制让 Swift 忘记 AnyView 中包含的特定类型，让它们看起来像是一样的东西。但这有性能成本，所以不要经常使用它。 尽管 Group 和 AnyView 都为我们的布局实现了相同的结果，但通常最好使用 Group，因为它对 SwiftUI 更有效。\n","date":1564033641,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564033641,"objectID":"8060bb86f12304582ea806ac36436683","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/","publishdate":"2019-07-25T13:47:21+08:00","relpermalink":"/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/","section":"post","summary":" ","tags":["View layout"],"title":"2.5_如何返回不同的视图类型","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 有一个专用的 stack 类型，用于创建重叠内容，例如，如果我们想在图片上放置一些文本，它就很有用。它被称为 ZStack，其工作原理与其他两种 stack 类型相同。\n1. 在文本下面放置图片 例如: 我们可以在如下文本下面放置一个大图像:\nvar body: some View { ZStack() { Image(\u0026quot;example-image\u0026quot;) Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background(Color.black) .foregroundColor(.white) } }  运行效果: 2. 对齐 与其它 stack 类型一样，ZStack 也可以设置对齐方式，这样它就不会总是将事物置于自身的中心位置:\nvar body: some View { ZStack(alignment: .leading) { Image(\u0026quot;example-image\u0026quot;) .resizable() .aspectRatio(contentMode: .fit) Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background(Color.black) .foregroundColor(.white) } }  运行效果: 但是，它没有 spacing 属性，因为它实际上没有意义。\n","date":1564032412,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564032412,"objectID":"a7bfae9c2de4a6e9a4edd2f9b2c4c6d9","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/","publishdate":"2019-07-25T13:26:52+08:00","relpermalink":"/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/","section":"post","summary":" ","tags":["View layout"],"title":"2.4_如何使用ZStack将视图叠加在一起","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 允许我们使用 padding() 修饰符在视图周围设置单独的填充。\n1. 系统默认 padding 如果在不传参数的情况下使用 padding() ，您将在所有边上获得系统默认填充，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里默认设置了视图四周的填充。\n2. 只设置一侧系统默认 padding 我们也可以自定义要 apply 的 padding 和位置。因此，我们只希望将系统填充应用于一侧:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里只设置了底部填充，与上面的例子不同。\n3. 用具体数值来设置 padding 我们可能希望控制对所有边应用了多少填充:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 4. 在视图一侧添加特定数量的填充 我们也可以将这两者结合起来，在视图的一侧添加特定数量的填充：\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom, 100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564025985,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564025985,"objectID":"e4177bc07a2849e3ab458ab3bb0941b0","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","publishdate":"2019-07-25T11:39:45+08:00","relpermalink":"/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","section":"post","summary":" ","tags":["View layout"],"title":"2.3_如何使用padding控制单个视图周围的间距","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 1. spacing 我们可以通过在 SwiftUI stacks 的构造方法中填一个值来设置间距，如下所示:\nvar body: some View { VStack(spacing: 50) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 2. Divider 我们可以在项目之间创建分隔符，以便 SwiftUI 在 stack 中的每个项目之间进行小的视觉区分，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Divider() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 3. alignment 默认情况下，stacks 中的项目居中对齐。\n 在 HStack 中: 项目在中间垂直对齐，因此如果有两个不同高度的文本视图，它们都将与垂直中心对齐。 在 VStack 中: 项目在中间水平对齐，因此如果有两个长度不同的文本视图，它们都将与水平中心对齐。  要调整这种情况，请在创建 stack 时按以下方式传递一个 alignment 参数:\nvar body: some View { VStack(alignment: .leading) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使 Hello SwiftUI 和 Hello M X 左对齐，但它们最终将位于屏幕的中间，因为 stack 只占用所需的空间。\n4.同时设置 alignment 和 spacing 我们可以同时使用 alignment 和 spacing ，如下所示:\nvar body: some View { VStack(alignment: .leading, spacing: 20) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使两个文本视图水平对齐到 leading（对于从左到右的语言是左对齐），并在它们之间放置20个点的垂直间距。\n","date":1564023292,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564023292,"objectID":"294ef00070d5dc7a12b85b39352a4f69","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","publishdate":"2019-07-25T10:54:52+08:00","relpermalink":"/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["View layout"],"title":"2.2_如何通过alignment和spacing自定义stack布局","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 的内容视图 content views 必须返回一个视图，即我们希望它们显示的视图。当我们想要一次在屏幕上显示多个视图时，我们需要告诉 SwiftUI 如何排列它们，这就是 堆栈（stacks）的来源。\n堆栈（Stacks） 相当于 UIKit 中的 UIStackView 。有三种形式:\n 水平（HStack） 垂直（VStack） 基于深度（ZStack）  当我们想放置子视图以便它们重叠时可以使用后者。\n1. VStack 让我们从一些简单的事情开始，先创建一个文本视图:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) }  运行效果: 有了一个文本视图，如果我们想在下面再写一个，我们不能只写:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) Text(\u0026quot;Hello M X\u0026quot;) }  这样的话，编译器会直接报错。 记住，我们只能返回一个视图，否则代码就不会工作。\n那么怎么办呢？我们需要将其放置在 VStack 中，以便将文本视图放置在彼此上方:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 您会注意到 VStack 放置在屏幕的中心，标签也居中，它们之间有一些自动空间。\n2. HStack 如果我们希望文本视图并排水平放置，请使用如下方式将 VStack 替换为 HStack:\nvar body: some View { HStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564020650,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564020650,"objectID":"25808207349efed761b6e8e414a439c6","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","publishdate":"2019-07-25T10:10:50+08:00","relpermalink":"/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","section":"post","summary":" ","tags":["View layout"],"title":"2.1_如何使用VStack和HStack创建stacks","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 我们可以使用相同的 background() 修饰符来设置背景图像，而不是设置背景颜色。\n1. 给文本视图设置图像背景 例如: 现在，我们要创建一个大字体的文本视图，然后在其后面放置一个 100x100 的图像:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Image(\u0026quot;example-image\u0026quot;) .resizable() .frame(width: 100, height: 100) ) } }  运行效果: 2. 给文本视图设置一个红色圆圈作为背景 在 SwiftUI 中，背景 View 并不一定是一个图像，实际上我们可以使用任何类型的视图作为背景。 例如: 现在将创建相同的文本视图，然后在其后面放置一个 200x200 的红色圆圈:\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) ) }  默认情况下，背景视图会自动占用尽可能多的空间以完全可见，但如果需要，可以使用 clipped() 修饰符将其剪裁为父视图的大小：\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) .clipped() ) }  运行效果: 明确地说，您可以使用任何视图作为背景，例如，如果需要，可以使用另一个文本视图。\n","date":1563954389,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954389,"objectID":"d77a54ad5e70c0e354963d33db9f8afa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","publishdate":"2019-07-24T15:46:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","section":"post","summary":" ","tags":["Text and image"],"title":"1.9_如何使用图像和其它视图作为背景","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 如果我们想在应用程序中使用简单地几何形状，我们可以直接创建它们，然后根据需要对它们进行着色和定位。\n1. 矩形 例如，如果我们想要一个 200x200 红色矩形，可以使用如下代码:\nvar body: some View { Rectangle() .fill(Color.red) .frame(width: 200, height: 200) }  运行效果: 2. 圆 同样，如果你想要一个 50x50 的蓝色圆圈，您可以使用如下代码:\nvar body: some View { Circle() .fill(Color.blue) .frame(width: 50, height: 50) }  运行效果: ","date":1563954361,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954361,"objectID":"6bb26cdc2adaf8cb830077b8110d51aa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","publishdate":"2019-07-24T15:46:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","section":"post","summary":" ","tags":["Text and image"],"title":"1.8_如何显示几何形状","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 为我们提供了各种渐变选项（gradient options），所有这些选项都可以以各种方式来使用。例如:\n1. 垂直线性渐变 我们使用从白色到黑色的线性渐变来渲染文本视图，如下所示:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 颜色被指定为一个数组，我们可以设置任意多我们想要的颜色 - 默认情况下，SwiftUI 将会平均分配这些颜色。所以，我们也可以这样从 白色 -\u0026gt; 红色 -\u0026gt; 黑色 来设置:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 2. 水平线性渐变 要实现一个水平渐变（a horizontal gradient）而不是一个垂直渐变（a vertical one），使用 .leading 和 .trailing 来作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .leading, endPoint: .trailing), cornerRadius: 0) }  运行效果: 3. 对角线线性渐变 要实现对角线渐变，可以使用 .topLeading 和 .bottomTrailing 作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .topLeading, endPoint: .bottomTrailing), cornerRadius: 0) }  运行效果: ","date":1563954329,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954329,"objectID":"b89862110d29df1cb2a98f4fee3a3c1b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","publishdate":"2019-07-24T15:45:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","section":"post","summary":" ","tags":["Text and image"],"title":"1.7_如何渲染渐变","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 的 Image 能够以不同的方式进行缩放，就像 UIImageView 的 content mode 一样。\n1.默认 默认情况下，图像视图会自动调整其内容的大小，这可能会使它们超出屏幕。\nImage(\u0026quot;ba_xian_tai\u0026quot;)  运行效果: 如果添加了 resizable() 修饰符，则图像将自动调整大小，以填充所有可用空间:\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable()  运行效果: 然而，这也可能导致图像的原始纵横比失真，因为它将在所有维度上被拉伸任意数量，以使其填充空间。\n2. .fill 和 .fit 如果要保持其纵横比，应使用 .fill 或 .fit添加一个aspectRatio()修饰符，如下所示：\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable() .aspectRatio(contentMode: .fill)  运行效果: 注意: 在当前的测试版中，有一个bug，.fit 内容模式仍然会导致图像被拉伸。\n","date":1563954307,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954307,"objectID":"cf6ffdbb1c994faad0b4746884cab952","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","publishdate":"2019-07-24T15:45:07+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","section":"post","summary":" ","tags":["Text and image"],"title":"1.6_如何调整图像视图的填充模式","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 使用图像视图 Image 可以在 SwiftUI 布局中渲染图像（images）。我们可以从 Bundle、System icons、UIImage 等中加载图像，但这三个将是最常见的。\n1. 从 Bundle 加载 要从 Bundle 中加载图像并将其显示在图像视图中，只需使用以下代码:\nvar body: some View { Image(\u0026quot;example-image\u0026quot;) }  运行效果: 2. 从 System icons 加载 要从苹果旧金山符号集(Apple’s San Francisco Symbol set)中加载图标，请使用 Image(systemName: ) 初始化器，传入图标字符串进行加载，如下所示:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;)  运行效果: 3. 从 UIImage 加载 最后，可以从现有的 UIImage 创建一个图像视图。因为这需要更多的代码，所以需要显式地使用 return 关键字。\nguard let image = UIImage(named: \u0026quot;example-image\u0026quot;) else { fatalError(\u0026quot;Unable to load image\u0026quot;) } return Image(uiImage: image)  运行效果: 4. foregroundColor 如果你使用的是 系统图标集，则返回的图像是 可缩放 和 可着色 的，这意味着你可以使用 foregroundColor() 修改器对图像着色。\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .foregroundColor(.red)  运行效果: 5. 动态文本样式 这意味着你可以通过匹配任何 Dynamic Type 文本样式，来要求 SwiftUI 放大图像:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .font(.largeTitle)  运行效果: ","date":1563954255,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954255,"objectID":"bcd80c540133b4c4f850d3403d4e3377","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","publishdate":"2019-07-24T15:44:15+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","section":"post","summary":" ","tags":["Text and image"],"title":"1.5_如何使用图像视图绘制图像","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":"SwiftUI 的文本视图有一个可选的 formatter 参数，可以让我们用来自定义数据在标签（label）内的显示方式。这一点很重要，因为在我们的程序中发生某些事情时，通常会为我们更新值，因此通过附加 formatter， SwiftUI 可以确保我们的数据以我们期望的方式来正确显示。\n例如，这定义了一个日期格式（date formatter）化程序，并使用它来确保 任务日期 以人类可读的形式显示:\nimport SwiftUI struct ContentView : View { static let taskDateFormatter: DateFormatter = { let formatter = DateFormatter() formatter.dateStyle = .long return formatter }() var dueDate = Date() var body: some View { Text(\u0026quot;Task due date: \\(dueDate, formatter: Self.taskDateFormatter)\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif  运行效果: ","date":1563954209,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954209,"objectID":"c122de324e0c11ab95cb0738749a23d0","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","publishdate":"2019-07-24T15:43:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","section":"post","summary":" ","tags":["Text and image"],"title":"1.4_如何格式化文本视图中的文本","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 文本视图不仅在外观方面给了我们一个可预见的广泛控制，而且还设计成与苹果的核心技术（如 Dynamic Type）无缝配合。\n1. 字体 默认情况下，文本视图有一个 Body 动态类型样式，但是我们可以通过以下方式调用 .font()，从其它 sizes 和 weights 进行选择:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle)  运行效果: 我们现在在文本视图下面使用了两个修饰符，这没关系 - 你可以将它们堆叠起来，并且它们都会生效。\n2. 文本对齐 特别是，现在我们有多行文本，我们需要调整文本的对齐方式，使其居中，如下所示:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .multilineTextAlignment(.center)  运行效果: 3. 字体颜色 我们可以通过 .foregroundColor() 修饰符来设置文本颜色，如下所示:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red)  运行效果: 4. 背景 我们可以使用 .background() 来设置背景颜色，但是它不仅仅可以用来设置背景颜色，也可以设置背景视图。无论如何，为了给我们的文本视图设置一个黄色背景，代码如下:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red) .background(Color.yellow)  运行效果: 5. 行间距 我们可以设置多行文本的行间距，行间距默认值为0，表示没有额外的行间距，但是我们可以通过以下方式在行与行之间指定一个值来添加额外的行间距。\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .lineSpacing(50)  运行效果: ","date":1563954148,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954148,"objectID":"8be44a51185d5c70ca4c4bc7d2fb462d","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","publishdate":"2019-07-24T15:42:28+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","section":"post","summary":" ","tags":["Text and image"],"title":"1.3_如何使用字体颜色行距等设置文本视图的样式","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 1. 简介 Text 主要用于在屏幕上显示静态文本，相当于 UIKit 中的 UILabel。\n2. 基本用法 最基本的用法如下:\nText(\u0026quot;Hello world\u0026quot;)  在内容视图的预览窗口中，您可能会看到 Automatic preview updating paused， 继续按 Resume 以让 Swift 开始构建代码并向您展示其外观的实时预览。 效果预览: ![]()\n2. 设置显示行数 默认情况下，Text 只显示一行 - 如果空间不足，字符将被剪切并替换为 ...。因此如果我们要显示的文本很长，就会看到这种情况发生。如果要改变这种行为 - 比如你希望 Text 可以显示多行文本，那么可以这样做，使其具有特定的行数:\nText(\u0026quot;Hello world\u0026quot;) .lineLimit(3)   提示: 请注意 lineLimit(3) 位于 Text(\u0026quot;Hello World\u0026quot;) 下方靠右侧的方式。这不是必需的，但它确实使您的代码更易于阅读。\n 或者，可以将 nil 指定给 lineLimit() 方法，该方法允许它根据需要运行在任意多行:\nText(\u0026quot;Hello World\u0026quot;) .lineLimit(nil)   注意: 这里设置 lineLimit(0) 不能实现多行显示，这一点跟 UIKit 中是不一样的。\n 3. 文本截断 我们也可以调整 SwiftUI 截断文本的方式，而不是调整行数。默认情况下，从末尾删除文本并显示省略号，但也可以将省略号放在中间或开头，具体取决于字符串各个部分的重要程度。\n例如: 以下代码会在中间截断文本\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones.\u0026quot;) .truncationMode(.middle)  不管我们如何截断文本，我们将看到文本视图始终位于主视图（main view）的中心。这是 SwiftUI 的默认行为 \u0026ndash; 除非我们明确告诉 SwiftUI 将视图定位到其他位置，否则 SwiftUI 会将视图定位到相对于屏幕中心的位置。\n","date":1563946501,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563946501,"objectID":"89351963c06fe6b05cb7331d20f36a1f","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-text-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","publishdate":"2019-07-24T13:35:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-text-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","section":"post","summary":" ","tags":["Text and image"],"title":"1.2_如何使用 Text 创建静态标签","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":"  小贴士: 你可能认为本章是完全可以略读的，但除非你是一个 Swift 天才，否则你应该读到最后再确定。\n 1. 简介 如图，自 Xcode 11 之后，基本的 Single View App 模板为我们提供以下内容:\n AppDelegate.swift  它负责监视外部事件。例如: 如果另一个应用程序试图向我们发送要一个要打开的文件。  SceneDelegate.swift  它负责管理应用程序的显示方式。例如: 让多个实例同时运行，或者当一个实例移动到后台时采取操作/措施。  ContentView.swift  它是我们的初始用户界面。如果这是一个 UIKit 项目，它就相当于是 Xcode 提供给我们的 ViewController 类。  Assets.xcassets  它是项目的资产目录。存储着我们项目中使用的所有图像和颜色。  LaunchScreen.storyboard  它是应用加载时显示的屏幕。  Info.plist  它是一个属性列表文件，用于存储应用程序的系统级设置。例如: 应该在 iOS 主屏幕的图标下面显示什么名称。  Preview content\n 它是一个名为 Preview content 的组，其中包含另一个名为 Preview Assests 的资产目录。   就是这样 - 只有少量的代码和资源，这意味着我们可以在此基础上进行构建。\n2. 查看 SceneDelegate 我们真正关心的是 ContentView.swift， 事实上，这是唯一重要的部分。这是我们应用程序的主要功能，在这里我们可以立即开始尝试各种 SwiftUI 代码。\n是什么让 ContentView.swift 显示在屏幕上？\n上面提到: SceneDelegate.swift 负责管理应用程序的显示方式。那么，我们打开 SceneDelegate.swift，就会看到下面的代码:\nlet window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: ContentView()) self.window = window window.makeKeyAndVisible()  这段代码创建了一个新的 ContentView 实例（这是我们即将看到的主要功能），并将其放在 window 中，以便在屏幕上显示。通过显示 ContentView 的第一个实例，可以有效地引导我们的应用程序，并从那里结束 - 你想做什么？\n3. 查看 ContentView 打开 ContentView.swift ，让我们看看实际的 SwiftUI 代码。可以看到这样的代码:\nimport SwiftUI struct ContentView : View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif   首先，请注意，ContentView 是一个结构体。熟悉 UIKit 的开发人员知道 - 我们从用户界面的所有值类型的不可变性和简单性中获益巨大！\n 其次，ContentView 遵守 View 协议。我们想在 SwiftUI 中显示的所有内容都需要遵守 View 协议，这实际上只意味着一件事: 我们需要一个名为 body 的属性来返回某种 View。\n 第三，body 的返回类型是 some View。some 关键字是在 Swift 5.1 中新增的，是一个名为 不透明返回类型（opaque return types） 功能的一部分，在这种情况下，它的意思是 将返回某种视图，但 SwiftUI 不需要知道（或关心）什么。\n   重要说明: 返回 some View 意味着 body 属性将返回遵守 View 协议的内容。我们不能返回很多东西或忘记返回任何东西 \u0026ndash; Swift 编译器将拒绝构建代码。要清楚，我们的视图正文必须返回一个子视图。\n  第四，body 属性中有 Text(\u0026quot;hello world\u0026quot;)，它创建了文本内容为 \u0026ldquo;hello world\u0026rdquo; 的标签。\n 最后，在 ContentView 下面的是一个类似但不同的 struct，称为 ContentView_Previews。它不遵守 View 协议，因为它专门用于在 Xcode 中显示 视图预览（Preview），而不是在真实 app 中显示在屏幕上。这就是为什么你会看到它在 #if DEBUG 和 #endif 之间 - 当我们的应用程序在调试环境中运行时，这段代码只构建在 成品（finished product）中，因为它在生产应用程序（Production app）中没有意义。\n  ","date":1563868318,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563868318,"objectID":"9d1b9da570681cca6df9924ec098df0b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","publishdate":"2019-07-23T15:51:58+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","section":"post","summary":"The introduction of SwiftUI project template","tags":["Text and image"],"title":"1.1_工程模板介绍","type":"post"}]