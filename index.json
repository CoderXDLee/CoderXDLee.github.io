[{"authors":["admin"],"categories":null,"content":" Avoiding Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","date":1564025985,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1564025985,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://coderxdlee.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":" Avoiding Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","tags":null,"title":"M X","type":"authors"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 允许我们使用 padding() 修饰符在视图周围设置单独的填充。\n1. 系统默认 padding 如果在没有参数的情况下使用此选项，您将在所有边上获得系统默认填充，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里默认设置了视图四周的填充。\n2. 只设置一侧系统默认 padding 我们也可以自定义要 apply 的 padding 和位置。因此，我们只希望将系统填充应用于一侧:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里只设置了底部填充，以上面的例子不同。\n3. 用具体数值来设置 padding 我们可能希望控制对所有边应用了多少填充:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  4. 在视图一侧添加特定数量的填充 我们也可以将这两者结合起来，在视图的一侧添加特定数量的填充：\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom, 100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564025985,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564025985,"objectID":"e4177bc07a2849e3ab458ab3bb0941b0","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","publishdate":"2019-07-25T11:39:45+08:00","relpermalink":"/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.3_如何使用padding控制单个视图周围的间距","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. spacing 我们可以通过在 SwiftUI stacks 的构造方法中填一个值来设置间距，如下所示:\nvar body: some View { VStack(spacing: 50) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 2. Divider 我们可以在项目之间创建分隔符，以便 SwiftUI 在 stack 中的每个项目之间进行小的视觉区分，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Divider() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 3. alignment 默认情况下，stacks 中的项目居中对齐。\n 在 HStack 中: 项目在中间垂直对齐，因此如果有两个不同高度的文本视图，它们都将与垂直中心对齐。 在 VStack 中: 项目在中间水平对齐，因此如果有两个长度不同的文本视图，它们都将与水平中心对齐。  要调整这种情况，请在创建 stack 时按以下方式传递一个 alignment 参数:\nvar body: some View { VStack(alignment: .leading) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使 Hello SwiftUI 和 Hello M X 左对齐，但它们最终将位于屏幕的中间，因为 stack 只占用所需的空间。\n4.同时设置 alignment 和 spacing 我们可以同时使用 alignment 和 spacing ，如下所示:\nvar body: some View { VStack(alignment: .leading, spacing: 20) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使两个文本视图水平对齐到 leading（对于从左到右的语言是左对齐），并在它们之间放置20个点的垂直间距。\n","date":1564023292,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564023292,"objectID":"294ef00070d5dc7a12b85b39352a4f69","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","publishdate":"2019-07-25T10:54:52+08:00","relpermalink":"/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.2_如何通过alignment和spacing自定义stack布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 的内容视图 content views 必须返回一个视图，即我们希望它们显示的视图。当我们想要一次在屏幕上显示多个视图时，我们需要告诉 SwiftUI 如何排列它们，这就是 堆栈（stacks）的来源。\n堆栈（Stacks） 相当于 UIKit 中的 UIStackView 。有三种形式:\n 水平（HStack） 垂直（VStack） 基于深度（ZStack）  当我们想放置子视图以便它们重叠时可以使用后者。\n1. VStack 让我们从一些简单的事情开始，先创建一个文本视图:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) }  运行效果: 有了一个文本视图，如果我们想在下面再写一个，我们不能只写:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) Text(\u0026quot;Hello M X\u0026quot;) }  这样的话，编译器会直接报错。 记住，我们只能返回一个视图，否则代码就不会工作。\n那么怎么办呢？我们需要将其放置在 VStack 中，以便将文本视图放置在彼此上方:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 您会注意到 VStack 放置在屏幕的中心，标签也居中，它们之间有一些自动空间。\n2. HStack 如果我们希望文本视图并排水平放置，请使用如下方式将 VStack 替换为 HStack:\nvar body: some View { HStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564020650,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564020650,"objectID":"25808207349efed761b6e8e414a439c6","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","publishdate":"2019-07-25T10:10:50+08:00","relpermalink":"/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.1_如何使用VStack和HStack创建stacks","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 我们可以使用相同的 background() 修饰符来设置背景图像，而不是设置背景颜色。\n1. 给文本视图设置图像背景 例如: 现在，我们要创建一个大字体的文本视图，然后在其后面放置一个 100x100 的图像:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Image(\u0026quot;example-image\u0026quot;) .resizable() .frame(width: 100, height: 100) ) } }  运行效果: 2. 给文本视图设置一个红色圆圈作为背景 在 SwiftUI 中，背景 View 并不一定是一个图像，实际上我们可以使用任何类型的视图作为背景。 例如: 现在将创建相同的文本视图，然后在其后面放置一个 200x200 的红色圆圈:\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) ) }  默认情况下，背景视图会自动占用尽可能多的空间以完全可见，但如果需要，可以使用 clipped() 修饰符将其剪裁为父视图的大小：\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) .clipped() ) }  运行效果: 明确地说，您可以使用任何视图作为背景，例如，如果需要，可以使用另一个文本视图。\n","date":1563954389,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954389,"objectID":"d77a54ad5e70c0e354963d33db9f8afa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","publishdate":"2019-07-24T15:46:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.9_如何使用图像和其它视图作为背景","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 如果我们想在应用程序中使用简单地几何形状，我们可以直接创建它们，然后根据需要对它们进行着色和定位。\n1. 矩形 例如，如果我们想要一个 200x200 红色矩形，可以使用如下代码:\nvar body: some View { Rectangle() .fill(Color.red) .frame(width: 200, height: 200) }  运行效果: 2. 圆 同样，如果你想要一个 50x50 的蓝色圆圈，您可以使用如下代码:\nvar body: some View { Circle() .fill(Color.blue) .frame(width: 50, height: 50) }  运行效果: ","date":1563954361,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954361,"objectID":"6bb26cdc2adaf8cb830077b8110d51aa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","publishdate":"2019-07-24T15:46:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.8_如何显示几何形状","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 为我们提供了各种渐变选项（gradient options），所有这些选项都可以以各种方式来使用。例如:\n1. 垂直线性渐变 我们使用从白色到黑色的线性渐变来渲染文本视图，如下所示:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 颜色被指定为一个数组，我们可以设置任意多我们想要的颜色 - 默认情况下，SwiftUI 将会平均分配这些颜色。所以，我们也可以这样从 白色 -\u0026gt; 红色 -\u0026gt; 黑色 来设置:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 2. 水平线性渐变 要实现一个水平渐变（a horizontal gradient）而不是一个垂直渐变（a vertical one），使用 .leading 和 .trailing 来作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .leading, endPoint: .trailing), cornerRadius: 0) }  运行效果: 3. 对角线线性渐变 要实现对角线渐变，可以使用 .topLeading 和 .bottomTrailing 作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .topLeading, endPoint: .bottomTrailing), cornerRadius: 0) }  运行效果: ","date":1563954329,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954329,"objectID":"b89862110d29df1cb2a98f4fee3a3c1b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","publishdate":"2019-07-24T15:45:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.7_如何渲染渐变","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 的 Image 能够以不同的方式进行缩放，就像 UIImageView 的 content mode 一样。\n1.默认 默认情况下，图像视图会自动调整其内容的大小，这可能会使它们超出屏幕。\nImage(\u0026quot;ba_xian_tai\u0026quot;)  运行效果: 如果添加了 resizable() 修饰符，则图像将自动调整大小，以填充所有可用空间:\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable()  运行效果: 然而，这也可能导致图像的原始纵横比失真，因为它将在所有维度上被拉伸任意数量，以使其填充空间。\n2. .fill 和 .fit 如果要保持其纵横比，应使用 .fill 或 .fit添加一个aspectRatio()修饰符，如下所示：\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable() .aspectRatio(contentMode: .fill)  运行效果: 注意: 在当前的测试版中，有一个bug，.fit 内容模式仍然会导致图像被拉伸。\n","date":1563954307,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954307,"objectID":"cf6ffdbb1c994faad0b4746884cab952","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","publishdate":"2019-07-24T15:45:07+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.6_如何调整图像视图的填充模式","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 使用图像视图 Image 可以在 SwiftUI 布局中渲染图像（images）。我们可以从 Bundle、System icons、UIImage 等中加载图像，但这三个将是最常见的。\n1. 从 Bundle 加载 要从 Bundle 中加载图像并将其显示在图像视图中，只需使用以下代码:\nvar body: some View { Image(\u0026quot;example-image\u0026quot;) }  运行效果: 2. 从 System icons 加载 要从苹果旧金山符号集(Apple’s San Francisco Symbol set)中加载图标，请使用 Image(systemName: ) 初始化器，传入图标字符串进行加载，如下所示:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;)  运行效果: 3. 从 UIImage 加载 最后，可以从现有的 UIImage 创建一个图像视图。因为这需要更多的代码，所以需要显式地使用 return 关键字。\nguard let image = UIImage(named: \u0026quot;example-image\u0026quot;) else { fatalError(\u0026quot;Unable to load image\u0026quot;) } return Image(uiImage: image)  运行效果: 4. foregroundColor 如果你使用的是 系统图标集，则返回的图像是 可缩放 和 可着色 的，这意味着你可以使用 foregroundColor() 修改器对图像着色。\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .foregroundColor(.red)  运行效果: 5. 动态文本样式 这意味着你可以通过匹配任何 Dynamic Type 文本样式，来要求 SwiftUI 放大图像:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .font(.largeTitle)  运行效果: ","date":1563954255,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954255,"objectID":"bcd80c540133b4c4f850d3403d4e3377","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","publishdate":"2019-07-24T15:44:15+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.5_如何使用图像视图绘制图像","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的文本视图有一个可选的 formatter 参数，可以让我们用来自定义数据在标签（label）内的显示方式。这一点很重要，因为在我们的程序中发生某些事情时，通常会为我们更新值，因此通过附加 formatter， SwiftUI 可以确保我们的数据以我们期望的方式来正确显示。\n例如，这定义了一个日期格式（date formatter）化程序，并使用它来确保 任务日期 以人类可读的形式显示:\nimport SwiftUI struct ContentView : View { static let taskDateFormatter: DateFormatter = { let formatter = DateFormatter() formatter.dateStyle = .long return formatter }() var dueDate = Date() var body: some View { Text(\u0026quot;Task due date: \\(dueDate, formatter: Self.taskDateFormatter)\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif  运行效果: ","date":1563954209,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954209,"objectID":"c122de324e0c11ab95cb0738749a23d0","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","publishdate":"2019-07-24T15:43:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.4_如何格式化文本视图中的文本","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 文本视图不仅在外观方面给了我们一个可预见的广泛控制，而且还设计成与苹果的核心技术（如 Dynamic Type）无缝配合。\n1. 字体 默认情况下，文本视图有一个 Body 动态类型样式，但是我们可以通过以下方式调用 .font()，从其它 sizes 和 weights 进行选择:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle)  运行效果: 我们现在在文本视图下面使用了两个修饰符，这没关系 - 你可以将它们堆叠起来，并且它们都会生效。\n2. 文本对齐 特别是，现在我们有多行文本，我们需要调整文本的对齐方式，使其居中，如下所示:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .multilineTextAlignment(.center)  运行效果: 3. 字体颜色 我们可以通过 .foregroundColor() 修饰符来设置文本颜色，如下所示:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red)  运行效果: 4. 背景 我们可以使用 .background() 来设置背景颜色，但是它不仅仅可以用来设置背景颜色，也可以设置背景视图。无论如何，为了给我们的文本视图设置一个黄色背景，代码如下:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red) .background(Color.yellow)  运行效果: 5. 行间距 我们可以设置多行文本的行间距，行间距默认值为0，表示没有额外的行间距，但是我们可以通过以下方式在行与行之间指定一个值来添加额外的行间距。\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .lineSpacing(50)  运行效果: ","date":1563954148,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954148,"objectID":"8be44a51185d5c70ca4c4bc7d2fb462d","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","publishdate":"2019-07-24T15:42:28+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.3_如何使用字体颜色行距等设置文本视图的样式","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 基本用法 文本视图 Text 主要用于在屏幕上显示静态文本，相当于 UIKit 中的 UILabel。最基本的用法如下:\nText(\u0026quot;Hello world\u0026quot;)  在内容视图的预览窗口中，您可能会看到 Automatic preview updating paused， 继续按 Resume 以让 Swift 开始构建代码并向您展示其外观的实时预览。\n2. 设置显示行数 默认情况下，Text 只显示一行 - 如果空间不足，字符将被剪切并替换为 ...。因此如果我们要显示的文本很长，就会看到这种情况发生。如果要改变这种行为 - 比如你希望 Text 可以显示多行文本，那么可以这样做，使其具有特定的行数:\nText(\u0026quot;Hello world\u0026quot;) .lineLimit(3)   提示: 请注意 lineLimit(3) 位于 Text(\u0026quot;Hello World\u0026quot;) 下方靠右侧的方式。这不是必需的，但它确实使您的代码更易于阅读。\n 或者，可以将 nil 指定给 lineLimit() 方法，该方法允许它根据需要运行在任意多行:\nText(\u0026quot;Hello World\u0026quot;) .lineLimit(nil)   注意: 这里设置 lineLimit(0) 不能实现多行显示，这一点跟 UIKit 中是不一样的。\n 3. 文本截断 我们也可以调整 SwiftUI 截断文本的方式，而不是调整行数。默认情况下，从末尾删除文本并显示省略号，但也可以将省略号放在中间或开头，具体取决于字符串各个部分的重要程度。\n例如: 以下代码会在中间截断文本\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones.\u0026quot;) .truncationMode(.middle)  不管我们如何截断文本，我们将看到文本视图始终位于主视图（main view）的中心。这是 SwiftUI 的默认行为 \u0026ndash; 除非我们明确告诉 SwiftUI 将视图定位到其他位置，否则 SwiftUI 会将视图定位到相对于屏幕中心的位置。\n","date":1563946501,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563946501,"objectID":"c8de0192120507accbd6cb1c301d2f14","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","publishdate":"2019-07-24T13:35:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.2 如何使用文本视图创建静态标签","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 提示: 您可能认为本章完全可以跳过，但除非你是一个 Swift 天才，否则你应该读到最后再确定。\n 如图，自 Xcode 11 之后，基本的 Single View App 模板为我们提供以下内容:\n AppDelegate.swift  这个文件负责监视外部事件。例如，如果另一个应用程序试图向您发送要打开的文件。  SceneDelegate.swift  这个文件负责管理应用程序的显示方式。例如让多个实例同时运行，或者当一个实例移动到后台时采取操作。  ContentView.swift  这个文件是我们的初始用户界面。如果这是一个 UIKit 项目，这个文件相当于是 Xcode 提供给我们的 ViewController 类。  Assets.xcassets  这个文件是项目的资产目录。存储着我们项目中使用的所有图像和颜色。  LaunchScreen.storyboard  这是应用加载时显示的屏幕。  Info.plist  这是一个属性列表文件，在本例中，它用于存储应用程序的系统级设置。例如，应该在 iOS 主屏幕的图标下面显示什么名称。  Preview content\n 一个名为 Preview content 的组，其中包含另一个名为 Preview Assests 的资产目录。   就是这样 - 这是一个令人愉快的少量代码和资源，这意味着我们可以在此基础上进行构建。\n我们真正关心的是 ContentView.swift， 事实上，这是唯一重要的部分。这是我们应用程序的主要功能，在这里我们可以立即开始尝试各种 SwiftUI 代码。\n首先，是什么让 ContentView.swift 显示在屏幕上？\n好吧，如果你还记得我说过 SceneDelegate.swift 负责管理应用程序的显示方式。那么，继续打开 SceneDelegate.swift，您会看到下面的代码:\nlet window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: ContentView()) self.window = window window.makeKeyAndVisible()  这段代码创建了一个新的 ContentView 实例（这是我们即将看到的主要功能），并将其放在 window 中，以便在屏幕上显示。它通过显示 ContentView 的第一个实例，可以有效地引导我们的应用程序，并从那里结束 - 你想做什么？\n打开 ContentView.swift ，让我们看看实际的 SwiftUI 代码。您应该看到这样的代码:\nimport SwiftUI struct ContentView : View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif  这不是很多代码，但它确实包含了大量代码。\n首先，请注意，ContentView 是一个结构体（struct）。熟悉 UIKit 的开发人员知道 - 我们从用户界面的所有值类型的不可变性和简单性中获益巨大！不熟悉 UIKit 的人\u0026hellip; 嗯，只是点头微笑 - 你从来不知道我们曾经的痛苦。\n其次，ContentView 符合 View 协议。你想在 SwiftUI 中显示的所有内容都需要符合 View，这实际上只意味着一件事: 你需要一个名为 body 的属性来返回某种 View。\n第三，body 的返回类型是 some View。some 关键字是在 Swift 5.1 中新增的，是一个名为 不透明返回类型（opaque return types） 的功能的一部分，在这种情况下，它的意思是 将返回某种视图，但 SwiftUI 不需要知道（或关心）什么。\n重要说明: 返回 some View 意味着 body 属性将返回符合 View 协议的内容。你不能返回很多东西或忘记返回任何东西 \u0026ndash; Swift 编译器将拒绝构建你的代码。要清楚，您的视图正文必须返回一个子视图。\n第四，body属性中有 Text(\u0026quot;hello world\u0026quot;)，它创建了文本内容为 “hello world”的标签。\n最后，在 ContentView 下面的是一个类似但不同的 struct，称为 ContentView_Previews。它不符合 View 协议，因为它专门用于在 Xcode 中显示 视图预览（Preview），而不是在真实 app 中显示在屏幕上。这就是为什么你会看到它在 #if DEBUG 和 #endif 之间 - 当我们的应用程序在调试环境中运行时，这段代码只构建在 *成品（finished product）*中，因为它在生产应用程序（Production app）中没有意义。\n我们很快就会更详细地看一下这些组件（components），但首先让我们看一下 Text 组件。\n","date":1563868318,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563868318,"objectID":"9d1b9da570681cca6df9924ec098df0b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","publishdate":"2019-07-23T15:51:58+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","section":"post","summary":"The introduction of SwiftUI project template","tags":["SwiftUI"],"title":"1.1 工程模板介绍","type":"post"}]