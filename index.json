[{"authors":["admin"],"categories":null,"content":" Revere Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","date":1564729449,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1564729449,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://coderxdlee.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":" Revere Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","tags":null,"title":"M X","type":"authors"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 允许我们通过使用 disabled() 修饰符来禁用表单的任何部分甚至整个表单。这需要一个布尔值来定义是否应禁止使用该元素。表单元素的样式会自动更新以反映其状态-例如，buttons 和 toggles 变为灰色。\n例如，这将创建一个包含两个 sections 的表单：一个section 包含 Toggle ，另一个部分包含仅在切换打开时才启用的 Button：\nstruct ContentView : View { @State var agreedToTerms = false var body: some View { NavigationView { Form { Section { Toggle(isOn: $agreedToTerms) { Text(\u0026quot;Agree to terms and conditions\u0026quot;) } } Section { Button(action: { // show next screen here }) { Text(\u0026quot;Continue\u0026quot;) } .disabled(!agreedToTerms) } } .navigationBarTitle(Text(\u0026quot;Welcome\u0026quot;)) } } }  运行效果: 如您所见，只需将禁用（!agreeToTerms）添加到修改器列表中即可禁用该按钮。\n与许多其他SwiftIUI修饰符一样，您可以提升 disabled()，以便它在 Section 上运行，甚至在整个表单上运行，这取决于您想要的行为——例如，只需移动 disabled(!agreedToTerms) 使它位于该 section 之后:\nSection { Button(action: { // show next screen here }) { Text(\u0026quot;Continue\u0026quot;) } } .disabled(!agreedToTerms)  ","date":1564729449,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564729449,"objectID":"6f38748a5514eb32502747bb8d0c90fc","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/","publishdate":"2019-08-02T15:04:09+08:00","relpermalink":"/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/","section":"post","summary":" ","tags":["Forms"],"title":"6.5_启用和禁用表单中的元素","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"在表单内部，SwiftUI 的 选择器视图 具有特殊的行为，可根据我们使用它们的平台自动进行调整。在 iOS 上，这种行为尤其令人印象深刻，因为选择器可以折叠到一个列表行，该行导航到一个新的可能选项列表中——这是处理许多选项的一种非常自然的方式。\n例如，这将创建一个带有选择器的表单，并为其项使用数组：\nstruct ContentView : View { var strengths = [\u0026quot;Mild\u0026quot;, \u0026quot;Medium\u0026quot;, \u0026quot;Mature\u0026quot;] @State var selectedStrength = 0 var body: some View { NavigationView { Form { Section { Picker(selection: $selectedStrength, label: Text(\u0026quot;Text strength\u0026quot;)) { ForEach(0..\u0026lt;strengths.count) { Text(self.strengths[$0]).tag($0) } } } } .navigationBarTitle(Text(\u0026quot;Select your cheese\u0026quot;)) } } }  运行效果: 表单中的选择器 在 iOS 上，这将显示为一个单独的列表行，您可以点击该行进入一个新屏幕，显示所有可能的选项—— Mild、Medium 和 Mature。您当前的选择旁边将有一个复选标记，当您选择一个新选项时，它将返回上一个屏幕，并显示当前的选项。\n如果要禁用此行为，可以使用.PickerStyle(.wheel)修饰符强制选取器采用其常规样式，如下所示：\nPicker(selection: $selectedStrength, label: Text(\u0026quot;Text strength\u0026quot;)) { ForEach(0..\u0026lt;strengths.count) { Text(self.strengths[$0]).tag($0) } } .pickerStyle(WheelPickerStyle())  运行效果: ","date":1564724999,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564724999,"objectID":"5d9a1e55ef75ff2b84b96b0fddee6775","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","publishdate":"2019-08-02T13:49:59+08:00","relpermalink":"/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","summary":" ","tags":["Forms"],"title":"6.4_表单中选择器的使用","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的表单通常在分成多个部分时效果最好，就像常规的内容列表一样。 如何将它们分组取决于你，但是通常情况下，按照它们的目的进行分组效果最好 - 如果它是一个订单页面你可以将项目放在一个组中，在另一个组中进行定制，并在第三个组中进行交付。 很有帮助的是，表单 sections 与列表 sections 相同，这意味着您可以在两个地方重复使用相同的代码。因此，您可以向 sections 中添加 header 和/或 footer ，或者两者都不使用，只需在 sections 之间获得一些屏幕上的间距。\n例如，这将创建一个包含两个 section 的表单，第一个 section 带有 segmented control 和 toggle ，第二个 section 带有保存按钮:\nstruct ContentView : View { @State var enableLogging = false @State var selectedColor = 0 @State var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Blue\u0026quot;] var body: some View { Form { Section(footer: Text(\u0026quot;Note: Enabling logging may slow down the app\u0026quot;)) { SegmentedControl(selection: $selectedColor) { ForEach(0..\u0026lt;colors.count) { Text(self.colors[$0]).tag($0) } } Toggle(isOn: $enableLogging) { Text(\u0026quot;Enable logging\u0026quot;) } } Section { Button(action: { }) { Text(\u0026quot;Save changes\u0026quot;) } } } .navigationBarTitle(Text(\u0026quot;Settings\u0026quot;)) } }  运行效果: ","date":1564718476,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564718476,"objectID":"dc78807f5ff8179160f7b5f9ba32b7de","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/","publishdate":"2019-08-02T12:01:16+08:00","relpermalink":"/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/","section":"post","summary":" ","tags":["Forms"],"title":"6.3_将表单分成几个sections","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 中的 表单(forms) 可以当作容器使用，就像 HStack 和 VStack 一样，这意味着我们可以根据需要在其中添加其它视图。 但是，表单会自动调整某些控件的行为和样式，以便它们更好地适应表单环境。 例如，我们将创建一个带有 _toggle_、segmentedControl 和 button 的表单:\nstruct ContentView : View { @State var enableLogging = false @State var selectedColor = 0 @State var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Blue\u0026quot;] var body: some View { NavigationView { Form { Picker(selection: $selectedColor, label: Text(\u0026quot;\u0026quot;)) { ForEach(0..\u0026lt;colors.count) { Text(self.colors[$0]).tag($0) } } .pickerStyle(SegmentedPickerStyle()) Toggle(isOn: $enableLogging) { Text(\u0026quot;Enable logging!\u0026quot;) } Button(action: { // activate theme! }) { Text(\u0026quot;Save changes\u0026quot;) } } .navigationBarTitle(Text(\u0026quot;Settings\u0026quot;)) } } }  运行效果: 当代码运行时，我们将看到两件对表单行为至关重要的事情:\n 在 iOS 上，表单自动采用 分组列表 的样式，因此用户可以看到滚动选项。 按钮已经调整了自己，看起来像一个可操作的列表行—— 左对齐，蓝色。   注意: 我们可以根据需要在表单中包含尽可能多的行，但如果需要超过10，请记住使用组(groups)。\n ","date":1564677427,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564677427,"objectID":"f5fd8348b8576268223baf2fd2709fa5","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/","publishdate":"2019-08-02T00:37:07+08:00","relpermalink":"/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/","section":"post","summary":" ","tags":["Forms"],"title":"6.2_基本表单设计","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 简介  SwiftUI 专注于声明性用户界面，因此它为我们提供了一种构建 表单(Form) 的绝佳机制也就不足为奇了。 表单(Form) 指的是用于收集信息的用户输入控件的集合，例如 订单表单 或 设置界面 。 更好的是，在表单中，SwiftUI 的几个部分会自适应放置——它们的外观和行为会发生变化，因此它们与其它输入控件组一起工作得更好。  如果你认为这很聪明，你会喜欢这个: 实际上 SwiftUI 会动态地调整布局，以便它可以根据代码运行的平台自动为我们生成全新的页面 - 它完全将控件的目的与它们的视觉效果分离开来。 这意味着我们描述了我们想要的东西，SwiftUI 找出了在当前平台上实现这一目标的惯用方法。\n 提示: Form 和 VStack 一样是常规容器，因此我们可以根据需要在这两者之间自由切换。\n ","date":1564676492,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564676492,"objectID":"3398a50e9915101695fcaca8082c3d4e","permalink":"https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","publishdate":"2019-08-02T00:21:32+08:00","relpermalink":"/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","section":"post","summary":" ","tags":["Forms"],"title":"6.1_表单的使用介绍","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果创建一个动态列表并在每行中放置多个内容，会发生什么情况？SwiftUI 的解决方案简单、灵活，并且在默认情况下为我们提供了良好的行为: 它创建了一个隐式的 HStack 来保存您的项目，因此它们会自动进行水平布局。 例如，如果我们想要创建一行，其中左侧有一张小图片，剩余的空间分配给一个文本字段，那么我们将从一个结构开始，这样保存数据:\nstruct User: Identifiable { var id = UUID() var username = \u0026quot;Anonymous\u0026quot; }  我已经给出了这两个默认值，以便简化示例。 完成后，我们可以创建一个包含三个用户的数组，并在动态列表中显示它们，如下所示：\nstruct ContentView : View { let users = [User(), User(), User()] var body: some View { List(users) { user in Image(\u0026quot;paul-hudson\u0026quot;) .resizable() .frame(width: 40, height: 40) Text(user.username) } } }  运行效果: ","date":1564673006,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564673006,"objectID":"0bcec38ca5651ba8151dcbd9c3d86a70","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/","publishdate":"2019-08-01T23:23:26+08:00","relpermalink":"/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/","section":"post","summary":" ","tags":["List"],"title":"5.9_如何使用隐式叠加","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 List 支持 grouped 或 plain 样式，就像 UITableView 一样。默认为 plain 样式，但如果要改为 grouped 样式，则应使用 列表 的 .listStyle(.grouped) 修饰符。 例如，这里定义了一个示例行，并将其放置在分组列表中：\nstruct ExampleRow : View { var body: some View { Text(\u0026quot;Example Row\u0026quot;) } } struct ContentView : View { var body: some View { List { Section(header: Text(\u0026quot;Examples\u0026quot;)) { ExampleRow() ExampleRow() ExampleRow() } }.listStyle(.grouped) } }  运行效果: ","date":1564672935,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564672935,"objectID":"d620cb9ff8acc28b957dc223843f3e44","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/","publishdate":"2019-08-01T23:22:15+08:00","relpermalink":"/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/","section":"post","summary":" ","tags":["List"],"title":"5.8_如何制作分组列表","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的列表视图内置了对 sections 和 section headers 的支持，就像 UIKit 中的 UITableView 一样。若要给某些 cells 添加一个 _section_，首先在其周围放置一个 Section，也可以添加 header 和 _footer_。 举个例子，这里有一行包含提醒应用的任务数据：\nstruct TaskRow: View { var body: some View { Text(\u0026quot;Task data goes here\u0026quot;) } }  我们要做的是创建一个列表视图，它有两个Sections：一个用于重要任务，另一个用于次要任务。这是它的样子：\nstruct ContentView : View { var body: some View { List { Section(header: Text(\u0026quot;Important task\u0026quot;)) { TaskRow() TaskRow() TaskRow() } Section(header: Text(\u0026quot;Other task\u0026quot;)) { TaskRow() TaskRow() } } } }  运行效果: ","date":1564672873,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564672873,"objectID":"f0a49fa7ff7024c6785a623bc8471cae","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/","publishdate":"2019-08-01T23:21:13+08:00","relpermalink":"/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/","section":"post","summary":" ","tags":["List"],"title":"5.7_如何向列表中添加sections","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"如果您已配置 SwiftUI 列表视图以支持删除或编辑其项目，则可以允许用户通过在某个地方添加 EditButton 来切换列表视图的编辑模式。 例如，这个 ContentView 结构定义了一个用户数组，附加了一个 OnDelete() 方法，然后在导航栏中添加了一个编辑按钮:\nstruct ContentView : View { @State var users = [\u0026quot;Paul\u0026quot;, \u0026quot;Taylor\u0026quot;, \u0026quot;Adele\u0026quot;] var body: some View { NavigationView { List { ForEach(users.identified(by: \\.self)) { user in Text(user) } .onDelete(perform: delete) } .navigationBarItems(trailing: EditButton()) } } func delete(at offsets: IndexSet) { if let first = offsets.first { users.remove(at: first) } } }  运行后，您会发现您可以点击编辑按钮来启用或禁用列表中项目的编辑模式。\n","date":1564504813,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564504813,"objectID":"09062a50ca232f471f444aa7a512869c","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/","publishdate":"2019-07-31T00:40:13+08:00","relpermalink":"/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/","section":"post","summary":" ","tags":["List"],"title":"5.6_如何使用EditButton在列表上启用编辑","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 为我们提供了简单地列表挂钩（hooks），让我们可以移动行(rows)，尽管 WWDC 上演示的一些功能在当前的测试版中实际上不可用，所以我们需要一个变通的解决方法。 我们可以将 onMove(perform:) 修饰符附加到列表中的项目，并让它在移动操作发生时调用我们选择的方法。 该方法需要接受 source IndexSet 和 destination Int，如下所示：\nfunc move(from source: IndexSet, to destination: Int) {  移动多个项目时，最好先移动后一个项目，这样可以避免移动其他项目并混淆索引 例如，我们可以创建一个 ContentView 结构，它设置一个由三个用户名字符串组成的数组，并要求SwiftUI在调用 move()方法时移动它们。为了激活“移动”（即显示拖动手柄），它还向导航视图添加了一个编辑按钮，以便用户切换编辑模式。 这是代码:\nstruct ContentView : View { @State var users = [\u0026quot;Paul\u0026quot;, \u0026quot;Taylor\u0026quot;, \u0026quot;Adele\u0026quot;] var body: some View { NavigationView { List { ForEach(users, id: \\.self, content: { user in Text(user) }) .onMove(perform: move) } .navigationBarItems(trailing: EditButton()) } } func move(from source: IndexSet, to destination: Int) { // sort the indexes low to high let reverseSource = source.sorted() // then loop from the back to avoid reordering problems for index in reverseSource.reversed() { // for each item, remove it and insert it at the destination users.insert(users.remove(at: index), at: destination) } } }  运行效果: 在WWDC会话演示中，他们的 move() 方法只是一行代码，因为它在 Swift 数组上使用了一个对我们不可用的扩展——希望它很快就会到来！\n","date":1564503980,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564503980,"objectID":"df5508d053cc8fe9fe049ef34359b904","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/","publishdate":"2019-07-31T00:26:20+08:00","relpermalink":"/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/","section":"post","summary":" ","tags":["List"],"title":"5.5_如何让用户移动列表中的行","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"通过将 OnDelete(perform:) 处理程序附加到部分或全部数据，SwiftUI 可以方便地让用户滑动以删除行。此处理程序需要具有一个特定签名，它可以接受多个索引以删除，如:\nfunc delete(at offsets: IndexSet) {  在这里，您可以循环访问集合中的每个索引，或者只读取第一个索引（如果您只想处理它的话）。因为SwiftUI 正在监视您的状态，所以您所做的任何更改都将自动反映在您的UI中。 注意：此功能的 WWDC 演示使用了一个名为 remove(atOffsets:) 的不存在的Swift数组方法，它为我们完成了所有这些工作 - 希望这将在未来版本中出现。 例如，此代码创建一个包含三个项目列表的 ContentView 结构，然后附加一个 OnDelete(perform:) 修饰符，用于删除列表中的任何项目:\nstruct ContentView: View { @State var users = [\u0026quot;Paul\u0026quot;, \u0026quot;Taylor\u0026quot;, \u0026quot;Adele\u0026quot;] var body: some View { List { ForEach(users, id: \\.self) { user in Text(user) } .onDelete(perform: delete) } } func delete(at offsets: IndexSet) { if let first = offsets.first { users.remove(at: first) } } }  运行效果: 如果您运行该代码，您会发现可以滑动以删除列表中的任何行。\n","date":1564502131,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564502131,"objectID":"9a653dced5a1cfc86a9aaddba974f132","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/","publishdate":"2019-07-30T23:55:31+08:00","relpermalink":"/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/","section":"post","summary":" ","tags":["List"],"title":"5.4_如何让用户从列表中删除行","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"为了处理动态项目，我们必须首先告诉 SwiftUI 如何识别哪个项目是哪个。 这是使用 Identifiable 协议完成的，该协议只有一个要求: 某种类型的 id 值，SwiftUI 可以使用它来查看哪个项目是哪个。 例如，我们可以创建一个 Restaurant 结构体，该结构表示餐馆具有 ID 和 name ，ID 是一个随机标识符，以便 SwiftUI 知道哪个是哪个:\nstruct Restaurant: Identifiable { var id = UUID() var name: String }  接下来，我们将定义列表行的外观。在我们的例子中，我们将定义一个 Restaurantrow 视图，该视图存储一个餐厅并在文本视图中打印其名称:\nstruct RestaurantRow : View { var restaurant: Restaurant var body: some View { Text(\u0026quot;Come and eat at \\(restaurant.name)\u0026quot;) } }  最后，我们可以创建一个列表视图来显示所有内容。这意味着创建一些示例数据，将其放入数组中，然后将其传递到要呈现的列表中:\nstruct ContentView : View { var body: some View { let first = Restaurant(name: \u0026quot;Joe's Original\u0026quot;) let second = Restaurant(name: \u0026quot;The Real Joe's Original\u0026quot;) let third = Restaurant(name: \u0026quot;Original Joe's\u0026quot;) let restaurants = [first, second, third] return List(restaurants) { restaurant in RestaurantRow(restaurant: restaurant) } } }  其中大部分只是创建数据——最后一部分是实际操作的地方:\nreturn List(restaurants) { restaurant in RestaurantRow(restaurant: restaurant) }  它从 restaurants 数组创建一个列表，对数组中的每个项目执行一次闭包。每次执行闭包时，餐厅的输入都将由数组中的一个项目填充，因此我们使用它来创建一个 Restaurantrow。 事实上，在这种小case下，我们可以使代码更短:\nreturn List(restaurants, rowContent: RestaurantRow.init)  运行效果: ","date":1564496763,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564496763,"objectID":"8555c24417af7f523a4567dcdc656847","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/","publishdate":"2019-07-30T22:26:03+08:00","relpermalink":"/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/","section":"post","summary":" ","tags":["List"],"title":"5.3_如何创建动态项目列表","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"要创建静态项目列表，首先需要定义列表中每行的外观。 这是一个与其他视图一样的视图，因此您可以编写如下的视图:\nstruct RestaurantRow : View { var name: String var body: some View { Text(\u0026quot;Restaurant: \\(name)\u0026quot;) } }  既然已经定义了每一行的外观，那么就可以创建一个 List，根据需要创建任意数量的行，如下所示:\nstruct ContentView : View { var body: some View { List { RestaurantRow(name: \u0026quot;Joe's Original\u0026quot;) RestaurantRow(name: \u0026quot;The Real Joe's Original\u0026quot;) RestaurantRow(name: \u0026quot;Original Joe's\u0026quot;) } } }  运行效果: 当该代码运行时，您将在表中看到三行，就像您在 UIKit 中使用 UITableView 一样。 您不需要使每一行使用相同的视图类型，因此您可以根据需要混合和匹配行视图。\n","date":1564417382,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564417382,"objectID":"649672d6167f0ef3d5ff8cbbf5ee77b3","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/","publishdate":"2019-07-30T00:23:02+08:00","relpermalink":"/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/","section":"post","summary":" ","tags":["List"],"title":"5.2_如何创建静态项列表","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 List 视图类似于 UITableView，它可以根据您的需要显示静态或动态表视图单元格(table view cells)。 但是，它使用起来要简单得多:\n 我们不需要在 storyboard 中创建原型cell( prototype cell ); 也不需要在代码中注册 Cell; 我们不需要告诉它有多少行; 我们不需要手动出列(dequeue)和配置单元格等等。  相反，SwiftUI 的列表是为可组合性而设计的 - 旨在能够从较小的东西构建更大的东西。 因此，SwiftUI 不需要一个手动配置单元的大视图控制器，而是让我们构建小视图，知道如何将自己配置为列表行，然后使用它们。\n在代码大小方面（如果没有其他的话），差异是惊人的——您可以删除几乎所有的表视图代码，仍然可以获得与您习惯的相同的出色外观和感觉。\n","date":1564335608,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564335608,"objectID":"6b909d78b771bef1e4bb11b1ae612ad1","permalink":"https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/","publishdate":"2019-07-29T01:40:08+08:00","relpermalink":"/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/","section":"post","summary":" ","tags":["List"],"title":"5.1_使用List","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 对于应该与整个应用程序中所有视图共享的数据，SwiftUI 为我们提供了 @EnvironmentObject 。这使我们可以在任何需要的地方共享模型数据，同时确保当模型数据发生变化时，我们的视图自动保持更新。\n可以将 @EnvironmentObject 看作是在多个视图中使用 @ObjectBinding 的一种更智能、更简单的方法。而不是在视图 A 中创建一些数据，然后将其传递给视图 B，然后查看视图 C，然后在最终使用数据之前查看视图 D，我们可以在视图中创建它并将其放入环境（environment）中，这样的话，视图B、C、D将会自动访问它。\n 注意: 环境对象必须由祖先视图（ancestor view）提供 \u0026ndash; 如果 SwiftUI 找不到正确类型的环境对象，将会导致崩溃（crash），这也适用于预览，所以要小心。\n 2. 示例 例如: 这里有一个可绑定对象，用于存储用户设置:\nimport Combine import SwiftUI ​ class UserSettings: BindableObject { var didChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var score = 0 { didSet { didChange.send(()) } } }  是的，它只存储一个值，但是没关系 \u0026ndash; 重要的是: 当值发生改变时，PassthroughSubject 会告诉所有使用它（这个值）的的视图进行刷新。\n用户设置 是我们可能希望能够在应用程序的任何地方共享的一个合理的数据，这样我们就不再需要手动处理同步。\n因此，当我们的应用程序首次启动时，我们将创建一个 UserSettings 的实例。以便在我们的应用程序中随处都可以访问共享实例。\n如果打开 Scenedelegate.swift ，您将在 （_:willConnectTo:options:）方法：中找到这两行代码\nlet window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: ContentView())  第二行代码创建我们的初始内容视图（ContentView）并将其显示到屏幕上。这就是我们需要传入我们创建的任何环境对象的地方，以便 SwiftUI 可以在 ContentView 以及它使用的任何其它视图中使用我们创建的环境对象。\n首先，将其添加为 SceneDelegate 的一个属性:\nvar settings = UserSettings()  这会创建一个 settings 实例，并安全地存储它。现在回到刚才展示的那两行代码，并更改第二行，以便将我们的 settings 属性作为环境对象传递给 ContentView，如下所示:\nwindow.rootViewController = UIHostingController(rootView: ContentView().environmentObject(settings))  完成后，共享的 UserSettings 实例可用于 ContentView 以及它承载（hosts）或展现（presents）的任何其它视图。你只需要使用 @EnvironmentObject 属性包装器创建一个属性，如下所示:\n@EnvironmentObject var settings: UserSettings  这不需要使用默认值进行初始化，因为它将自动从环境中读取。\n因此，我们可以创建一个 ContentView 结构来增加我们的分数设置，甚至使它呈现出一个显示分数设置的 Detailview，所有这些都不需要创建或传递任何 UserSettings 的本地实例 \u0026ndash; 它总是使用环境。\n以下是实现这一目标的代码:\nstruct ContentView : View { @EnvironmentObject var settings: UserSettings var body: some View { NavigationView { VStack { Button(action: { self.settings.score += 1 }) { Text(\u0026quot;Increase score\u0026quot;) } NavigationButton(destination: DetailView()) { Text(\u0026quot;Show Detail View\u0026quot;) } } } } } ​ struct DetailView : View { @EnvironmentObject var settings: UserSettings var body: some View { // A text view that reads from the environment settings Text(\u0026quot;Score: \\(settings.score)\u0026quot;) } }  因此，一旦你将一个对象注入到环境中，你就可以立即在顶层视图中或者在下面的十层视图中使用它——这并不重要。最重要的是，每当任何视图改变环境时，依赖它的所有视图都会自动刷新，从而保持同步。\n如你所见，我们不需要将场景代理（scene delegate）中的 UserSettings 实例与我们两个视图中的 settings 属性显式关联 - SwiftUI 会自动发现它在环境中有一个 UserSettings 实例，因此这就是要使用的实例。\n 警告：既然我们的视图依赖于存在的环境对象，那么您还必须更新预览代码以提供一些要使用的示例设置。例如，使用 ContentView().EnvironmentObject(UserSettings()) 进行预览应该可以做到这一点。\n ","date":1564334245,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564334245,"objectID":"d7c53467083300299cef722449189967","permalink":"https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/","publishdate":"2019-07-29T01:17:25+08:00","relpermalink":"/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/","section":"post","summary":" ","tags":["Advanced state"],"title":"4.3_如何使用@EnvironmentObject在视图之间共享数据","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 两件重要的事情 当使用对象绑定时，我们需要处理两个细微不同的东西:\n BindableObject 协议，用于一些可以存储数据的类。 @ObjectBinding 属性包装器，在视图中用于存储可绑定对象实例。  2. 示例 举个例子，这是一个遵循 BindableObject 协议的 UserSettings 类:\nimport Combine import SwiftUI class UserSettings: BindableObject { var didChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var score = 0 { didSet { didChange.send(()) } } }  这段代码代码量很小，但是却包含了相当多的知识点，接下来我们逐一解释:\n 第一: didChange是 PassthroughSubject 的一个实例。  这个类来自 Combine 框架，我们需要添加 import Combine 以使我们的代码能够编译。 passthrough subject 的工作很简单: 每当我们想要告诉世界我们的对象发生了变化，我们就要求 passthrough subject 为我们做这件事情。它被称为 pass through ，因为我们传递给它的值实际上会传递给任何正在观察变化对象的视图。 PassthroughSubject 在技术上被称为 publisher ，因为它对世界发布了变化的公告。  第二: PassthroughSubject 是 Void 和 Never 的泛型。  第一个参数 Void 意味着 \u0026ldquo;我不发送任何值\u0026ldquo;。在 SwiftUI 的情况下，我们不需要发送值，因为我们想要的是视图刷新 - 它将自动从 @ObjectBinding 状态中获取新数据。 第二个参数 Never，意味着 \u0026ldquo;我永远不会抛出错误\u0026ldquo;。如果你想，你可以定义一个自定义的错误类型，如 NetworkError，并将其发送，但是通常会发现在可绑定对象内部本地处理错误。  第三: 我们在 UserSettings 的 score 属性上附加了一个 didSet 属性观察器，这样我们就可以在该值发生变化时运行代码。 在我们的示例代码中，每当得分发生变化时，我们都会调用 didChange.send(())，这就是告诉 didChange 发布者发布我们的数据已更改的消息，以便任何订阅的视图都可以刷新。  我们可以在这样的视图中使用 UserSettings类:\nstruct ContentView: View { @ObjectBinding var settings = UserSettings() var body: some View { VStack { Text(\u0026quot;Your score is \\(settings.score)\u0026quot;) Button(action: { self.settings.score += 1 }) { Text(\u0026quot;Increase Score\u0026quot;) } } } }  正如你所看到的，除了使用带有 @ObjectBinding 属性包装器的 settings 之外，其他所有内容都或多或少看起来相同 - SwiftUI 负责处理我们的所有实现细节。 但是有一个重要区别: settings 属性未声明为 private。 这是因为绑定对象可以被多个视图使用，因此通常会公开共享它。\n 警告: 当您使用 publisher 宣布您的对象已更改时，这必须在主线程上发生。\n ","date":1564330164,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564330164,"objectID":"ca9c9c1a2591882da7e410d5071269fe","permalink":"https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/","publishdate":"2019-07-29T00:09:24+08:00","relpermalink":"/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/","section":"post","summary":" ","tags":["Advanced state"],"title":"4.2_如何使用@ObjectBinding创建对象绑定","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. @State 在任何现代应用程序中，状态（State）都是不可避免的。\n但是对于 SwiftUI 来说，重要的是要记住:\n 我们所有的视图都只是它们的状态的函数 我们不会直接改变视图，而是操纵状态并让它决定结果  SwiftUI 为我们提供了几种在应用程序中存储状态的方法，但是它们之间略有不同，理解它们之间的区别对于正确使用框架是很重要的。\n到目前为止，在我们所有的状态示例中，我们都使用 @State 来创建如下属性:\nstruct ContentView : View { @State var score = 0 // more code }  这段代码在视图中创建了一个属性，但它使用 @State 属性包装器（property wrapper）来请求 SwiftUI 来管理内存。这一点很重要: 我们所有的视图都是结构体（structs），这意味着它们不能被改变，如果我们不能在一场比赛中给一个分数加1，那么这就不是一场比赛了。\n因此，当我们使用 @State 创建一个属性时，就意味着将该属性的控制权交给了 SwiftUI，这样的话，只要视图存在，它就在内存中保持不变。当该状态发生变化时，SwiftUI 知道用最新的变化自动重新加载视图，以便反映其新信息。\n@State 对于属于特定视图且从未在该视图之外使用的简单属性非常有用，因此通常最好将这些属性标记为私有属性，如下所示:\n@State private var score = 0  这再次强化了这样一种观点，即这种状态是专门设计的，永远不会脱离它的视图。简单理解，就是在视图内部使用的。\n2. @ObjectBinding 对于更复杂的属性:\n 当你有一个要使用的自定义类型，该类型可能具有多个属性和方法 可能在多个视图中共享时  那么，你应该使用 @ObjectBinding。 这与 @State 非常相似，只是现在我们使用的是外部引用类型，而不是简单地本地属性，如字符串或整数。我们仍然可以说视图取决于要更改的数据，除了我们负责管理自己的数据: 我们需要创建类的实例，创建自己的属性，等等。\n与 @ObjectBinding 一起使用的任何类型都应该遵循 BindableObject 协议，该协议只有一个要求: 您的类型必须实现某种类型的 didchange 属性，该属性在数据发生更改时通知视图。\n这就是我的意思，当我说这是你负责管理自己的数据时——当你在绑定对象上设置一个属性时，你就可以决定是否应该强制视图刷新。你通常会的，但不是必须的。\n一个可绑定的对象可以使用 Combine 框架中 publisher 通知其视图重要数据已经更改。如果碰巧有几个视图使用可绑定对象的数据，那么它将自动通知所有这些视图。\n 警告: 当你使用 publisher 宣布你的对象已更改，这个动作必须在主线程上执行。\n 3. @EnvironmentObject 我们已经了解了如何通过 @State 声明一个类型的简单属性，该类型数据在发生更改时自动导致视图更新，以及如何通过 @Objectbinding 声明外部类型的属性，该属性在更改时可能会或可能不会导致视图更新。这两个都必须由我们的视图设置，但是 @Objectbinding 可能与其他视图共享。\n针对这种情况，我们还有第三种类型的属性可供使用，即 @EnvironmentObject。这是一个通过应用程序本身对视图可用的值 -\n 它是每个视图都可以读取的共享数据，因此，如果你的应用程序有一些重要的模型数据，所有视图都需要读取，你可以把它从一个视图传递到另一个视图，或者把它放到每个视图都可以即时访问的环境中。\n 当我们需要在应用程序中传递大量数据时，可以将 @Environmentobject 视为一种极大的便利。由于所有视图都指向同一模型，因此如果一个视图更改模型，则所有视图都会立即更新 - 不会有使应用程序的不同部分不同的风险。\n4. 总结差异  将 @State 用于属于单个视图的简单属性。 它们通常应标记为 private。 将 @ObjectBinding 用于可能属于多个视图的复杂属性。 无论何时使用引用类型，都应该使用@ObjectBinding。 将 @EnvironmentObject 用于在应用程序中其他位置创建的属性，例如共享数据。  在这三种方法中，您会发现 @objectbinding 是最有用和最常用的，因此如果您不确定要使用哪种方法，请从那里开始。\n","date":1564324295,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564324295,"objectID":"4ab05b3531ff232d121b14870c542c81","permalink":"https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/","publishdate":"2019-07-28T22:31:35+08:00","relpermalink":"/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/","section":"post","summary":" ","tags":["Advanced state"],"title":"4.1_@ObjectBinding、@State 和 @EnvironmentObject三者之间的区别","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 以 onAppear() 和 onDisappear() 的形式为我们提供了 UIKit 的viewDidAppear() 和 viewDidDisappear() 的等价物。 您可以将任何代码附加到您想要的这两个事件，SwiftUI 将在它们发生时执行它们。\n2. 示例 注意：在当前的beta版本， onAppear() 工作得很好，但 onDisappear() 似乎没有被调用。 例如: 我们创建两个使用 onAppear() 和 onDisappear() 来打印消息的视图，并使用导航按钮在两者之间移动：\nstruct ContentView : View { var body: some View { NavigationView { NavigationLink(destination: DetailView()) { Text(\u0026quot;Hello World\u0026quot;) } }.onAppear { print(\u0026quot;ContentView appeared!\u0026quot;) }.onDisappear { print(\u0026quot;ContentView disappeared!\u0026quot;) } } } struct DetailView : View { var body: some View { VStack { Text(\u0026quot;Second View\u0026quot;) }.onAppear { print(\u0026quot;DetailView appeared!\u0026quot;) }.onDisappear { print(\u0026quot;DetailView disappeared!\u0026quot;) } } }  运行效果: 当代码运行时，我们应该能够在两个视图之间移动，并看到 Xcode 调试控制台中打印的消息。\n","date":1564317440,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564317440,"objectID":"8f314f08560aabefab6576fcc2aea91e","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/","publishdate":"2019-07-28T20:37:20+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.14_如何响应视图生命周期事件_appear_and_disappear","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 任何 SwiftUI 视图都可以附加手势识别器，而这些手势识别器又可以附加闭包，在识别器被激活时执行闭包。\n2. 示例 有几个手势识别器可供使用，这里我们提供其中几个的代码示例，以帮助入门 - 我们将看到它们有多相似。\n2.1 TapGesture 点击手势 创建 TapGesture 时，可以指定触发手势所需的 点击次数，然后附加将在手势发生时运行的 onEnded 闭包。\n例如，我们来创建一个每次点击时都会变大的图像:\nstruct ContentView: View { @State private var scale: Length = 1 var body: some View { Image(\u0026quot;example-image\u0026quot;) .scaleEffect(scale) .gesture( TapGesture() .onEnded({ (_) in self.scale += 0.1 }) ) } }  运行效果: 2.2 LongPressGesture 长按手势 LongPressGesture 可识别用户何时按下视图并保持至少一段用户指定的时间。 因此，我们创建一个图像视图，在按下该消息至少两秒时打印该消息:\nstruct ContentView: View { var body: some View { Image(\u0026quot;example-image\u0026quot;) .gesture( LongPressGesture(minimumDuration: 2.0) .onEnded({ (_) in print(\u0026quot;LongPressed!\u0026quot;) }) ) } }  运行效果: 2.3 DragGesture 拖拽手势 最后，当用户按下视图并移动至少一定距离时，DragGesture 会触发。因此，我们创建一个带有拖动手势的图像，当它们移动至少50个点时会触发:\nstruct ContentView: View { var body: some View { Image(\u0026quot;example-image\u0026quot;) .gesture( DragGesture(minimumDistance: 50) .onEnded({ (_) in print(\u0026quot;Dragged!\u0026quot;) }) ) } }  ","date":1564315172,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564315172,"objectID":"3364903379c9c273bb5481b517b2ecad","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/","publishdate":"2019-07-28T19:59:32+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.13_如何给视图添加手势识别器","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 任何 SwiftUI 视图都可以附加 点击操作(tap action)，我们可以指定在触发操作之前应该接收多少次点击。\n2. 示例 例如: 我们创建一个文本视图，在点击时将打印消息:\nstruct ContentView : View { var body: some View { Text(\u0026quot;Tap me!\u0026quot;) .tapAction { print(\u0026quot;Tapped\u0026quot;) } } }  运行效果: 再创建一个图像视图，当双击时将打印消息:\nstruct ContentView : View { var body: some View { Image(\u0026quot;example-img\u0026quot;) .tapAction(count: 2) { print(\u0026quot;Double tapped!\u0026quot;) } }  运行效果: ","date":1564310318,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564310318,"objectID":"55e3ef6773fc6b10e994bc4aa484b72b","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/","publishdate":"2019-07-28T18:38:38+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.12_如何设置tap和double Tap手势","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI中 的 SegmentedControl 与 UIKit中的 UISegmentedControl 的工作方式类似，但是它需要绑定到某种状态（state），并且必须确保为每个分段（segment）提供一个 tag 标记，以便能够识别它。分段(Segments) 可以是文本或者图片，其它任何东西都会自动失败。\n2. 示例 我们将创建一个分段控件，该控件使用 favoriteColor 作为状态属性，并且在下面添加一个文本视图，用于显示所选的任何值:\nstruct ContentView : View { @State private var favoriteColor = 0 var body: some View { VStack { SegmentedControl(selection: $favoriteColor) { Text(\u0026quot;Red\u0026quot;).tag(0) Text(\u0026quot;Green\u0026quot;).tag(1) Text(\u0026quot;Blue\u0026quot;).tag(2) } Text(\u0026quot;Value: \\(favoriteColor)\u0026quot;) } } }  运行效果: 不过，在本例中，我们最好创建一个数组来存储各种颜色，然后使用 foreach 在内部使用循环创建文本视图:\nstruct ContentView : View { @State private var favoriteColor = 0 var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Blue\u0026quot;] var body: some View { VStack { SegmentedControl(selection: $favoriteColor) { ForEach(0..\u0026lt;colors.count) { index in Text(self.colors[index]).tag(index) } } Text(\u0026quot;Value: \\(colors[favoriteColor])\u0026quot;) } } }  运行效果: ","date":1564280205,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564280205,"objectID":"61d4493272264ab2d0d062d71dec74d2","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-28T10:16:45+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.11_如何创建分段控件并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 初识 SwiftUI 中的 DatePicker 视图类似于 UIkit 中的 UIDatePicker，它提供了各种选项来控制它的外观和工作方式。和所有存储值的控件一样，它也需要绑定到应用程序中的某种状态。\n2. 示例 例如: 我们创建一个绑定到 birthDate 属性的日期选择器，然后显示日期选择器的值，如下所示:\nstruct ContentView : View { var dateFormatter: DateFormatter { let formatter = DateFormatter() formatter.dateStyle = .long return formatter } @State var birthDate = Date() var body: some View { VStack { DatePicker($birthDate, maximumDate: Date(), displayedComponents: .date) Text(\u0026quot;Date is \\(birthDate, formatter: dateFormatter)\u0026quot;) } } }  运行效果: 可以看到我已经将 DisplayedComponents 设置为 .Date，但您也可以使用 .hourAndMinute来获取时间数据。 我还使用 maximumDate 来阻止人们在将来指定出生日期，但是您可以指定 minimumDate 来阻止人们指定早于您选择的日期。\n","date":1564244924,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564244924,"objectID":"4cddfa543f0ee080e0ac194513780cad","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-28T00:28:44+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.10_如何创建DatePicker并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 Picker 视图将 UIPicker 和 UITableView 结合在一起。同时也适应其它操作系统上的其它样式。最棒的是我们真的不需要关系它是如何工作的 \u0026ndash; SwiftUI 可以很好的自动适应它的环境。 与大多数其它控件一样，必须将 picker 附加到某种 state，以跟踪 picker 的选择。例如: 这会创建一个 colors 数组和一个存储所选颜色的整数，然后将其与 picker，Text 视图一起使用，以便您可以看到正在读取的值:\nstruct ContentView: View { var colors = [\u0026quot;Red\u0026quot;, \u0026quot;Orange\u0026quot;, \u0026quot;Yellow\u0026quot;, \u0026quot;Green\u0026quot;] @State private var selectedColor = 0 var body: some View { VStack { Picker(selection: $selectedColor, label: Text(\u0026quot;Please choose a color\u0026quot;)) { ForEach(0..\u0026lt;colors.count) { Text(self.colors[$0]).tag($0) } } Text(\u0026quot;You selected: \\(colors[selectedColor]) \u0026quot;) } } }  运行效果: 注意: 将选择器视图放在某个内容中非常重要，以确保它在iOS上以默认的轮子样式显示。\n","date":1564242984,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564242984,"objectID":"95d8ab883b2ca60edb613b9212c745e8","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-27T23:56:24+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.9_如何创建选择器Picker并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 的 Slider 视图的工作原理与 UISlider 非常相似，尽管您需要将其绑定到某个地方，以便存储其值。 当我们创建它时，可以提供多种参数，但我们可能最关心的是:\n Value: 要绑定到的值是多少 From and To: 滑块的范围 By: 移动滑块时要更改多少值  2. 示例 例如: 我们创建一个绑定到 Celsius 属性的滑块，然后在滑块移动时更新文本视图，以便在 Celsius(摄氏温度) 和 Fahrenheit(华氏温度) 之间进行转换:\nstruct ContentView : View { @State var celsius: Double = 0 var body: some View { VStack { Slider(value: $celsius, from: -100, through: 100, by: 0.1) .padding() Text(\u0026quot;\\(celsius) Celsius is \\(celsius * 9 / 5 + 32) Fahrenheit\u0026quot;) } } }  运行效果: ","date":1564242023,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564242023,"objectID":"6e0dfc5aeee85c0ba579fc57c08604fc","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","publishdate":"2019-07-27T23:40:23+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.8_如何创建Slider并从中读取值","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 SecureTextField 的工作方式与常规的 TextField 完全相同，只是为了保护隐私而屏蔽了字符。当然，它绑定的底层值（underlying value）仍然是一个普通的字符串，因此你可以根据需要检查它。 下面是一个示例，创建了一个绑定到本地 @State 属性的 SecureField，以便我们显示键入的内容:\nstruct ContentView : View { @State private var password = \u0026quot;\u0026quot; var body: some View { VStack { SecureField($password, placeholder: Text(\u0026quot;Enter your password:\u0026quot;)) .padding() Text(\u0026quot;Your entered: \\(password)\u0026quot;) } } }  运行效果: 提示: 在 beta1 和 beta2 中，你应该使用: SecureField($password)\n","date":1564241580,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564241580,"objectID":"3d6ecacd3c6855a02c680a90954675d3","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/","publishdate":"2019-07-27T23:33:00+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.7_如何使用SecureField创建一个安全的文本输入框","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 TextField 支持占位符文本，就像 UITextField 一样 \u0026ndash; 当 TextField 为空时在 TextField 中显示灰色文本。要么使用提示（”Enter your password“），要么显示一些示例数据。\n要设置 placeholder，请将其作为 TextField 初始化设置的一部分传入，如下所示:\nstruct ContentView : View { @State var emailAddress = \u0026quot;\u0026quot; var body: some View { TextField($emailAddress, placeholder: Text(\u0026quot;test@gmail.com\u0026quot;)) .textFieldStyle(.roundedBorder) .padding() } }  运行效果: 这将在 TextField 中显示占位文本 test@gmail.com，而 TextField 为空，但一旦用户在其中键入内容，占位文本就会消失。\n","date":1564239599,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564239599,"objectID":"0e3882801ea545ed88f41f5dee0dc56c","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/","publishdate":"2019-07-27T22:59:59+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.6_如何给TextField添加占位符","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 TextField 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更愿意在 TextField 周围添加边框，以使其更清晰。 如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 .textFieldStyle(.roundedBorder) 修饰符，如下所示:\nstruct ContentView : View { @State var text = \u0026quot;\u0026quot; var body: some View { TextField($text, placeholder: Text(\u0026quot;Enter some text\u0026quot;)) .padding() .textFieldStyle(.roundedBorder) } }  运行效果: ","date":1564238554,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564238554,"objectID":"c5921d17d28e606592038104bf6e7930","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/","publishdate":"2019-07-27T22:42:34+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.5_如何给TextField添加边框","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 的 TextField 视图类似于 UIkit 中的 UITextField，但是，在默认情况下 TextField 看起来有点不同，并且它非常依赖于 状态绑定（binding to state）。\n2. 创建 TextField 那么，要创建一个 TextField，我们应该给在 text field 传入一个 placeholder，再加上它应该绑定到的状态属性。\n例如: 现在，我们要创建一个 绑定到本地字符串的 TextField，然后在其下面放置一个文本视图，在键入时显示 TextField 的输出:\nstruct ContentView : View { @State var name = \u0026quot;Devin\u0026quot; var body: some View { VStack { TextField($name, placeholder: Text(\u0026quot;Enter your name\u0026quot;)) Text(\u0026quot;Hello, \\(name)\u0026quot;) } } }  运行后，您应该能够在 TextField 中键入内容，并看到下面直接显示一条问候语。 运行效果: 提示: 在 beta1 和 beta2 中，应该改用 TextField($name)。 使用 TextField 时有两个重要的限制条件。首先，默认情况下，它没有边框，因此你可能看不到任何内容 \u0026ndash; 你需要大致点击其所在位置，以激活键盘。 其次，您可能会发现无法在布局的画布预览中键入内容。如果遇到这个问题，请按Cmd+R在模拟器中构建和运行代码。\n","date":1564234941,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564234941,"objectID":"bc2d48638948cb5663d60f788ef39370","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/","publishdate":"2019-07-27T21:42:21+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.4_如何从TextField中读取文本","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. Button vs UIButton SwiftUI 的 按钮(Button) 类似于 UIKit 中的 UIButton，跟 UIButton 的区别在于:\n 在显示内容方面 SwiftUI 的按钮更为灵活 SwiftUI 的按钮使用 闭包 来实现其 action，而 UIButton 使用的是 target/action 系统  2. Button 初体验 那么，如何创建一个 SwiftUI 的按钮呢?，我们可以从以下代码开始:\nButton(action: { // your action here }) { Text(\u0026quot;Button title\u0026quot;) }  由以上代码可以看到，创建 Button 的的方法有两个参数，都是闭包，第一个闭包负责传入 action，第二个闭包负责传入按钮上的文本。\n3. Button 简单用例 例如: 我们可以创建一个按钮，在点击按钮时显示或隐藏一些详细信息:\nstruct ContentView : View { @State var showDetails = false var body: some View { VStack { Button(action: { self.showDetails.toggle() }) { Text(\u0026quot;Show detail information\u0026quot;) } if showDetails { Text(\u0026quot;You should follow me on M X Website\u0026quot;) .font(.largeTitle) .lineLimit(nil) } } } }  运行效果: 4. 提示 在学习框架时最常做的事情是分散调用 print()，这样我们就可以看到什么时候发生了什么事情。 如果我们想通过按钮 action 来尝试，首先应右键单击预览画布中的播放按钮，然后选择 调试预览，以便调用 print() 工作。 按钮内的标题可以是任何类型的视图，因此您可以创建这样的图像按钮:\nButton(action: { self.showDetails.toggle() }) { Image(\u0026quot;example-image\u0026quot;) }  运行效果: ","date":1564215682,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564215682,"objectID":"d20c00144e66723398bd9ac6d31dff6c","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/","publishdate":"2019-07-27T16:21:22+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.3_如何创建一个可点击的按钮","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 中的 toggle 允许用户在 true 和 false 之间移动，就像 UIKit 中的 UISwitch 一样。\n例如:\n我们可以创建一个 toggle ，然后根据 toggle 是否启动来决定显示或者不显示消息。但是我们不希望手动跟踪 toggle 的状态 \u0026ndash; 我们希望 SwiftUI 为我们做这件事。 与以往不同，在这里，我们应该定义一个 @State Boolean 属性，用于存储 toggle 的当前值。然后我们可以使用它来显示或隐藏其它视图。\n例如:\nstruct ContentView : View { @State var showGreeting = true var body: some View { VStack { Toggle(isOn: $showGreeting) { Text(\u0026quot;Show welcome message!\u0026quot;) }.padding() if showGreeting { Text(\u0026quot;Hello world\u0026quot;) } } } }  运行效果: 这段代码，只有当 showGreeting 为 true 时才会返回文本视图，这意味着当 showGreeting 为 false 时，VStack 的大小会减小 - 它的堆栈中没有第二个视图。\n","date":1564214142,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564214142,"objectID":"3c1e66f81817090b3b3c051810d18775","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/","publishdate":"2019-07-27T15:55:42+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.2_如何创建拨动开关","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 概念 所有应用程序都会改变状态。\n例如:\n 用户可能点击了一个按钮来显示更多信息 用户可能已经在文本框中输入了一些文本 用户从日期选择器中选择了一个日期  所有涉及应用程序 从一种状态转变到另一种状态 的事情，都叫做应用程序改变状态。\n2. 问题所在 状态的问题在于它是混乱的: 当它发生变化时，我们需要发现变化并更新我们的布局来匹配变化。 这个一开始听起来可能很简单，但是随着我们的状态的不断增长，它就会变得越来越难 - 因为这个时候，我们很容易忘记更新一件事，或者更新顺序出错，以致于用户界面状态达不到预期效果。\n3. SwiftUI 如何破解？ SwiftUI 通过 从控件中移除状态 来解决这个问题。\n当我们向视图添加属性时，这些属性实际上是惰性的 - 当然，它们有值，但是更改这些值并不会做任何事情。 但是如果我们在这些属性之前添加了特殊的@State 来包装属性，SwiftUI将自动监视属性变化并更新使用该属性的视图的任何部分。\n示例代码:\n@state var name: String = \u0026quot;\u0026quot;   注意: @state 这种语法称为 属性包装器，这里不作详细介绍，可以自行查找文档。\n 当涉及到某种状态时 - 例如，当切换开关（toggle switch）改变时告诉状态属性改变。 这里需要注意的是: 我们不能直接引用这个属性属性。这是因为 Swift 会认为我们现在所指的是\u0026quot;属性当前的值\u0026quot;，而不是说 \u0026quot;请注意这件事情(属性状态变化)\u0026quot;。幸运的是，SwiftUI 的解决方案是在属性名称前放置一个美元符号($)，这样的话，我们就可以引用属性本身而不是它当前的值。\n 当然，这里一开始理解起有点令人困惑，但在当我们学习一两个示例之后就会理解，非常简单。\n 最后，请记住，SwiftUI 是声明性的，这意味着我们预先告诉它所有可能状态的所有布局，并让它知道当属性发生变化时如何在它们之间移动。我们称之为 绑定（binding） - 要求 SwiftUI 同步UI控件和底层属性之间的更改。 如果你已经习惯了一种更为迫切的编程风格，那么使用 state 一开始会让你头疼一些，但不要担心 - 一旦你完成了它，你就很明确了。\n","date":1564152499,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564152499,"objectID":"60ad908be8392124a7932d32de1fad67","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/","publishdate":"2019-07-26T22:48:19+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/","section":"post","summary":" ","tags":["Responding to events"],"title":"3.1_使用 state","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"默认情况下，我们的 SwiftUI 视图将主要位于安全区域内 - 它将会到达屏幕底部，但不会靠近设备顶部的任何凹口。 如果我们想改变它 - 想让视图真正全屏，即使这意味着被一个缺口或其他硬件切口部分遮挡 - 那么我们应该使用 edgesIgnoringSafeArea() 修饰符。 例如，这会创建一个红色文本视图，要求填充所有可用空间，然后将其设置为忽略任何安全区域，以使其真正边缘到边缘。\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity) .background(Color.red) .edgesIgnoringSafeArea(.all) }  运行效果: ","date":1564150370,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564150370,"objectID":"2d7ef1463d807d926bce34ac48fcf79f","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/","publishdate":"2019-07-26T22:12:50+08:00","relpermalink":"/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/","section":"post","summary":" ","tags":["View layout"],"title":"2.8_如何将视图放到安全区域之外","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 通过在环境中暴露 size classes 来原生支持它。如果要使用它，我们首先需要创建一个 @Environment 对象来存储其值，如下所示:\n@Environment(\\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?  然后在我们需要时检查该属性的值，查找 .compact 或 .regular，如下所示:\nif horizontalSizeClass == .compact { return Text(\u0026quot;Compact\u0026quot;) } else { return Text(\u0026quot;Regular\u0026quot;) }  将所有代码组合在一起，可以创建这样的视图:\nstruct ContentView: View { @Environment(\\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass? var body: some View { if horizontalSizeClass == .compact { return Text(\u0026quot;Compact\u0026quot;) } else { return Text(\u0026quot;Regular\u0026quot;) } } }  运行效果:\n(1) 正向竖屏 (2) 横屏 - 刘海在右侧 (3) 横屏 - 刘海在左侧 ","date":1564131137,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564131137,"objectID":"b019851a2ebb1462e1c5b879efc221ee","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/","publishdate":"2019-07-26T16:52:17+08:00","relpermalink":"/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["View layout"],"title":"2.7_如何使用size_classes创建不同的布局","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 我们通常会发现，我们需要循环一个序列来创建视图，而在 SwiftUI 中，这是通过 ForEach 来完成的。\n重要提示: 我们很容易一看到 ForEach 就认为它与 Swift 序列中的 forEach() 方法相同，但事实并非如你所见。\n SwiftUI 中的 ForEach 本身是一个视图结构，这就意味着我们可以根据需要直接从视图 Body 返回它。 我们为它提供一系列项目，可能还需要告诉 SwiftUI 它如何唯一地标识每个项目，以便 SwiftUI 知道如何在值更改时更新它们。 我们还传递一个要运行的闭包，来为循环中的每个项创建一个视图。 对于范围内的简单循环，您可以将范围直接传递给ForEach。  1. 循环 1\u0026hellip;10 创建文本视图 例如，这从10减少到1然后在最后添加一条消息：\nvar body: some View { VStack(alignment: .leading) { ForEach((1...10).reversed()) { Text(\u0026quot;\\($0)…\u0026quot;) } Text(\u0026quot;Ready or not, here I come!\u0026quot;) } }  运行效果: 2. ForEach colors 对于简单类型数组（如字符串、整数、颜色等）的循环，可以在数组上使用 .identified(by: \\.self)，让 SwiftUI 使用值本身作为标识符。因此，如果您的数组是 [\u0026quot;cat\u0026quot;, \u0026quot;Dog\u0026quot;, \u0026quot;monkey\u0026quot;]，那么 SwiftUI 会将这些字符串本身作为您的视图的标识符。 因此，此代码创建一个包含三种颜色的数组，在它们上面循环，并使用每个颜色名称和颜色值创建文本视图：\nlet colors: [Color] = [.red, .green, .blue] var body: some View { VStack { ForEach(colors.identified(by: \\.self)) { color in Text(color.description.capitalized) .padding() .background(color) } } }  运行效果: 3. ForEach custom type 如果您的数组中有自定义类型，则应使用 .identified(by:) 与您的类型中的任何属性唯一标识它。 例如，这是一个存储测试结果的结构，如下所示：\nstruct Result { var id = UUID() var score: Int }  它有一个带有 UUID 的 id 属性，这意味着它保证是唯一的 - 完美的用于我们的目的。 如果我们想循环一个结果数组，创建一个显示 VStack 中每个结果的文本视图，那么我们将使用它：\nlet results = [Result(score: 8), Result(score: 5), Result(score: 10)] var body: some View { VStack { ForEach(results.identified(by: \\.id)) { result in Text(\u0026quot;Result: \\(result.score)\u0026quot;) } } }  运行效果: 这告诉 SwiftUI 它可以通过查看它们的 id 属性来区分 ForEach 中的视图。 提示：如果您使 Result 符合 Identifiable protocol，您只需编写 ForEach（Result）。 符合此协议意味着添加唯一标识每个对象的 id 属性，在我们的示例中我们已经拥有，因此您只需编写 struct Result：Identifiable {！\n","date":1564071700,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564071700,"objectID":"44f7c36133de110ed7eedcbf7f02adf5","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/","publishdate":"2019-07-26T00:21:40+08:00","relpermalink":"/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["View layout"],"title":"2.6_如何使用ForEach在循环中创建视图","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 当我们从视图的 body 返回 some View 的时候，Swift 理解这意味着我们有一个特定的返回类型。\n例如: 如果我们想掷硬币并显示 \u0026ldquo;你赢了!\u0026ldquo;，但是我们不能这样写: 要么返回一个 Image，要么返回一个 Text，写着 \u0026ldquo;下次祝你好运\u0026rdquo;:\nvar body: some View { if Bool.random() { Image(\u0026quot;example-image\u0026quot;) } else { Text(\u0026quot;Better luck next time\u0026quot;) } }  这段代码会报错: 因为它可能返回 Image 或者 Text ，这是不允许的 \u0026ndash; 我们必须精确返回一种类型。 有两种方法可以解决这个问题。\n1. Group 第一种方法是将输出包装在一个 group 中，这样无论我们发送图像视图还是文本视图，它们都将返回到一个 group 中:\nvar body: some View { Group { if Bool.random() { Image(\u0026quot;example-image\u0026quot;) } else { Text(\u0026quot;Better luck next time\u0026quot;) } } }  运行效果: 2. AnyView 第二种方法，SwiftUI 提供了一个名为 AnyView 的类型，我们可以返回这种类型:\nvar body: AnyView { if Bool.random() { return AnyView(Image(\u0026quot;example-image\u0026quot;)) } else { return AnyView(Text(\u0026quot;Better luck next time\u0026quot;)) } }  如果你还没有听说过这个概念，它会强制让 Swift 忘记 AnyView 中包含的特定类型，让它们看起来像是一样的东西。但这有性能成本，所以不要经常使用它。 尽管 Group 和 AnyView 都为我们的布局实现了相同的结果，但通常最好使用 Group，因为它对 SwiftUI 更有效。\n","date":1564033641,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564033641,"objectID":"8060bb86f12304582ea806ac36436683","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/","publishdate":"2019-07-25T13:47:21+08:00","relpermalink":"/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/","section":"post","summary":" ","tags":["View layout"],"title":"2.5_如何返回不同的视图类型","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 有一个专用的 stack 类型，用于创建重叠内容，例如，如果我们想在图片上放置一些文本，它就很有用。它被称为 ZStack，其工作原理与其他两种 stack 类型相同。\n1. 在文本下面放置图片 例如: 我们可以在如下文本下面放置一个大图像:\nvar body: some View { ZStack() { Image(\u0026quot;example-image\u0026quot;) Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background(Color.black) .foregroundColor(.white) } }  运行效果: 2. 对齐 与其它 stack 类型一样，ZStack 也可以设置对齐方式，这样它就不会总是将事物置于自身的中心位置:\nvar body: some View { ZStack(alignment: .leading) { Image(\u0026quot;example-image\u0026quot;) .resizable() .aspectRatio(contentMode: .fit) Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background(Color.black) .foregroundColor(.white) } }  运行效果: 但是，它没有 spacing 属性，因为它实际上没有意义。\n","date":1564032412,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564032412,"objectID":"a7bfae9c2de4a6e9a4edd2f9b2c4c6d9","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/","publishdate":"2019-07-25T13:26:52+08:00","relpermalink":"/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/","section":"post","summary":" ","tags":["View layout"],"title":"2.4_如何使用ZStack将视图叠加在一起","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 允许我们使用 padding() 修饰符在视图周围设置单独的填充。\n1. 系统默认 padding 如果在不传参数的情况下使用 padding() ，您将在所有边上获得系统默认填充，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里默认设置了视图四周的填充。\n2. 只设置一侧系统默认 padding 我们也可以自定义要 apply 的 padding 和位置。因此，我们只希望将系统填充应用于一侧:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里只设置了底部填充，与上面的例子不同。\n3. 用具体数值来设置 padding 我们可能希望控制对所有边应用了多少填充:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 4. 在视图一侧添加特定数量的填充 我们也可以将这两者结合起来，在视图的一侧添加特定数量的填充：\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom, 100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564025985,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564025985,"objectID":"e4177bc07a2849e3ab458ab3bb0941b0","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","publishdate":"2019-07-25T11:39:45+08:00","relpermalink":"/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","section":"post","summary":" ","tags":["View layout"],"title":"2.3_如何使用padding控制单个视图周围的间距","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 1. spacing 我们可以通过在 SwiftUI stacks 的构造方法中填一个值来设置间距，如下所示:\nvar body: some View { VStack(spacing: 50) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 2. Divider 我们可以在项目之间创建分隔符，以便 SwiftUI 在 stack 中的每个项目之间进行小的视觉区分，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Divider() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 3. alignment 默认情况下，stacks 中的项目居中对齐。\n 在 HStack 中: 项目在中间垂直对齐，因此如果有两个不同高度的文本视图，它们都将与垂直中心对齐。 在 VStack 中: 项目在中间水平对齐，因此如果有两个长度不同的文本视图，它们都将与水平中心对齐。  要调整这种情况，请在创建 stack 时按以下方式传递一个 alignment 参数:\nvar body: some View { VStack(alignment: .leading) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使 Hello SwiftUI 和 Hello M X 左对齐，但它们最终将位于屏幕的中间，因为 stack 只占用所需的空间。\n4.同时设置 alignment 和 spacing 我们可以同时使用 alignment 和 spacing ，如下所示:\nvar body: some View { VStack(alignment: .leading, spacing: 20) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使两个文本视图水平对齐到 leading（对于从左到右的语言是左对齐），并在它们之间放置20个点的垂直间距。\n","date":1564023292,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564023292,"objectID":"294ef00070d5dc7a12b85b39352a4f69","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","publishdate":"2019-07-25T10:54:52+08:00","relpermalink":"/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["View layout"],"title":"2.2_如何通过alignment和spacing自定义stack布局","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 的内容视图 content views 必须返回一个视图，即我们希望它们显示的视图。当我们想要一次在屏幕上显示多个视图时，我们需要告诉 SwiftUI 如何排列它们，这就是 堆栈（stacks）的来源。\n堆栈（Stacks） 相当于 UIKit 中的 UIStackView 。有三种形式:\n 水平（HStack） 垂直（VStack） 基于深度（ZStack）  当我们想放置子视图以便它们重叠时可以使用后者。\n1. VStack 让我们从一些简单的事情开始，先创建一个文本视图:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) }  运行效果: 有了一个文本视图，如果我们想在下面再写一个，我们不能只写:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) Text(\u0026quot;Hello M X\u0026quot;) }  这样的话，编译器会直接报错。 记住，我们只能返回一个视图，否则代码就不会工作。\n那么怎么办呢？我们需要将其放置在 VStack 中，以便将文本视图放置在彼此上方:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 您会注意到 VStack 放置在屏幕的中心，标签也居中，它们之间有一些自动空间。\n2. HStack 如果我们希望文本视图并排水平放置，请使用如下方式将 VStack 替换为 HStack:\nvar body: some View { HStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564020650,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564020650,"objectID":"25808207349efed761b6e8e414a439c6","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","publishdate":"2019-07-25T10:10:50+08:00","relpermalink":"/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","section":"post","summary":" ","tags":["View layout"],"title":"2.1_如何使用VStack和HStack创建stacks","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 我们可以使用相同的 background() 修饰符来设置背景图像，而不是设置背景颜色。\n1. 给文本视图设置图像背景 例如: 现在，我们要创建一个大字体的文本视图，然后在其后面放置一个 100x100 的图像:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Image(\u0026quot;example-image\u0026quot;) .resizable() .frame(width: 100, height: 100) ) } }  运行效果: 2. 给文本视图设置一个红色圆圈作为背景 在 SwiftUI 中，背景 View 并不一定是一个图像，实际上我们可以使用任何类型的视图作为背景。 例如: 现在将创建相同的文本视图，然后在其后面放置一个 200x200 的红色圆圈:\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) ) }  默认情况下，背景视图会自动占用尽可能多的空间以完全可见，但如果需要，可以使用 clipped() 修饰符将其剪裁为父视图的大小：\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) .clipped() ) }  运行效果: 明确地说，您可以使用任何视图作为背景，例如，如果需要，可以使用另一个文本视图。\n","date":1563954389,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954389,"objectID":"d77a54ad5e70c0e354963d33db9f8afa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","publishdate":"2019-07-24T15:46:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","section":"post","summary":" ","tags":["Text and image"],"title":"1.9_如何使用图像和其它视图作为背景","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 如果我们想在应用程序中使用简单地几何形状，我们可以直接创建它们，然后根据需要对它们进行着色和定位。\n1. 矩形 例如，如果我们想要一个 200x200 红色矩形，可以使用如下代码:\nvar body: some View { Rectangle() .fill(Color.red) .frame(width: 200, height: 200) }  运行效果: 2. 圆 同样，如果你想要一个 50x50 的蓝色圆圈，您可以使用如下代码:\nvar body: some View { Circle() .fill(Color.blue) .frame(width: 50, height: 50) }  运行效果: ","date":1563954361,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954361,"objectID":"6bb26cdc2adaf8cb830077b8110d51aa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","publishdate":"2019-07-24T15:46:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","section":"post","summary":" ","tags":["Text and image"],"title":"1.8_如何显示几何形状","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 为我们提供了各种渐变选项（gradient options），所有这些选项都可以以各种方式来使用。例如:\n1. 垂直线性渐变 我们使用从白色到黑色的线性渐变来渲染文本视图，如下所示:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 颜色被指定为一个数组，我们可以设置任意多我们想要的颜色 - 默认情况下，SwiftUI 将会平均分配这些颜色。所以，我们也可以这样从 白色 -\u0026gt; 红色 -\u0026gt; 黑色 来设置:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 2. 水平线性渐变 要实现一个水平渐变（a horizontal gradient）而不是一个垂直渐变（a vertical one），使用 .leading 和 .trailing 来作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .leading, endPoint: .trailing), cornerRadius: 0) }  运行效果: 3. 对角线线性渐变 要实现对角线渐变，可以使用 .topLeading 和 .bottomTrailing 作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .topLeading, endPoint: .bottomTrailing), cornerRadius: 0) }  运行效果: ","date":1563954329,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954329,"objectID":"b89862110d29df1cb2a98f4fee3a3c1b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","publishdate":"2019-07-24T15:45:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","section":"post","summary":" ","tags":["Text and image"],"title":"1.7_如何渲染渐变","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" SwiftUI 的 Image 能够以不同的方式进行缩放，就像 UIImageView 的 content mode 一样。\n1.默认 默认情况下，图像视图会自动调整其内容的大小，这可能会使它们超出屏幕。\nImage(\u0026quot;ba_xian_tai\u0026quot;)  运行效果: 如果添加了 resizable() 修饰符，则图像将自动调整大小，以填充所有可用空间:\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable()  运行效果: 然而，这也可能导致图像的原始纵横比失真，因为它将在所有维度上被拉伸任意数量，以使其填充空间。\n2. .fill 和 .fit 如果要保持其纵横比，应使用 .fill 或 .fit添加一个aspectRatio()修饰符，如下所示：\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable() .aspectRatio(contentMode: .fill)  运行效果: 注意: 在当前的测试版中，有一个bug，.fit 内容模式仍然会导致图像被拉伸。\n","date":1563954307,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954307,"objectID":"cf6ffdbb1c994faad0b4746884cab952","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","publishdate":"2019-07-24T15:45:07+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","section":"post","summary":" ","tags":["Text and image"],"title":"1.6_如何调整图像视图的填充模式","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 使用图像视图 Image 可以在 SwiftUI 布局中渲染图像（images）。我们可以从 Bundle、System icons、UIImage 等中加载图像，但这三个将是最常见的。\n1. 从 Bundle 加载 要从 Bundle 中加载图像并将其显示在图像视图中，只需使用以下代码:\nvar body: some View { Image(\u0026quot;example-image\u0026quot;) }  运行效果: 2. 从 System icons 加载 要从苹果旧金山符号集(Apple’s San Francisco Symbol set)中加载图标，请使用 Image(systemName: ) 初始化器，传入图标字符串进行加载，如下所示:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;)  运行效果: 3. 从 UIImage 加载 最后，可以从现有的 UIImage 创建一个图像视图。因为这需要更多的代码，所以需要显式地使用 return 关键字。\nguard let image = UIImage(named: \u0026quot;example-image\u0026quot;) else { fatalError(\u0026quot;Unable to load image\u0026quot;) } return Image(uiImage: image)  运行效果: 4. foregroundColor 如果你使用的是 系统图标集，则返回的图像是 可缩放 和 可着色 的，这意味着你可以使用 foregroundColor() 修改器对图像着色。\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .foregroundColor(.red)  运行效果: 5. 动态文本样式 这意味着你可以通过匹配任何 Dynamic Type 文本样式，来要求 SwiftUI 放大图像:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .font(.largeTitle)  运行效果: ","date":1563954255,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954255,"objectID":"bcd80c540133b4c4f850d3403d4e3377","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","publishdate":"2019-07-24T15:44:15+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","section":"post","summary":" ","tags":["Text and image"],"title":"1.5_如何使用图像视图绘制图像","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":"SwiftUI 的文本视图有一个可选的 formatter 参数，可以让我们用来自定义数据在标签（label）内的显示方式。这一点很重要，因为在我们的程序中发生某些事情时，通常会为我们更新值，因此通过附加 formatter， SwiftUI 可以确保我们的数据以我们期望的方式来正确显示。\n例如，这定义了一个日期格式（date formatter）化程序，并使用它来确保 任务日期 以人类可读的形式显示:\nimport SwiftUI struct ContentView : View { static let taskDateFormatter: DateFormatter = { let formatter = DateFormatter() formatter.dateStyle = .long return formatter }() var dueDate = Date() var body: some View { Text(\u0026quot;Task due date: \\(dueDate, formatter: Self.taskDateFormatter)\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif  运行效果: ","date":1563954209,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954209,"objectID":"c122de324e0c11ab95cb0738749a23d0","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","publishdate":"2019-07-24T15:43:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","section":"post","summary":" ","tags":["Text and image"],"title":"1.4_如何格式化文本视图中的文本","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 文本视图不仅在外观方面给了我们一个可预见的广泛控制，而且还设计成与苹果的核心技术（如 Dynamic Type）无缝配合。\n1. 字体 默认情况下，文本视图有一个 Body 动态类型样式，但是我们可以通过以下方式调用 .font()，从其它 sizes 和 weights 进行选择:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle)  运行效果: 我们现在在文本视图下面使用了两个修饰符，这没关系 - 你可以将它们堆叠起来，并且它们都会生效。\n2. 文本对齐 特别是，现在我们有多行文本，我们需要调整文本的对齐方式，使其居中，如下所示:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .multilineTextAlignment(.center)  运行效果: 3. 字体颜色 我们可以通过 .foregroundColor() 修饰符来设置文本颜色，如下所示:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red)  运行效果: 4. 背景 我们可以使用 .background() 来设置背景颜色，但是它不仅仅可以用来设置背景颜色，也可以设置背景视图。无论如何，为了给我们的文本视图设置一个黄色背景，代码如下:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red) .background(Color.yellow)  运行效果: 5. 行间距 我们可以设置多行文本的行间距，行间距默认值为0，表示没有额外的行间距，但是我们可以通过以下方式在行与行之间指定一个值来添加额外的行间距。\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .lineSpacing(50)  运行效果: ","date":1563954148,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954148,"objectID":"8be44a51185d5c70ca4c4bc7d2fb462d","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","publishdate":"2019-07-24T15:42:28+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","section":"post","summary":" ","tags":["Text and image"],"title":"1.3_如何使用字体颜色行距等设置文本视图的样式","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 1. 基本用法 文本视图 Text 主要用于在屏幕上显示静态文本，相当于 UIKit 中的 UILabel。最基本的用法如下:\nText(\u0026quot;Hello world\u0026quot;)  在内容视图的预览窗口中，您可能会看到 Automatic preview updating paused， 继续按 Resume 以让 Swift 开始构建代码并向您展示其外观的实时预览。\n2. 设置显示行数 默认情况下，Text 只显示一行 - 如果空间不足，字符将被剪切并替换为 ...。因此如果我们要显示的文本很长，就会看到这种情况发生。如果要改变这种行为 - 比如你希望 Text 可以显示多行文本，那么可以这样做，使其具有特定的行数:\nText(\u0026quot;Hello world\u0026quot;) .lineLimit(3)   提示: 请注意 lineLimit(3) 位于 Text(\u0026quot;Hello World\u0026quot;) 下方靠右侧的方式。这不是必需的，但它确实使您的代码更易于阅读。\n 或者，可以将 nil 指定给 lineLimit() 方法，该方法允许它根据需要运行在任意多行:\nText(\u0026quot;Hello World\u0026quot;) .lineLimit(nil)   注意: 这里设置 lineLimit(0) 不能实现多行显示，这一点跟 UIKit 中是不一样的。\n 3. 文本截断 我们也可以调整 SwiftUI 截断文本的方式，而不是调整行数。默认情况下，从末尾删除文本并显示省略号，但也可以将省略号放在中间或开头，具体取决于字符串各个部分的重要程度。\n例如: 以下代码会在中间截断文本\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones.\u0026quot;) .truncationMode(.middle)  不管我们如何截断文本，我们将看到文本视图始终位于主视图（main view）的中心。这是 SwiftUI 的默认行为 \u0026ndash; 除非我们明确告诉 SwiftUI 将视图定位到其他位置，否则 SwiftUI 会将视图定位到相对于屏幕中心的位置。\n","date":1563946501,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563946501,"objectID":"c8de0192120507accbd6cb1c301d2f14","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","publishdate":"2019-07-24T13:35:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","section":"post","summary":" ","tags":["Text and image"],"title":"1.2 如何使用文本视图创建静态标签","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 提示: 您可能认为本章完全可以跳过，但除非你是一个 Swift 天才，否则你应该读到最后再确定。\n 如图，自 Xcode 11 之后，基本的 Single View App 模板为我们提供以下内容:\n AppDelegate.swift  这个文件负责监视外部事件。例如，如果另一个应用程序试图向您发送要打开的文件。  SceneDelegate.swift  这个文件负责管理应用程序的显示方式。例如让多个实例同时运行，或者当一个实例移动到后台时采取操作。  ContentView.swift  这个文件是我们的初始用户界面。如果这是一个 UIKit 项目，这个文件相当于是 Xcode 提供给我们的 ViewController 类。  Assets.xcassets  这个文件是项目的资产目录。存储着我们项目中使用的所有图像和颜色。  LaunchScreen.storyboard  这是应用加载时显示的屏幕。  Info.plist  这是一个属性列表文件，在本例中，它用于存储应用程序的系统级设置。例如，应该在 iOS 主屏幕的图标下面显示什么名称。  Preview content\n 一个名为 Preview content 的组，其中包含另一个名为 Preview Assests 的资产目录。   就是这样 - 这是一个令人愉快的少量代码和资源，这意味着我们可以在此基础上进行构建。\n我们真正关心的是 ContentView.swift， 事实上，这是唯一重要的部分。这是我们应用程序的主要功能，在这里我们可以立即开始尝试各种 SwiftUI 代码。\n首先，是什么让 ContentView.swift 显示在屏幕上？\n好吧，如果你还记得我说过 SceneDelegate.swift 负责管理应用程序的显示方式。那么，继续打开 SceneDelegate.swift，您会看到下面的代码:\nlet window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: ContentView()) self.window = window window.makeKeyAndVisible()  这段代码创建了一个新的 ContentView 实例（这是我们即将看到的主要功能），并将其放在 window 中，以便在屏幕上显示。它通过显示 ContentView 的第一个实例，可以有效地引导我们的应用程序，并从那里结束 - 你想做什么？\n打开 ContentView.swift ，让我们看看实际的 SwiftUI 代码。您应该看到这样的代码:\nimport SwiftUI struct ContentView : View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif  这不是很多代码，但它确实包含了大量代码。\n首先，请注意，ContentView 是一个结构体（struct）。熟悉 UIKit 的开发人员知道 - 我们从用户界面的所有值类型的不可变性和简单性中获益巨大！不熟悉 UIKit 的人\u0026hellip; 嗯，只是点头微笑 - 你从来不知道我们曾经的痛苦。\n其次，ContentView 符合 View 协议。你想在 SwiftUI 中显示的所有内容都需要符合 View，这实际上只意味着一件事: 你需要一个名为 body 的属性来返回某种 View。\n第三，body 的返回类型是 some View。some 关键字是在 Swift 5.1 中新增的，是一个名为 不透明返回类型（opaque return types） 的功能的一部分，在这种情况下，它的意思是 将返回某种视图，但 SwiftUI 不需要知道（或关心）什么。\n重要说明: 返回 some View 意味着 body 属性将返回符合 View 协议的内容。你不能返回很多东西或忘记返回任何东西 \u0026ndash; Swift 编译器将拒绝构建你的代码。要清楚，您的视图正文必须返回一个子视图。\n第四，body属性中有 Text(\u0026quot;hello world\u0026quot;)，它创建了文本内容为 “hello world”的标签。\n最后，在 ContentView 下面的是一个类似但不同的 struct，称为 ContentView_Previews。它不符合 View 协议，因为它专门用于在 Xcode 中显示 视图预览（Preview），而不是在真实 app 中显示在屏幕上。这就是为什么你会看到它在 #if DEBUG 和 #endif 之间 - 当我们的应用程序在调试环境中运行时，这段代码只构建在 *成品（finished product）*中，因为它在生产应用程序（Production app）中没有意义。\n我们很快就会更详细地看一下这些组件（components），但首先让我们看一下 Text 组件。\n","date":1563868318,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563868318,"objectID":"9d1b9da570681cca6df9924ec098df0b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","publishdate":"2019-07-23T15:51:58+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","section":"post","summary":"The introduction of SwiftUI project template","tags":["Text and image"],"title":"1.1 工程模板介绍","type":"post"}]