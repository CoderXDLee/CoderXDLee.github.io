[{"authors":["admin"],"categories":null,"content":" Avoiding Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","date":1564239599,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1564239599,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://coderxdlee.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":" Avoiding Knowledge Respect for knowledge Absorbing knowledge Master knowledge Spread knowledge  ","tags":null,"title":"M X","type":"authors"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 TextField 支持占位符文本，就像 UITextField 一样 \u0026ndash; 当 TextField 为空时在 TextField 中显示灰色文本。要么使用提示（”Enter your password“），要么显示一些示例数据。\n要设置 placeholder，请将其作为 TextField 初始化设置的一部分传入，如下所示:\nstruct ContentView : View { @State var emailAddress = \u0026quot;\u0026quot; var body: some View { TextField($emailAddress, placeholder: Text(\u0026quot;test@gmail.com\u0026quot;)) .textFieldStyle(.roundedBorder) .padding() } }  运行效果: 这将在 TextField 中显示占位文本 test@gmail.com，而 TextField 为空，但一旦用户在其中键入内容，占位文本就会消失。\n","date":1564239599,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564239599,"objectID":"0e3882801ea545ed88f41f5dee0dc56c","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/","publishdate":"2019-07-27T22:59:59+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/","section":"post","summary":" ","tags":["SwiftUI"],"title":"3.6_如何给TextField添加占位符","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的 TextField 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更愿意在 TextField 周围添加边框，以使其更清晰。 如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 .textFieldStyle(.roundedBorder) 修饰符，如下所示:\nstruct ContentView : View { @State var text = \u0026quot;\u0026quot; var body: some View { TextField($text, placeholder: Text(\u0026quot;Enter some text\u0026quot;)) .padding() .textFieldStyle(.roundedBorder) } }  运行效果: ","date":1564238554,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564238554,"objectID":"c5921d17d28e606592038104bf6e7930","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/","publishdate":"2019-07-27T22:42:34+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/","section":"post","summary":"SwiftUI 的 TextField 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更愿意在 TextField 周围添加边框，以使其更清晰。 如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 .textFieldStyle(.roundedBorder) 修饰符，如下所示:\nstruct ContentView : View { @State var text = \u0026quot;\u0026quot; var body: some View { TextField($text, placeholder: Text(\u0026quot;Enter some text\u0026quot;)) .padding() .textFieldStyle(.roundedBorder) } }  运行效果: ","tags":["SwiftUI"],"title":"3.5_如何给TextField添加边框","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 简介 SwiftUI 的 TextField 视图类似于 UIkit 中的 UITextField，但是，在默认情况下 TextField 看起来有点不同，并且它非常依赖于 状态绑定（binding to state）。\n2. 创建 TextField 那么，要创建一个 TextField，我们应该给在 text field 传入一个 placeholder，再加上它应该绑定到的状态属性。\n例如: 现在，我们要创建一个 绑定到本地字符串的 TextField，然后在其下面放置一个文本视图，在键入时显示 TextField 的输出:\nstruct ContentView : View { @State var name = \u0026quot;Devin\u0026quot; var body: some View { VStack { TextField($name, placeholder: Text(\u0026quot;Enter your name\u0026quot;)) Text(\u0026quot;Hello, \\(name)\u0026quot;) } } }  运行后，您应该能够在 TextField 中键入内容，并看到下面直接显示一条问候语。 运行效果: 提示: 在 beta1 和 beta2 中，应该改用 TextField($name)。 使用 TextField 时有两个重要的限制条件。首先，默认情况下，它没有边框，因此你可能看不到任何内容 \u0026ndash; 你需要大致点击其所在位置，以激活键盘。 其次，您可能会发现无法在布局的画布预览中键入内容。如果遇到这个问题，请按Cmd+R在模拟器中构建和运行代码。\n","date":1564234941,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564234941,"objectID":"bc2d48638948cb5663d60f788ef39370","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/","publishdate":"2019-07-27T21:42:21+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/","section":"post","summary":" ","tags":["SwiftUI"],"title":"3.4_如何从TextField中读取文本","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. Button vs UIButton SwiftUI 的 按钮(Button) 类似于 UIKit 中的 UIButton，跟 UIButton 的区别在于:\n 在显示内容方面 SwiftUI 的按钮更为灵活 SwiftUI 的按钮使用 闭包 来实现其 action，而 UIButton 使用的是 target/action 系统  2. Button 初体验 那么，如何创建一个 SwiftUI 的按钮呢?，我们可以从以下代码开始:\nButton(action: { // your action here }) { Text(\u0026quot;Button title\u0026quot;) }  由以上代码可以看到，创建 Button 的的方法有两个参数，都是闭包，第一个闭包负责传入 action，第二个闭包负责传入按钮上的文本。\n3. Button 简单用例 例如: 我们可以创建一个按钮，在点击按钮时显示或隐藏一些详细信息:\nstruct ContentView : View { @State var showDetails = false var body: some View { VStack { Button(action: { self.showDetails.toggle() }) { Text(\u0026quot;Show detail information\u0026quot;) } if showDetails { Text(\u0026quot;You should follow me on M X Website\u0026quot;) .font(.largeTitle) .lineLimit(nil) } } } }  运行效果: 4. 提示 在学习框架时最常做的事情是分散调用 print()，这样我们就可以看到什么时候发生了什么事情。 如果我们想通过按钮 action 来尝试，首先应右键单击预览画布中的播放按钮，然后选择 调试预览，以便调用 print() 工作。 按钮内的标题可以是任何类型的视图，因此您可以创建这样的图像按钮:\nButton(action: { self.showDetails.toggle() }) { Image(\u0026quot;example-image\u0026quot;) }  运行效果: ","date":1564215682,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564215682,"objectID":"d20c00144e66723398bd9ac6d31dff6c","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/","publishdate":"2019-07-27T16:21:22+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/","section":"post","summary":" ","tags":["SwiftUI"],"title":"3.3_如何创建一个可点击的按钮","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 中的 toggle 允许用户在 true 和 false 之间移动，就像 UIKit 中的 UISwitch 一样。\n例如:\n我们可以创建一个 toggle ，然后根据 toggle 是否启动来决定显示或者不显示消息。但是我们不希望手动跟踪 toggle 的状态 \u0026ndash; 我们希望 SwiftUI 为我们做这件事。 与以往不同，在这里，我们应该定义一个 @State Boolean 属性，用于存储 toggle 的当前值。然后我们可以使用它来显示或隐藏其它视图。\n例如:\nstruct ContentView : View { @State var showGreeting = true var body: some View { VStack { Toggle(isOn: $showGreeting) { Text(\u0026quot;Show welcome message!\u0026quot;) }.padding() if showGreeting { Text(\u0026quot;Hello world\u0026quot;) } } } }  运行效果: 这段代码，只有当 showGreeting 为 true 时才会返回文本视图，这意味着当 showGreeting 为 false 时，VStack 的大小会减小 - 它的堆栈中没有第二个视图。\n","date":1564214142,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564214142,"objectID":"3c1e66f81817090b3b3c051810d18775","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/","publishdate":"2019-07-27T15:55:42+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/","section":"post","summary":"SwiftUI 中的 toggle 允许用户在 true 和 false 之间移动，就像 UIKit 中的 UISwitch 一样。\n例如:\n我们可以创建一个 toggle ，然后根据 toggle 是否启动来决定显示或者不显示消息。但是我们不希望手动跟踪 toggle 的状态 \u0026ndash; 我们希望 SwiftUI 为我们做这件事。 与以往不同，在这里，我们应该定义一个 @State Boolean 属性，用于存储 toggle 的当前值。然后我们可以使用它来显示或隐藏其它视图。\n例如:\nstruct ContentView : View { @State var showGreeting = true var body: some View { VStack { Toggle(isOn: $showGreeting) { Text(\u0026quot;Show welcome message!\u0026quot;) }.padding() if showGreeting { Text(\u0026quot;Hello world\u0026quot;) } } } }  运行效果: 这段代码，只有当 showGreeting 为 true 时才会返回文本视图，这意味着当 showGreeting 为 false 时，VStack 的大小会减小 - 它的堆栈中没有第二个视图。","tags":["SwiftUI"],"title":"3.2_如何创建拨动开关","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 概念 所有应用程序都会改变状态。\n例如:\n 用户可能点击了一个按钮来显示更多信息 用户可能已经在文本框中输入了一些文本 用户从日期选择器中选择了一个日期  所有涉及应用程序 从一种状态转变到另一种状态 的事情，都叫做应用程序改变状态。\n2. 问题所在 状态的问题在于它是混乱的: 当它发生变化时，我们需要发现变化并更新我们的布局来匹配变化。 这个一开始听起来可能很简单，但是随着我们的状态的不断增长，它就会变得越来越难 - 因为这个时候，我们很容易忘记更新一件事，或者更新顺序出错，以致于用户界面状态达不到预期效果。\n3. SwiftUI 如何破解？ SwiftUI 通过 从控件中移除状态 来解决这个问题。\n当我们向视图添加属性时，这些属性实际上是惰性的 - 当然，它们有值，但是更改这些值并不会做任何事情。 但是如果我们在这些属性之前添加了特殊的@State 来包装属性，SwiftUI将自动监视属性变化并更新使用该属性的视图的任何部分。\n示例代码:\n@state var name: String = \u0026quot;\u0026quot;   注意: @state 这种语法称为 属性包装器，这里不作详细介绍，可以自行查找文档。\n 当涉及到某种状态时 - 例如，当切换开关（toggle switch）改变时告诉状态属性改变。 这里需要注意的是: 我们不能直接引用这个属性属性。这是因为 Swift 会认为我们现在所指的是\u0026quot;属性当前的值\u0026quot;，而不是说 \u0026quot;请注意这件事情(属性状态变化)\u0026quot;。幸运的是，SwiftUI 的解决方案是在属性名称前放置一个美元符号($)，这样的话，我们就可以引用属性本身而不是它当前的值。\n 当然，这里一开始理解起有点令人困惑，但在当我们学习一两个示例之后就会理解，非常简单。\n 最后，请记住，SwiftUI 是声明性的，这意味着我们预先告诉它所有可能状态的所有布局，并让它知道当属性发生变化时如何在它们之间移动。我们称之为 绑定（binding） - 要求 SwiftUI 同步UI控件和底层属性之间的更改。 如果你已经习惯了一种更为迫切的编程风格，那么使用 state 一开始会让你头疼一些，但不要担心 - 一旦你完成了它，你就很明确了。\n","date":1564152499,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564152499,"objectID":"60ad908be8392124a7932d32de1fad67","permalink":"https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/","publishdate":"2019-07-26T22:48:19+08:00","relpermalink":"/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/","section":"post","summary":" ","tags":["SwiftUI"],"title":"3.1_使用 state","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"默认情况下，我们的 SwiftUI 视图将主要位于安全区域内 - 它将会到达屏幕底部，但不会靠近设备顶部的任何凹口。 如果我们想改变它 - 想让视图真正全屏，即使这意味着被一个缺口或其他硬件切口部分遮挡 - 那么我们应该使用 edgesIgnoringSafeArea() 修饰符。 例如，这会创建一个红色文本视图，要求填充所有可用空间，然后将其设置为忽略任何安全区域，以使其真正边缘到边缘。\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity) .background(Color.red) .edgesIgnoringSafeArea(.all) }  运行效果: ","date":1564150370,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564150370,"objectID":"2d7ef1463d807d926bce34ac48fcf79f","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/","publishdate":"2019-07-26T22:12:50+08:00","relpermalink":"/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.8_如何将视图放到安全区域之外","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 通过在环境中暴露 size classes 来原生支持它。如果要使用它，我们首先需要创建一个 @Environment 对象来存储其值，如下所示:\n@Environment(\\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?  然后在我们需要时检查该属性的值，查找 .compact 或 .regular，如下所示:\nif horizontalSizeClass == .compact { return Text(\u0026quot;Compact\u0026quot;) } else { return Text(\u0026quot;Regular\u0026quot;) }  将所有代码组合在一起，可以创建这样的视图:\nstruct ContentView: View { @Environment(\\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass? var body: some View { if horizontalSizeClass == .compact { return Text(\u0026quot;Compact\u0026quot;) } else { return Text(\u0026quot;Regular\u0026quot;) } } }  运行效果:\n(1) 正向竖屏 (2) 横屏 - 刘海在右侧 (3) 横屏 - 刘海在左侧 ","date":1564131137,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564131137,"objectID":"b019851a2ebb1462e1c5b879efc221ee","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/","publishdate":"2019-07-26T16:52:17+08:00","relpermalink":"/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.7_如何使用size_classes创建不同的布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 我们通常会发现，我们需要循环一个序列来创建视图，而在 SwiftUI 中，这是通过 ForEach 来完成的。\n重要提示: 我们很容易一看到 ForEach 就认为它与 Swift 序列中的 forEach() 方法相同，但事实并非如你所见。\n SwiftUI 中的 ForEach 本身是一个视图结构，这就意味着我们可以根据需要直接从视图 Body 返回它。 我们为它提供一系列项目，可能还需要告诉 SwiftUI 它如何唯一地标识每个项目，以便 SwiftUI 知道如何在值更改时更新它们。 我们还传递一个要运行的闭包，来为循环中的每个项创建一个视图。 对于范围内的简单循环，您可以将范围直接传递给ForEach。  1. 循环 1\u0026hellip;10 创建文本视图 例如，这从10减少到1然后在最后添加一条消息：\nvar body: some View { VStack(alignment: .leading) { ForEach((1...10).reversed()) { Text(\u0026quot;\\($0)…\u0026quot;) } Text(\u0026quot;Ready or not, here I come!\u0026quot;) } }  运行效果: 2. ForEach colors 对于简单类型数组（如字符串、整数、颜色等）的循环，可以在数组上使用 .identified(by: \\.self)，让 SwiftUI 使用值本身作为标识符。因此，如果您的数组是 [\u0026quot;cat\u0026quot;, \u0026quot;Dog\u0026quot;, \u0026quot;monkey\u0026quot;]，那么 SwiftUI 会将这些字符串本身作为您的视图的标识符。 因此，此代码创建一个包含三种颜色的数组，在它们上面循环，并使用每个颜色名称和颜色值创建文本视图：\nlet colors: [Color] = [.red, .green, .blue] var body: some View { VStack { ForEach(colors.identified(by: \\.self)) { color in Text(color.description.capitalized) .padding() .background(color) } } }  运行效果: 3. ForEach custom type 如果您的数组中有自定义类型，则应使用 .identified(by:) 与您的类型中的任何属性唯一标识它。 例如，这是一个存储测试结果的结构，如下所示：\nstruct Result { var id = UUID() var score: Int }  它有一个带有 UUID 的 id 属性，这意味着它保证是唯一的 - 完美的用于我们的目的。 如果我们想循环一个结果数组，创建一个显示 VStack 中每个结果的文本视图，那么我们将使用它：\nlet results = [Result(score: 8), Result(score: 5), Result(score: 10)] var body: some View { VStack { ForEach(results.identified(by: \\.id)) { result in Text(\u0026quot;Result: \\(result.score)\u0026quot;) } } }  运行效果: 这告诉 SwiftUI 它可以通过查看它们的 id 属性来区分 ForEach 中的视图。 提示：如果您使 Result 符合 Identifiable protocol，您只需编写 ForEach（Result）。 符合此协议意味着添加唯一标识每个对象的 id 属性，在我们的示例中我们已经拥有，因此您只需编写 struct Result：Identifiable {！\n","date":1564071700,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564071700,"objectID":"44f7c36133de110ed7eedcbf7f02adf5","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/","publishdate":"2019-07-26T00:21:40+08:00","relpermalink":"/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.6_如何使用ForEach在循环中创建视图","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 当我们从视图的 body 返回 some View 的时候，Swift 理解这意味着我们有一个特定的返回类型。\n例如: 如果我们想掷硬币并显示 \u0026ldquo;你赢了!\u0026ldquo;，但是我们不能这样写: 要么返回一个 Image，要么返回一个 Text，写着 \u0026ldquo;下次祝你好运\u0026rdquo;:\nvar body: some View { if Bool.random() { Image(\u0026quot;example-image\u0026quot;) } else { Text(\u0026quot;Better luck next time\u0026quot;) } }  这段代码会报错: 因为它可能返回 Image 或者 Text ，这是不允许的 \u0026ndash; 我们必须精确返回一种类型。 有两种方法可以解决这个问题。\n1. Group 第一种方法是将输出包装在一个 group 中，这样无论我们发送图像视图还是文本视图，它们都将返回到一个 group 中:\nvar body: some View { Group { if Bool.random() { Image(\u0026quot;example-image\u0026quot;) } else { Text(\u0026quot;Better luck next time\u0026quot;) } } }  运行效果: 2. AnyView 第二种方法，SwiftUI 提供了一个名为 AnyView 的类型，我们可以返回这种类型:\nvar body: AnyView { if Bool.random() { return AnyView(Image(\u0026quot;example-image\u0026quot;)) } else { return AnyView(Text(\u0026quot;Better luck next time\u0026quot;)) } }  如果你还没有听说过这个概念，它会强制让 Swift 忘记 AnyView 中包含的特定类型，让它们看起来像是一样的东西。但这有性能成本，所以不要经常使用它。 尽管 Group 和 AnyView 都为我们的布局实现了相同的结果，但通常最好使用 Group，因为它对 SwiftUI 更有效。\n","date":1564033641,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564033641,"objectID":"8060bb86f12304582ea806ac36436683","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/","publishdate":"2019-07-25T13:47:21+08:00","relpermalink":"/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.5_如何返回不同的视图类型","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 有一个专用的 stack 类型，用于创建重叠内容，例如，如果我们想在图片上放置一些文本，它就很有用。它被称为 ZStack，其工作原理与其他两种 stack 类型相同。\n1. 在文本下面放置图片 例如: 我们可以在如下文本下面放置一个大图像:\nvar body: some View { ZStack() { Image(\u0026quot;example-image\u0026quot;) Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background(Color.black) .foregroundColor(.white) } }  运行效果: 2. 对齐 与其它 stack 类型一样，ZStack 也可以设置对齐方式，这样它就不会总是将事物置于自身的中心位置:\nvar body: some View { ZStack(alignment: .leading) { Image(\u0026quot;example-image\u0026quot;) .resizable() .aspectRatio(contentMode: .fit) Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background(Color.black) .foregroundColor(.white) } }  运行效果: 但是，它没有 spacing 属性，因为它实际上没有意义。\n","date":1564032412,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564032412,"objectID":"a7bfae9c2de4a6e9a4edd2f9b2c4c6d9","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/","publishdate":"2019-07-25T13:26:52+08:00","relpermalink":"/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.4_如何使用ZStack将视图叠加在一起","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 允许我们使用 padding() 修饰符在视图周围设置单独的填充。\n1. 系统默认 padding 如果在不传参数的情况下使用 padding() ，您将在所有边上获得系统默认填充，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里默认设置了视图四周的填充。\n2. 只设置一侧系统默认 padding 我们也可以自定义要 apply 的 padding 和位置。因此，我们只希望将系统填充应用于一侧:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 注意: 这里只设置了底部填充，与上面的例子不同。\n3. 用具体数值来设置 padding 我们可能希望控制对所有边应用了多少填充:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 4. 在视图一侧添加特定数量的填充 我们也可以将这两者结合起来，在视图的一侧添加特定数量的填充：\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) .padding(.bottom, 100) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564025985,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564025985,"objectID":"e4177bc07a2849e3ab458ab3bb0941b0","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","publishdate":"2019-07-25T11:39:45+08:00","relpermalink":"/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.3_如何使用padding控制单个视图周围的间距","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. spacing 我们可以通过在 SwiftUI stacks 的构造方法中填一个值来设置间距，如下所示:\nvar body: some View { VStack(spacing: 50) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 2. Divider 我们可以在项目之间创建分隔符，以便 SwiftUI 在 stack 中的每个项目之间进行小的视觉区分，如下所示:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Divider() Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 3. alignment 默认情况下，stacks 中的项目居中对齐。\n 在 HStack 中: 项目在中间垂直对齐，因此如果有两个不同高度的文本视图，它们都将与垂直中心对齐。 在 VStack 中: 项目在中间水平对齐，因此如果有两个长度不同的文本视图，它们都将与水平中心对齐。  要调整这种情况，请在创建 stack 时按以下方式传递一个 alignment 参数:\nvar body: some View { VStack(alignment: .leading) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使 Hello SwiftUI 和 Hello M X 左对齐，但它们最终将位于屏幕的中间，因为 stack 只占用所需的空间。\n4.同时设置 alignment 和 spacing 我们可以同时使用 alignment 和 spacing ，如下所示:\nvar body: some View { VStack(alignment: .leading, spacing: 20) { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 这将使两个文本视图水平对齐到 leading（对于从左到右的语言是左对齐），并在它们之间放置20个点的垂直间距。\n","date":1564023292,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564023292,"objectID":"294ef00070d5dc7a12b85b39352a4f69","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","publishdate":"2019-07-25T10:54:52+08:00","relpermalink":"/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.2_如何通过alignment和spacing自定义stack布局","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 的内容视图 content views 必须返回一个视图，即我们希望它们显示的视图。当我们想要一次在屏幕上显示多个视图时，我们需要告诉 SwiftUI 如何排列它们，这就是 堆栈（stacks）的来源。\n堆栈（Stacks） 相当于 UIKit 中的 UIStackView 。有三种形式:\n 水平（HStack） 垂直（VStack） 基于深度（ZStack）  当我们想放置子视图以便它们重叠时可以使用后者。\n1. VStack 让我们从一些简单的事情开始，先创建一个文本视图:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) }  运行效果: 有了一个文本视图，如果我们想在下面再写一个，我们不能只写:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) Text(\u0026quot;Hello M X\u0026quot;) }  这样的话，编译器会直接报错。 记住，我们只能返回一个视图，否则代码就不会工作。\n那么怎么办呢？我们需要将其放置在 VStack 中，以便将文本视图放置在彼此上方:\nvar body: some View { VStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: 您会注意到 VStack 放置在屏幕的中心，标签也居中，它们之间有一些自动空间。\n2. HStack 如果我们希望文本视图并排水平放置，请使用如下方式将 VStack 替换为 HStack:\nvar body: some View { HStack { Text(\u0026quot;Hello SwiftUI\u0026quot;) .background(Color.red) Text(\u0026quot;Hello M X\u0026quot;) .background(Color.blue) } }  运行效果: ","date":1564020650,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564020650,"objectID":"25808207349efed761b6e8e414a439c6","permalink":"https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","publishdate":"2019-07-25T10:10:50+08:00","relpermalink":"/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/","section":"post","summary":" ","tags":["SwiftUI"],"title":"2.1_如何使用VStack和HStack创建stacks","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 我们可以使用相同的 background() 修饰符来设置背景图像，而不是设置背景颜色。\n1. 给文本视图设置图像背景 例如: 现在，我们要创建一个大字体的文本视图，然后在其后面放置一个 100x100 的图像:\nvar body: some View { Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Image(\u0026quot;example-image\u0026quot;) .resizable() .frame(width: 100, height: 100) ) } }  运行效果: 2. 给文本视图设置一个红色圆圈作为背景 在 SwiftUI 中，背景 View 并不一定是一个图像，实际上我们可以使用任何类型的视图作为背景。 例如: 现在将创建相同的文本视图，然后在其后面放置一个 200x200 的红色圆圈:\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) ) }  默认情况下，背景视图会自动占用尽可能多的空间以完全可见，但如果需要，可以使用 clipped() 修饰符将其剪裁为父视图的大小：\nvar body: some View { // 红色圆圈作背景 Text(\u0026quot;Hello SwiftUI\u0026quot;) .font(.largeTitle) .background( Circle() .fill(Color.red) .frame(width: 200, height: 200) .clipped() ) }  运行效果: 明确地说，您可以使用任何视图作为背景，例如，如果需要，可以使用另一个文本视图。\n","date":1563954389,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954389,"objectID":"d77a54ad5e70c0e354963d33db9f8afa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","publishdate":"2019-07-24T15:46:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.9_如何使用图像和其它视图作为背景","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 如果我们想在应用程序中使用简单地几何形状，我们可以直接创建它们，然后根据需要对它们进行着色和定位。\n1. 矩形 例如，如果我们想要一个 200x200 红色矩形，可以使用如下代码:\nvar body: some View { Rectangle() .fill(Color.red) .frame(width: 200, height: 200) }  运行效果: 2. 圆 同样，如果你想要一个 50x50 的蓝色圆圈，您可以使用如下代码:\nvar body: some View { Circle() .fill(Color.blue) .frame(width: 50, height: 50) }  运行效果: ","date":1563954361,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954361,"objectID":"6bb26cdc2adaf8cb830077b8110d51aa","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","publishdate":"2019-07-24T15:46:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.8_如何显示几何形状","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 为我们提供了各种渐变选项（gradient options），所有这些选项都可以以各种方式来使用。例如:\n1. 垂直线性渐变 我们使用从白色到黑色的线性渐变来渲染文本视图，如下所示:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 颜色被指定为一个数组，我们可以设置任意多我们想要的颜色 - 默认情况下，SwiftUI 将会平均分配这些颜色。所以，我们也可以这样从 白色 -\u0026gt; 红色 -\u0026gt; 黑色 来设置:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0) }  运行效果: 2. 水平线性渐变 要实现一个水平渐变（a horizontal gradient）而不是一个垂直渐变（a vertical one），使用 .leading 和 .trailing 来作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .leading, endPoint: .trailing), cornerRadius: 0) }  运行效果: 3. 对角线线性渐变 要实现对角线渐变，可以使用 .topLeading 和 .bottomTrailing 作为 startPoint 和 endPoint:\nvar body: some View { Text(\u0026quot;Hello World\u0026quot;) .padding() .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .topLeading, endPoint: .bottomTrailing), cornerRadius: 0) }  运行效果: ","date":1563954329,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954329,"objectID":"b89862110d29df1cb2a98f4fee3a3c1b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","publishdate":"2019-07-24T15:45:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.7_如何渲染渐变","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" SwiftUI 的 Image 能够以不同的方式进行缩放，就像 UIImageView 的 content mode 一样。\n1.默认 默认情况下，图像视图会自动调整其内容的大小，这可能会使它们超出屏幕。\nImage(\u0026quot;ba_xian_tai\u0026quot;)  运行效果: 如果添加了 resizable() 修饰符，则图像将自动调整大小，以填充所有可用空间:\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable()  运行效果: 然而，这也可能导致图像的原始纵横比失真，因为它将在所有维度上被拉伸任意数量，以使其填充空间。\n2. .fill 和 .fit 如果要保持其纵横比，应使用 .fill 或 .fit添加一个aspectRatio()修饰符，如下所示：\nImage(\u0026quot;ba_xian_tai\u0026quot;) .resizable() .aspectRatio(contentMode: .fill)  运行效果: 注意: 在当前的测试版中，有一个bug，.fit 内容模式仍然会导致图像被拉伸。\n","date":1563954307,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954307,"objectID":"cf6ffdbb1c994faad0b4746884cab952","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","publishdate":"2019-07-24T15:45:07+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.6_如何调整图像视图的填充模式","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 使用图像视图 Image 可以在 SwiftUI 布局中渲染图像（images）。我们可以从 Bundle、System icons、UIImage 等中加载图像，但这三个将是最常见的。\n1. 从 Bundle 加载 要从 Bundle 中加载图像并将其显示在图像视图中，只需使用以下代码:\nvar body: some View { Image(\u0026quot;example-image\u0026quot;) }  运行效果: 2. 从 System icons 加载 要从苹果旧金山符号集(Apple’s San Francisco Symbol set)中加载图标，请使用 Image(systemName: ) 初始化器，传入图标字符串进行加载，如下所示:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;)  运行效果: 3. 从 UIImage 加载 最后，可以从现有的 UIImage 创建一个图像视图。因为这需要更多的代码，所以需要显式地使用 return 关键字。\nguard let image = UIImage(named: \u0026quot;example-image\u0026quot;) else { fatalError(\u0026quot;Unable to load image\u0026quot;) } return Image(uiImage: image)  运行效果: 4. foregroundColor 如果你使用的是 系统图标集，则返回的图像是 可缩放 和 可着色 的，这意味着你可以使用 foregroundColor() 修改器对图像着色。\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .foregroundColor(.red)  运行效果: 5. 动态文本样式 这意味着你可以通过匹配任何 Dynamic Type 文本样式，来要求 SwiftUI 放大图像:\nImage(systemName: \u0026quot;cloud.heavyrain.fill\u0026quot;) .font(.largeTitle)  运行效果: ","date":1563954255,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954255,"objectID":"bcd80c540133b4c4f850d3403d4e3377","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","publishdate":"2019-07-24T15:44:15+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.5_如何使用图像视图绘制图像","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":"SwiftUI 的文本视图有一个可选的 formatter 参数，可以让我们用来自定义数据在标签（label）内的显示方式。这一点很重要，因为在我们的程序中发生某些事情时，通常会为我们更新值，因此通过附加 formatter， SwiftUI 可以确保我们的数据以我们期望的方式来正确显示。\n例如，这定义了一个日期格式（date formatter）化程序，并使用它来确保 任务日期 以人类可读的形式显示:\nimport SwiftUI struct ContentView : View { static let taskDateFormatter: DateFormatter = { let formatter = DateFormatter() formatter.dateStyle = .long return formatter }() var dueDate = Date() var body: some View { Text(\u0026quot;Task due date: \\(dueDate, formatter: Self.taskDateFormatter)\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif  运行效果: ","date":1563954209,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954209,"objectID":"c122de324e0c11ab95cb0738749a23d0","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","publishdate":"2019-07-24T15:43:29+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.4_如何格式化文本视图中的文本","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 文本视图不仅在外观方面给了我们一个可预见的广泛控制，而且还设计成与苹果的核心技术（如 Dynamic Type）无缝配合。\n1. 字体 默认情况下，文本视图有一个 Body 动态类型样式，但是我们可以通过以下方式调用 .font()，从其它 sizes 和 weights 进行选择:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle)  运行效果: 我们现在在文本视图下面使用了两个修饰符，这没关系 - 你可以将它们堆叠起来，并且它们都会生效。\n2. 文本对齐 特别是，现在我们有多行文本，我们需要调整文本的对齐方式，使其居中，如下所示:\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .multilineTextAlignment(.center)  运行效果: 3. 字体颜色 我们可以通过 .foregroundColor() 修饰符来设置文本颜色，如下所示:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red)  运行效果: 4. 背景 我们可以使用 .background() 来设置背景颜色，但是它不仅仅可以用来设置背景颜色，也可以设置背景视图。无论如何，为了给我们的文本视图设置一个黄色背景，代码如下:\nText(\u0026quot;The best laid plans\u0026quot;) .foregroundColor(Color.red) .background(Color.yellow)  运行效果: 5. 行间距 我们可以设置多行文本的行间距，行间距默认值为0，表示没有额外的行间距，但是我们可以通过以下方式在行与行之间指定一个值来添加额外的行间距。\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones\u0026quot;) .lineLimit(nil) .font(.largeTitle) .lineSpacing(50)  运行效果: ","date":1563954148,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563954148,"objectID":"8be44a51185d5c70ca4c4bc7d2fb462d","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","publishdate":"2019-07-24T15:42:28+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.3_如何使用字体颜色行距等设置文本视图的样式","type":"post"},{"authors":["M X"],"categories":["SwiftUI"],"content":" 1. 基本用法 文本视图 Text 主要用于在屏幕上显示静态文本，相当于 UIKit 中的 UILabel。最基本的用法如下:\nText(\u0026quot;Hello world\u0026quot;)  在内容视图的预览窗口中，您可能会看到 Automatic preview updating paused， 继续按 Resume 以让 Swift 开始构建代码并向您展示其外观的实时预览。\n2. 设置显示行数 默认情况下，Text 只显示一行 - 如果空间不足，字符将被剪切并替换为 ...。因此如果我们要显示的文本很长，就会看到这种情况发生。如果要改变这种行为 - 比如你希望 Text 可以显示多行文本，那么可以这样做，使其具有特定的行数:\nText(\u0026quot;Hello world\u0026quot;) .lineLimit(3)   提示: 请注意 lineLimit(3) 位于 Text(\u0026quot;Hello World\u0026quot;) 下方靠右侧的方式。这不是必需的，但它确实使您的代码更易于阅读。\n 或者，可以将 nil 指定给 lineLimit() 方法，该方法允许它根据需要运行在任意多行:\nText(\u0026quot;Hello World\u0026quot;) .lineLimit(nil)   注意: 这里设置 lineLimit(0) 不能实现多行显示，这一点跟 UIKit 中是不一样的。\n 3. 文本截断 我们也可以调整 SwiftUI 截断文本的方式，而不是调整行数。默认情况下，从末尾删除文本并显示省略号，但也可以将省略号放在中间或开头，具体取决于字符串各个部分的重要程度。\n例如: 以下代码会在中间截断文本\nText(\u0026quot;This is an extremely long string that will never fit even the widest of Phones.\u0026quot;) .truncationMode(.middle)  不管我们如何截断文本，我们将看到文本视图始终位于主视图（main view）的中心。这是 SwiftUI 的默认行为 \u0026ndash; 除非我们明确告诉 SwiftUI 将视图定位到其他位置，否则 SwiftUI 会将视图定位到相对于屏幕中心的位置。\n","date":1563946501,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563946501,"objectID":"c8de0192120507accbd6cb1c301d2f14","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","publishdate":"2019-07-24T13:35:01+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/","section":"post","summary":" ","tags":["SwiftUI"],"title":"1.2 如何使用文本视图创建静态标签","type":"post"},{"authors":["M X"],"categories":["SwfitUI"],"content":" 提示: 您可能认为本章完全可以跳过，但除非你是一个 Swift 天才，否则你应该读到最后再确定。\n 如图，自 Xcode 11 之后，基本的 Single View App 模板为我们提供以下内容:\n AppDelegate.swift  这个文件负责监视外部事件。例如，如果另一个应用程序试图向您发送要打开的文件。  SceneDelegate.swift  这个文件负责管理应用程序的显示方式。例如让多个实例同时运行，或者当一个实例移动到后台时采取操作。  ContentView.swift  这个文件是我们的初始用户界面。如果这是一个 UIKit 项目，这个文件相当于是 Xcode 提供给我们的 ViewController 类。  Assets.xcassets  这个文件是项目的资产目录。存储着我们项目中使用的所有图像和颜色。  LaunchScreen.storyboard  这是应用加载时显示的屏幕。  Info.plist  这是一个属性列表文件，在本例中，它用于存储应用程序的系统级设置。例如，应该在 iOS 主屏幕的图标下面显示什么名称。  Preview content\n 一个名为 Preview content 的组，其中包含另一个名为 Preview Assests 的资产目录。   就是这样 - 这是一个令人愉快的少量代码和资源，这意味着我们可以在此基础上进行构建。\n我们真正关心的是 ContentView.swift， 事实上，这是唯一重要的部分。这是我们应用程序的主要功能，在这里我们可以立即开始尝试各种 SwiftUI 代码。\n首先，是什么让 ContentView.swift 显示在屏幕上？\n好吧，如果你还记得我说过 SceneDelegate.swift 负责管理应用程序的显示方式。那么，继续打开 SceneDelegate.swift，您会看到下面的代码:\nlet window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: ContentView()) self.window = window window.makeKeyAndVisible()  这段代码创建了一个新的 ContentView 实例（这是我们即将看到的主要功能），并将其放在 window 中，以便在屏幕上显示。它通过显示 ContentView 的第一个实例，可以有效地引导我们的应用程序，并从那里结束 - 你想做什么？\n打开 ContentView.swift ，让我们看看实际的 SwiftUI 代码。您应该看到这样的代码:\nimport SwiftUI struct ContentView : View { var body: some View { Text(\u0026quot;Hello World\u0026quot;) } } #if DEBUG struct ContentView_Previews : PreviewProvider { static var previews: some View { ContentView() } } #endif  这不是很多代码，但它确实包含了大量代码。\n首先，请注意，ContentView 是一个结构体（struct）。熟悉 UIKit 的开发人员知道 - 我们从用户界面的所有值类型的不可变性和简单性中获益巨大！不熟悉 UIKit 的人\u0026hellip; 嗯，只是点头微笑 - 你从来不知道我们曾经的痛苦。\n其次，ContentView 符合 View 协议。你想在 SwiftUI 中显示的所有内容都需要符合 View，这实际上只意味着一件事: 你需要一个名为 body 的属性来返回某种 View。\n第三，body 的返回类型是 some View。some 关键字是在 Swift 5.1 中新增的，是一个名为 不透明返回类型（opaque return types） 的功能的一部分，在这种情况下，它的意思是 将返回某种视图，但 SwiftUI 不需要知道（或关心）什么。\n重要说明: 返回 some View 意味着 body 属性将返回符合 View 协议的内容。你不能返回很多东西或忘记返回任何东西 \u0026ndash; Swift 编译器将拒绝构建你的代码。要清楚，您的视图正文必须返回一个子视图。\n第四，body属性中有 Text(\u0026quot;hello world\u0026quot;)，它创建了文本内容为 “hello world”的标签。\n最后，在 ContentView 下面的是一个类似但不同的 struct，称为 ContentView_Previews。它不符合 View 协议，因为它专门用于在 Xcode 中显示 视图预览（Preview），而不是在真实 app 中显示在屏幕上。这就是为什么你会看到它在 #if DEBUG 和 #endif 之间 - 当我们的应用程序在调试环境中运行时，这段代码只构建在 *成品（finished product）*中，因为它在生产应用程序（Production app）中没有意义。\n我们很快就会更详细地看一下这些组件（components），但首先让我们看一下 Text 组件。\n","date":1563868318,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563868318,"objectID":"9d1b9da570681cca6df9924ec098df0b","permalink":"https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","publishdate":"2019-07-23T15:51:58+08:00","relpermalink":"/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/","section":"post","summary":"The introduction of SwiftUI project template","tags":["SwiftUI"],"title":"1.1 工程模板介绍","type":"post"}]