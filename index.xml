<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>M X</title>
    <link>https://coderxdlee.github.io/</link>
    <description>Recent content on M X</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>M X ©{year}</copyright>
    <lastBuildDate>Tue, 06 Aug 2019 15:49:19 +0800</lastBuildDate>
    
	    <atom:link href="https://coderxdlee.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>10.16_如何将视图混合在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.16_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%B7%B7%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Tue, 06 Aug 2019 15:49:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.16_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%B7%B7%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;将一个视图放在另一个视图上时，可以使用 &lt;code&gt;blendMode()&lt;/code&gt; 修改器控制它们重叠的方式。 这包含多种可以将颜色混合在一起的方法，例如使用它们的差异或使用颜色刻录 - 如果您之前使用过 Core Graphics 或类似 Photoshop，这些方法会很熟悉。&lt;/p&gt;

&lt;p&gt;为了证明这一点，我们可以创建一个内部有两个图像的 &lt;code&gt;ZStack&lt;/code&gt; ，其中第二个具有 &lt;code&gt;.multiply&lt;/code&gt; 混合模式，以便使其后面的颜色变暗:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        ZStack {
            Image(&amp;quot;stripes&amp;quot;)
            Image(&amp;quot;example-image&amp;quot;)
                .blendMode(.multiply)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.16_blend.png&#34; alt=&#34;10.16_blend&#34; title=&#34;Blend two image view with multiply mode&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.15_如何模糊视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.15_%E5%A6%82%E4%BD%95%E6%A8%A1%E7%B3%8A%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 15:37:49 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.15_%E5%A6%82%E4%BD%95%E6%A8%A1%E7%B3%8A%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;blur()&lt;/code&gt; 修改器允许我们根据自己的选择对视图应用实时高斯模糊。&lt;/p&gt;

&lt;h3 id=&#34;2-给图像设置模糊&#34;&gt;2. 给图像设置模糊&lt;/h3&gt;

&lt;p&gt;例如: 下面代码会创建一个 &lt;code&gt;300x300&lt;/code&gt; 的个人资料图片，然后添加一个20点的高斯模糊:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Image(&amp;quot;avatar&amp;quot;)
            .resizable()
            .frame(width: 300, height: 300)
            .blur(radius: 20)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.15_blur_20_radius.png&#34; alt=&#34;10.15_blur_20_radius&#34; title=&#34;Set a blur for a image view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-给文本设置模糊&#34;&gt;3. 给文本设置模糊&lt;/h3&gt;

&lt;p&gt;我们可以模糊我们想要的任何内容，包括文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Welcome to my SwiftUI app&amp;quot;)
            .blur(radius: 2)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.15_set_blur_for_text.png&#34; alt=&#34;10.15_set_blur_for_text&#34; title=&#34;Set a blur for a text view&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.14_如何用另一个视图遮罩一个视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.14_%E5%A6%82%E4%BD%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E9%81%AE%E7%BD%A9%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 15:16:56 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.14_%E5%A6%82%E4%BD%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E9%81%AE%E7%BD%A9%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 为我们提供了 &lt;code&gt;mask()&lt;/code&gt; 修改器，用于将一个图像作为另一个视图的蒙版，这意味着我们可以使用文本来作为图像的蒙版，或使用图像作为图像的蒙版，或更多。&lt;/p&gt;

&lt;p&gt;例如，下面代码会创建一个 &lt;code&gt;300x300&lt;/code&gt; 的条纹图像，然后使用文本 &amp;ldquo;SWIFT!&amp;rdquo; 对其进行遮罩，以便字母充当图像的剪切区域:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Image(&amp;quot;stripes&amp;quot;)
            .resizable()
            .frame(width: 300, height: 300)
            .mask(
                Text(&amp;quot;SWIFT!&amp;quot;)
                    .font(Font.system(size: 72, weight: .black, design: .serif))
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.14_mask_image_with_text.png&#34; alt=&#34;10.14_mask_image_with_text&#34; title=&#34;Mask a image view with a text view&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.13_如何调整视图的强调色</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.13_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%B0%83%E8%89%B2/</link>
      <pubDate>Tue, 06 Aug 2019 14:35:43 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.13_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%B0%83%E8%89%B2/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;iOS 使用 &lt;code&gt;tints colors&lt;/code&gt; 为应用程序提供协调的主题，SwiftUI 中的 &lt;code&gt;accent colors&lt;/code&gt; 也提供了相同的功能。就像在 UIKit 中一样，当您设置一个视图的 &lt;code&gt;accent color&lt;/code&gt; 时，它会影响其中的所有内容，因此如果您设置顶级控件的 &lt;code&gt;accent color&lt;/code&gt;，那么一切都会变色。&lt;/p&gt;

&lt;p&gt;例如，下面代码会在 &lt;code&gt;VStack&lt;/code&gt; 中创建一个按钮，然后给它一个橙色的强调颜色:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Button(action: {}, label: {
                Text(&amp;quot;Tap here&amp;quot;)
            })
        }
        .accentColor(Color.orange)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.13_accent_color.png&#34; alt=&#34;10.13_accent_color&#34; title=&#34;Set accent color&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.12_如何调整视图的不透明度</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.12_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6/</link>
      <pubDate>Tue, 06 Aug 2019 14:19:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.12_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过 &lt;code&gt;opacity()&lt;/code&gt; 修改器，我们可以将任何 SwiftUI 视图设置成部分或全部透明。它接收 &lt;em&gt;0(完全不可见)&lt;/em&gt; 到 &lt;em&gt;1(完全不透明)&lt;/em&gt; 之间的值。就像 UIKit 中 &lt;code&gt;UIView&lt;/code&gt; 的 &lt;code&gt;alpha&lt;/code&gt; 属性一样。&lt;/p&gt;

&lt;p&gt;例如: 下面代码创建一个带有红色背景的文本视图，然后给它30％的不透明度:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Now you see me&amp;quot;)
            .padding()
            .background(Color.red)
            .opacity(0.3)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.12_opacity.png&#34; alt=&#34;10.12_opacity&#34; title=&#34;Set opacity is 0.3&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.11_如何给视图设置圆角</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</link>
      <pubDate>Tue, 06 Aug 2019 14:06:51 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过 &lt;code&gt;cornerRadius()&lt;/code&gt; 修改器，我们可以给任何 SwiftUI 视图设置圆角。这需要一个简单地值来限定如何明确地成圆。&lt;/p&gt;

&lt;p&gt;因此，我们可以创建一个25点圆角的文本视图，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Round me&amp;quot;)
            .padding()
            .background(Color.red)
            .cornerRadius(20)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.11_round_the_corner_25.png&#34; alt=&#34;10.11_round_the_corner_25&#34; title=&#34;Round the corner&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.10_如何向上或向下缩放视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.10_%E5%A6%82%E4%BD%95%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%E7%BC%A9%E6%94%BE%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 13:13:23 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.10_%E5%A6%82%E4%BD%95%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%E7%BC%A9%E6%94%BE%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI的 &lt;code&gt;scaleEffect()&lt;/code&gt; 修改器允许我们自由地增大或减小视图的大小。&lt;/p&gt;

&lt;h3 id=&#34;2-放大视图&#34;&gt;2. 放大视图&lt;/h3&gt;

&lt;p&gt;例如，我们可以将文本视图设置为常规大小的五倍，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .scaleEffect(5)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.10_scale_up_5.png&#34; alt=&#34;10.10_scale_up_5&#34; title=&#34;Make a text view five times its regular size&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-独立缩放xy&#34;&gt;3. 独立缩放XY&lt;/h3&gt;

&lt;p&gt;如果需要，可以独立缩放X和Y尺寸，从而可以挤压以下视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .scaleEffect(x: 1, y: 5)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.10_scale_x_y.png&#34; alt=&#34;10.10_scale_x_y&#34; title=&#34;Scale the X and Y dimensions independently&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-设置锚点&#34;&gt;4. 设置锚点&lt;/h3&gt;

&lt;p&gt;如果您想要更多控制，可以为此缩放指定锚点，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .scaleEffect(2, anchor: UnitPoint(x: 1, y: 1))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.10_scale_with_anchor.png&#34; alt=&#34;10.10_scale_with_anchor&#34; title=&#34;Specify an anchor&#34; /&gt;
这使得文本视图两倍于常规大小，从右下角缩放。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.9_如何在3D中旋转视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.9_%E5%A6%82%E4%BD%95%E5%9C%A83d%E4%B8%AD%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 12:38:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.9_%E5%A6%82%E4%BD%95%E5%9C%A83d%E4%B8%AD%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;rotation3DEffect()&lt;/code&gt; 修改器让我们可以在三维空间中旋转视图，几乎不需要任何代码就可以创建漂亮的效果。&lt;/p&gt;

&lt;p&gt;这个修改器接受两个参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;旋转的角度（以度或弧度为单位）。&lt;/li&gt;
&lt;li&gt;加上包含X，Y和Z轴的元组，围绕该轴执行旋转。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;: 如果你以前从未进行过三维旋转，那么你应该将X/Y/Z轴视为视图中的扦子。X轴是水平的，所以如果你在X轴上旋转，就像是在你的视图中放置一个水平的扦子 — 任何旋转都会使顶部或底部更近或更远，但不会调整前缘和后缘。&lt;/p&gt;

&lt;h3 id=&#34;2-围绕x轴旋转视图&#34;&gt;2. 围绕X轴旋转视图&lt;/h3&gt;

&lt;p&gt;因此，如果要围绕X轴将某些文本旋转45度（这将导致文本顶部比底部看得更远），可以编写以下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .foregroundColor(.yellow)
            .rotation3DEffect(.degrees(-45), axis: (x: 1, y: 0, z: 0))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.9_rotate_in_3D_x_axis.png&#34; alt=&#34;10.9_rotate_in_3D_x_axis&#34; title=&#34;Rotate a text by x axis in 3D&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.8_如何旋转视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.8_%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 11:16:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.8_%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI的 &lt;code&gt;rotationEffect()&lt;/code&gt; 修改器让我们可以使用度数或弧度自由旋转视图。&lt;/p&gt;

&lt;h3 id=&#34;2-使用角度旋转视图&#34;&gt;2. 使用角度旋转视图&lt;/h3&gt;

&lt;p&gt;例如，如果我们想将某些文本旋转-90度以使其向上读取，我们可以使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .rotationEffect(.degrees(-90))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_90_degree.png&#34; alt=&#34;10.8_rotate_90_degree&#34; title=&#34;Rotate a text by -90 degrees so that it reads upwards&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-使用弧度旋转视图&#34;&gt;3. 使用弧度旋转视图&lt;/h3&gt;

&lt;p&gt;如果我们更喜欢使用弧度，只需传入 &lt;code&gt;.radians()&lt;/code&gt; 作为参数，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .rotationEffect(.radians(.pi))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_pi.png&#34; alt=&#34;10.8_rotate_pi&#34; title=&#34;Using radians&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-使用滑块交互&#34;&gt;4. 使用滑块交互&lt;/h3&gt;

&lt;p&gt;视图旋转速度如此之快，以至于实际上是自由的，所以如果需要，甚至可以使用滑块进行交互:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var rotation: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $rotation, in: 0...360, step: 1) { _ in
                print(self.rotation)
            }
            Text(&amp;quot;Up we go&amp;quot;)
                .rotationEffect(.degrees(rotation))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_by_slider.gif&#34; alt=&#34;10.8_rotate_by_slider&#34; title=&#34;Rotate a view by a slider&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-设置旋转锚点&#34;&gt;5. 设置旋转锚点&lt;/h3&gt;

&lt;p&gt;默认情况下，视图围绕其中心旋转，但如果要从特定点固定旋转，则可以为其添加额外参数。 例如，如果你想让旋转器围绕视图的左上角旋转旋转，你可以这样写：&lt;/p&gt;

&lt;p&gt;默认情况下，视图围绕其中心旋转，但如果要从特定点固定旋转，可以为此添加一个额外参数。例如，如果要使上方的滑块围绕视图左上角旋转，可以编写以下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var rotation: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $rotation, in: 0...360, step: 1) { _ in
                print(self.rotation)
            }
            Text(&amp;quot;Up we go&amp;quot;)
                .rotationEffect(.degrees(rotation), anchor: UnitPoint(x: 0, y: 0))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_by_slider_with_anchor.gif&#34; alt=&#34;10.8_rotate_by_slider_with_anchor&#34; title=&#34;Rotate a text by slider with an anchor&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.7_如何剪裁视图使其只有部分可见</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.7_%E5%A6%82%E4%BD%95%E5%89%AA%E8%A3%81%E8%A7%86%E5%9B%BE%E4%BD%BF%E5%85%B6%E5%8F%AA%E6%9C%89%E9%83%A8%E5%88%86%E5%8F%AF%E8%A7%81/</link>
      <pubDate>Tue, 06 Aug 2019 11:01:10 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.7_%E5%A6%82%E4%BD%95%E5%89%AA%E8%A3%81%E8%A7%86%E5%9B%BE%E4%BD%BF%E5%85%B6%E5%8F%AA%E6%9C%89%E9%83%A8%E5%88%86%E5%8F%AF%E8%A7%81/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;通过使用 &lt;code&gt;clipShape()&lt;/code&gt; 修改器，SwiftUI允许我们剪切任何视图以控制其形状。&lt;/p&gt;

&lt;h3 id=&#34;2-创建圆形按钮&#34;&gt;2. 创建圆形按钮&lt;/h3&gt;

&lt;p&gt;例如: 下面的代码使用系统图像 &lt;code&gt;bolt.fill&lt;/code&gt; 创建一个按钮，给它一些填充和背景颜色，然后使用圆形剪裁它，以便我们得到一个圆形按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Button(action: {
            print(&amp;quot;Button tapped!&amp;quot;)
        }, label: {
            Image(systemName: &amp;quot;bolt.fill&amp;quot;)
                .foregroundColor(.white)
                .padding()
                .background(Color.green)
                .clipShape(Circle())
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.7_create_circle_button.png&#34; alt=&#34;10.7_create_circle_button&#34; title=&#34;Create a circle button&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Circle&lt;/code&gt; 剪辑形状将始终从视图中创建圆圈，即使它们的宽度和高度不相等 - 它只会裁剪较大的值以匹配较小的值。&lt;/p&gt;

&lt;h3 id=&#34;3&#34;&gt;3.&lt;/h3&gt;

&lt;p&gt;除了 &lt;code&gt;Circle&lt;/code&gt; 之外，还有 &lt;code&gt;Capsule&lt;/code&gt;，它可以看到圆形的菱形形状。 例如，下面的代码使用 &lt;code&gt;Capsule&lt;/code&gt; 形状创建相同的按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Button(action: {
            print(&amp;quot;Button tapped!&amp;quot;)
        }, label: {
            Image(systemName: &amp;quot;bolt.fill&amp;quot;)
                .foregroundColor(.white)
                .padding(EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20))
                .background(Color.green)
                .clipShape(Capsule())
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.7_create_capsule_button.png&#34; alt=&#34;10.7_create_capsule_button&#34; title=&#34;Create a capsule button&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.6_如何在视图周围绘制阴影</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.6_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1/</link>
      <pubDate>Tue, 06 Aug 2019 10:37:26 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.6_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 为我们提供了一个专用的 &lt;code&gt;shadow()&lt;/code&gt; 修改器，用于在视图周围绘制阴影。 我们可以控制阴影的颜色、半径和位置，还可以通过调整修改器顺序来控制视图的哪些部分被阴影遮盖。&lt;/p&gt;

&lt;h3 id=&#34;2-通过模糊半径绘制阴影&#34;&gt;2. 通过模糊半径绘制阴影&lt;/h3&gt;

&lt;p&gt;在其基本形式中，我们只需指定模糊的半径即可添加阴影，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .shadow(radius: 5)
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.6_shadow_through_radius.png&#34; alt=&#34;10.6_shadow_through_radius&#34; title=&#34;Add a shadow just by specifying the radius of the blur&#34; /&gt;
这段代码添加了一个非常轻微的阴影，以文本为中心的5点模糊。&lt;/p&gt;

&lt;h3 id=&#34;3-绘制红色阴影&#34;&gt;3. 绘制红色阴影&lt;/h3&gt;

&lt;p&gt;我们还可以指定所需的颜色以及原始视图的X和Y偏移。 例如，下面的代码会创建一个强烈的红色阴影，其中包含5点模糊，以文本为中心：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .shadow(color: Color.red, radius: 5)
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.6_shadow_red.png&#34; alt=&#34;10.6_shadow_red&#34; title=&#34;This creates a strong red shadow with a 5 point blur&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-为阴影设置偏移量&#34;&gt;4. 为阴影设置偏移量&lt;/h3&gt;

&lt;p&gt;如果要为阴影指定偏移，请将 &lt;code&gt;x&lt;/code&gt; 和/或 &lt;code&gt;y&lt;/code&gt; 参数添加到修改器，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .shadow(color: Color.red, radius: 5, x: 20, y: 20)
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.6_shadow_red_x20_y20.png&#34; alt=&#34;10.6_shadow_red_x20_y20&#34; title=&#34;Add x and/or y parameters to the modifier&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-为边框绘制阴影&#34;&gt;5. 为边框绘制阴影&lt;/h3&gt;

&lt;p&gt;请记住，SwiftUI 按照列出修改器的顺序来应用它们，因此如果我们希望可以将阴影应用于边框，只需将边框修改器放在阴影修改器之前:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .border(Color.red, width: 4)
            .shadow(color: Color.red, radius: 5, x: 20, y: 20)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.6_shadow_set_shadow_for_border.png&#34; alt=&#34;10.6_shadow_set_shadow_for_border&#34; title=&#34;Apply a shadow for the border&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.5_如何在视图周围绘制边框</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.5_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E8%BE%B9%E6%A1%86/</link>
      <pubDate>Tue, 06 Aug 2019 10:17:54 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.5_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E8%BE%B9%E6%A1%86/</guid>
      <description>

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 为我们提供了一个专用的 &lt;code&gt;border&lt;/code&gt; 修改器，用于在视图周围绘制边框。根据我们是要指定笔划宽度(a stroke width)还是圆角半径(a corner radius)，它有一些变化，因此下面是几个示例:&lt;/p&gt;

&lt;h3 id=&#34;2-绘制1个点的边框&#34;&gt;2. 绘制1个点的边框&lt;/h3&gt;

&lt;p&gt;下面的代码在文本视图周围绘制1个点的黑色边框:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .border(Color.black)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.5_border_1_point.png&#34; alt=&#34;10.5_border_1_point&#34; title=&#34;This adds a simple 1-point black border around a text view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-先添加填充再绘制边框&#34;&gt;3. 先添加填充再绘制边框&lt;/h3&gt;

&lt;p&gt;如果要使边框不位于视图边缘，请先添加一些填充：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .border(Color.black)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.5_border_with_padding.png&#34; alt=&#34;10.5_border_with_padding&#34; title=&#34;Add some padding first, then add border&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-添加4个点的红色边框&#34;&gt;4. 添加4个点的红色边框&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.5_border_4_point_red.png&#34; alt=&#34;10.5_border_4_point_red&#34; title=&#34;This adds a 4 point red border&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.4_如何堆叠修改器以创建更高级的效果</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.4_%E5%A6%82%E4%BD%95%E5%A0%86%E5%8F%A0%E4%BF%AE%E6%94%B9%E5%99%A8%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%95%88%E6%9E%9C/</link>
      <pubDate>Tue, 06 Aug 2019 10:07:51 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.4_%E5%A6%82%E4%BD%95%E5%A0%86%E5%8F%A0%E4%BF%AE%E6%94%B9%E5%99%A8%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%95%88%E6%9E%9C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;我们添加到视图中的每个修改器都会调整其前面的内容，并且可以多次重复使用修改器。&lt;/p&gt;

&lt;p&gt;例如，我们可以在文本视图周围添加填充和背景色，然后添加更多的填充和不同的背景色，然后添加更多的填充和第三种背景色，所有这些都可以产生特定的效果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Forecast: Sun&amp;quot;)
            .font(.largeTitle)
            .foregroundColor(Color.white)
            .padding()
            .background(Color.red)
            .padding()
            .background(Color.orange)
            .padding()
            .background(Color.yellow)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.4_stack_modifiers.png&#34; alt=&#34;10.4_stack_modifiers&#34; title=&#34;Stack modifiers&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.3_如何为视图周围的填充设置颜色</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.3_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E5%A1%AB%E5%85%85%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Tue, 06 Aug 2019 09:46:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.3_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E5%A1%AB%E5%85%85%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;padding()&lt;/code&gt; 修饰符允许我们在视图周围添加一些空间，&lt;code&gt;background()&lt;/code&gt; 修饰符允许我们设置背景颜色。 但是，我们使用它们的方式很重要，因此明确我们的目标以获得最佳结果非常重要。&lt;/p&gt;

&lt;h3 id=&#34;2-先着色后填充&#34;&gt;2. 先着色后填充&lt;/h3&gt;

&lt;p&gt;例如，下面的代码将创建一个具有黑色背景和白色前景的文本视图，然后向其添加系统默认填充:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .background(Color.black)
            .foregroundColor(Color.white)
            .padding()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.3_backgroudcolor_foregroundcolor_padding.png&#34; alt=&#34;10.3_backgroudcolor_foregroundcolor_padding&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-先填充后着色&#34;&gt;3. 先填充后着色&lt;/h3&gt;

&lt;p&gt;例如，下面的代码将为文本视图添加系统默认填充，然后再为其设置红色背景和白色前景:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .background(Color.red)
            .foregroundColor(Color.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.3_padding_backgroudcolor_foregroundcolor.png&#34; alt=&#34;10.3_padding_backgroudcolor_foregroundcolor&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-总结&#34;&gt;4. 总结&lt;/h3&gt;

&lt;p&gt;这两段代码可能看起来很相似，但是它们会产生不同的结果，因为应用修饰符的顺序很重要。在第二个示例中，视图先被填充，然后被着色，这意味着填充也被着色为红色。与此相反，第一个示例是先着色，然后填充，因此填充保持未着色。&lt;/p&gt;

&lt;p&gt;因此，如果我们希望某些文本的背景色比文本本身更宽，请确保使用第二个代码示例 – 先填充后着色。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.2_如何调整视图的位置</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.2_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 06 Aug 2019 09:17:27 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.2_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;所有视图在层次结构中都有一个自然位置，但是我们可以通过 &lt;code&gt;offset()&lt;/code&gt; 修改器相对于其自然位置来移动它们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要说明:&lt;/strong&gt; 使用 &lt;code&gt;offset()&lt;/code&gt; 将导致视图相对于其自然位置进行移动，但是不会影响其它视图的位置。这意味着我们可以使一个视图与另一个视图重叠，因为通常情况下它们可能彼此相邻，而这可能不是我们想要的。&lt;/p&gt;

&lt;p&gt;例如，在这个 &lt;code&gt;VStack&lt;/code&gt; 中，我们可以使用 &lt;code&gt;offset()&lt;/code&gt; 将第二个项目向下移动15个点，以便它开始与第三个项目重叠:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;Home&amp;quot;)
            Text(&amp;quot;Options&amp;quot;)
                .offset(y: 15)
            Text(&amp;quot;Help&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.2_adjust_position_2nd_item_in_vstack.png&#34; alt=&#34;10.2_adjust_position_2nd_item_in_vstack&#34; title=&#34;Set offset.y = 15 for the 2nd item&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常，我们可以使用 &lt;code&gt;padding()&lt;/code&gt; 和 &lt;code&gt;offset()&lt;/code&gt; 来得到我们期望的结果，因为这样可以移动一个视图，同时挑着做那个它旁边的视图以使其匹配。&lt;/p&gt;

&lt;p&gt;例如: 我们将第二个项目向下移动15个点，但在其底边添加15个填充点，使其不会与下面的文本视图重叠:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;Home&amp;quot;)
            Text(&amp;quot;Options&amp;quot;)
                .offset(y: 15)
                .padding(.bottom, 15)
            Text(&amp;quot;Help&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.2_adjust_position_using_padding.png&#34; alt=&#34;10.2_adjust_position_using_padding&#34; title=&#34;Set padding.bottom = 15&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.1_如何为视图提供自定义frame</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.1_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89frame/</link>
      <pubDate>Tue, 06 Aug 2019 00:19:31 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.1_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89frame/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;默认情况下，视图只占用自己所需的空间，但是如果我们想要更改它，可以使用 &lt;code&gt;frame()&lt;/code&gt; 修饰符告诉 SwiftUI 我们想要的尺寸范围(size range)。&lt;/p&gt;

&lt;p&gt;例如，可以创建一个具有 &lt;code&gt;200x200&lt;/code&gt; 可点击区域的按钮，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Button(action: {
            print(&amp;quot;Button tapped&amp;quot;)
        }, label: {
            Text(&amp;quot;Welcome&amp;quot;)
                .frame(minWidth: 0, maxWidth: 200, minHeight: 0, maxHeight: 200, alignment: .center)
                .font(.largeTitle)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.1_frame_200wh_button.png&#34; alt=&#34;10.1_frame_200wh_button&#34; title=&#34;Create a 200 * 200 button&#34; /&gt;
或者，我们可以通过指定一个 frame 来使文本视图填充整个屏幕，这个 frame 的最小宽度和最小高度为0，最大宽度和最大高度是无穷大。如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Please login&amp;quot;)
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
                .font(.largeTitle)
                .foregroundColor(Color.white)
                .background(Color.red)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.1_frame_fill_screen_text.png&#34; alt=&#34;10.1_frame_fill_screen_text&#34; title=&#34;Create a text which fills the screen&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>9.3_如何使用PresentationLink呈现新视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8presentationlink%E5%91%88%E7%8E%B0%E6%96%B0%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Mon, 05 Aug 2019 18:11:53 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8presentationlink%E5%91%88%E7%8E%B0%E6%96%B0%E8%A7%86%E5%9B%BE/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;PresentationLink&lt;/code&gt; 用于以现有视图控制器的基础上以模态方式呈现新视图控制器，例如在 &lt;code&gt;UIViewController&lt;/code&gt; 上调用 &lt;code&gt;present()&lt;/code&gt;。 要使用一个，给它一些要显示的内容（一些文本、一个图像等）加上一个目的地，然后让 SwiftUI 处理其余的内容。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;提示: 在beta 1和beta 2中，它被命名为 &lt;code&gt;PresentationButton&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如，如果我们有这样的详细视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct DetailView: View {
    var body: some View {
        Text(&amp;quot;Detail&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你我们可以这样呈现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>9.2_点击列表行时如何push新视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.2_%E7%82%B9%E5%87%BB%E5%88%97%E8%A1%A8%E8%A1%8C%E6%97%B6%E5%A6%82%E4%BD%95push%E6%96%B0%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Mon, 05 Aug 2019 17:40:40 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.2_%E7%82%B9%E5%87%BB%E5%88%97%E8%A1%A8%E8%A1%8C%E6%97%B6%E5%A6%82%E4%BD%95push%E6%96%B0%E8%A7%86%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;SwiftUI 中没有 &lt;code&gt;UITableView&lt;/code&gt; 的 &lt;code&gt;didSelectRowAt&lt;/code&gt; 方法的直接等价物，但它不需要这样的方法，因为我们可以将 &lt;code&gt;NavigationLink&lt;/code&gt; 与列表行结合起来并免费获取这种 behavior。&lt;/p&gt;

&lt;p&gt;我们需要将列表与我们可以使用的一些内容放在一起。 首先，我们需要某种数据来显示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Restaurant: Identifiable {
    var id = UUID()
    var name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要一个列表行视图，一次显示一个餐厅:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow: View {
    
    var restaurant: Restaurant
    
    var body: some View {
        Text(restaurant.name)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们需要一个视图，其中包含可用餐厅的列表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        let first = Restaurant(name: &amp;quot;Joe&#39;s Original&amp;quot;)
        let restaurants = [first]
        
        return NavigationView {
            List(restaurants, rowContent: { restaurant in
                RestaurantRow(restaurant: restaurant)
            }).navigationBarTitle(Text(&amp;quot;Select a restaurant&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/9.2_restaurant_list.png&#34; alt=&#34;9.2_restaurant_list&#34; title=&#34;A restaurant list&#34; /&gt;
这段代码在列表中显示一家餐馆，但是不可选。&lt;/p&gt;

&lt;p&gt;为了使点击一行显示详细视图，我们首先需要一个可以显示餐厅的详细视图。 例如，像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow: View {
    
    var restaurant: Restaurant
    
    var body: some View {
        Text(&amp;quot;Come and eat at \(restaurant.name)&amp;quot;)
            .font(.largeTitle)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了它，我们现在可以在 &lt;code&gt;NavigationLink&lt;/code&gt; 中包装 &lt;code&gt;RestaurantRow&lt;/code&gt; 行，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        let first = Restaurant(name: &amp;quot;Joe&#39;s Original&amp;quot;)
        let restaurants = [first]
        
        return NavigationView {
            List(restaurants, rowContent: { restaurant in
                NavigationLink(destination: RestaurantRow(restaurant: restaurant)) {
                    RestaurantRow(restaurant: restaurant)
                }
            }).navigationBarTitle(Text(&amp;quot;Select a restaurant&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/9.2_select_a_restaurant.gif&#34; alt=&#34;9.2_select_a_restaurant&#34; title=&#34;Select a restaurant&#34; /&gt;
如您所见，使用 &lt;code&gt;RestaurantRow(restaurant: restaurant)&lt;/code&gt; 作为行点击事件的目的地，因此将创建 &lt;code&gt;RestaurantView&lt;/code&gt; 并传递附加到列表行的餐厅。&lt;/p&gt;

&lt;p&gt;请注意，我们是如何在导航按钮中添加列表行的 — SwiftUI 凭借其出色的构图能力使其工作正常。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>9.1_如何将新视图push到NavigationView</title>
      <link>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.1_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%B0%E8%A7%86%E5%9B%BEpush%E5%88%B0navigationview/</link>
      <pubDate>Mon, 05 Aug 2019 16:58:35 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.1_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%B0%E8%A7%86%E5%9B%BEpush%E5%88%B0navigationview/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果我们有一个导航视图，并且希望将一个新视图 push 到 SwiftUI 的导航堆栈上，那么我们应该使用 &lt;code&gt;NavigationLink&lt;/code&gt;，在 beta 1和2 中使用的是 &lt;code&gt;NavigationButton&lt;/code&gt;。这将一个目标作为它的第一个参数，以及在按钮内部显示什么作为它的第二个参数（或者作为一个尾随闭包），并负责将新视图和动画一起 push 到堆栈上。&lt;/p&gt;

&lt;p&gt;例如: 如果我们有这样一个 &lt;strong&gt;详细视图&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct DetailView: View {
    var body: some View {
        Text(&amp;quot;Detail&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以这样呈现它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView(), label: {
                Text(&amp;quot;Click!&amp;quot;)
                    .background(Color.red)
            })
            .navigationBarTitle(Text(&amp;quot;Navigation&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/9.1_push_view_to_navigationview.png&#34; alt=&#34;9.1_push_view_to_navigationview&#34; title=&#34;Push a view onto the navigationView&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8.4_如何显示一个action_sheet</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.4_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAaction_sheet/</link>
      <pubDate>Mon, 05 Aug 2019 16:14:42 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.4_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAaction_sheet/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 为我们提供了 &lt;code&gt;ActionSheet&lt;/code&gt; 视图，用于创建供用户选择的操作表。但是，我们确实需要确保在它被解除时重置我们的状态，否则，我们将无法再次显示它。&lt;/p&gt;

&lt;p&gt;稍后，我们再展示所有代码，现在我们首先将其分解，因为这并不容易。&lt;/p&gt;

&lt;p&gt;首先，我们需要定义一个属性来跟踪是否需要显示操作表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@State private var showingSheet = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们应该创建一个属性来存储操作表。这需要标题和消息文本，但也应该提供一个按钮数组。如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var sheet = ActionSheet(title: Text(&amp;quot;Action&amp;quot;),
                        message: Text(&amp;quot;Quote mark&amp;quot;),
                        buttons: [.default(Text(&amp;quot;Show sheet&amp;quot;))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，我们可以使用显示工作表的演示文稿将操作表附加到视图中，或者根据showsSheet的值执行任何操作，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showingSheet = false
    var sheet = ActionSheet(title: Text(&amp;quot;Action&amp;quot;),
                            message: Text(&amp;quot;Quote mark&amp;quot;),
                            buttons: [.default(Text(&amp;quot;Show sheet&amp;quot;))])
        
        
    var body: some View {
        Button(action: {
            self.showingSheet = true
        }, label: {
            Text(&amp;quot;Woo&amp;quot;)
        })
        .actionSheet(isPresented: $showingSheet, content: {
            self.sheet
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/8.4_show_action_sheet.gif&#34; alt=&#34;8.4_show_action_sheet&#34; title=&#34;Show an action sheet&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8.3_如何向alert_buttons添加actions</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.3_%E5%A6%82%E4%BD%95%E5%90%91alert_buttons%E6%B7%BB%E5%8A%A0actions/</link>
      <pubDate>Mon, 05 Aug 2019 15:54:28 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.3_%E5%A6%82%E4%BD%95%E5%90%91alert_buttons%E6%B7%BB%E5%8A%A0actions/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;基本的 SwiftUI alert 如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Alert(title: Text(&amp;quot;Important message&amp;quot;), message: Text(&amp;quot;Wear sunscreen&amp;quot;), dismissButton: .default(Text(&amp;quot;Got it!&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，我们经常需要将操作附加到按钮上，以便在点击按钮时执行特定操作。要做到这一点，请在按钮上附加一个闭包，当按钮被点击时闭包将被调用，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showAlert = false
    
    var body: some View {
        Button(action: {
            self.showAlert = true
        }, label: {
            Text(&amp;quot;Show alert&amp;quot;)
        })
        .alert(isPresented: $showAlert,
               content: {
                Alert(title: Text(&amp;quot;Are you sure you want to delete this?&amp;quot;),
                      message: Text(&amp;quot;There is no undo.&amp;quot;),
                      primaryButton: .destructive(Text(&amp;quot;Delete&amp;quot;), action: {
                        print(&amp;quot;Deleting...&amp;quot;)
                      }),
                      secondaryButton: .cancel())
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/8.3_add_actions_to_alert_buttons.gif&#34; alt=&#34;8.3_add_actions_to_alert_buttons&#34; title=&#34;Add actions to alert buttons&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;提示: 在预览视图中，点击 &lt;code&gt;Delete&lt;/code&gt; 按钮，控制台没有日志输出。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>8.2_如何显示一个alert</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.2_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAalert/</link>
      <pubDate>Mon, 05 Aug 2019 15:23:39 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.2_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAalert/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;创建一个基本的 SwiftUI alert 的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Alert(title: Text(&amp;quot;Important message&amp;quot;), message: Text(&amp;quot;Wear sunscreen&amp;quot;), dismissButton: .default(Text(&amp;quot;Got it!&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它定义了一个标题和消息，就像我们在 &lt;code&gt;UIAlertController&lt;/code&gt; 中看到的那样，然后添加了一个带有默认样式的 dismiss 按钮和文本 &amp;ldquo;Got it!&amp;ldquo;。&lt;/p&gt;

&lt;p&gt;要显示该 alert，我们需要定义某种可绑定条件，以确定 alert 是否可见。然后将其作为演示附加到主视图中，在 alert 条件变为 true 的时候，立即显示 alert。&lt;/p&gt;

&lt;p&gt;例如: 下面的代码创建一个 &lt;code&gt;showingAlert&lt;/code&gt; 的布尔值，用于跟踪是否应该显示 &amp;ldquo;sunscreen message&amp;rdquo;，在点击按钮时将该布尔值设置为 true，然后使用该布尔值创建并附加一个 alert 视图，以便在点击按钮时显示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showingAlert = false
    
    var body: some View {
        Button(action: {
            self.showingAlert = true
        }, label: {
            Text(&amp;quot;Show alert&amp;quot;)
        })
        .alert(isPresented: $showingAlert,
               content: {
                Alert(title: Text(&amp;quot;Important message&amp;quot;), message: Text(&amp;quot;Wear sunscreen&amp;quot;), dismissButton: .default(Text(&amp;quot;Got it!&amp;quot;)))
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果演示:
&lt;img src=&#34;img/8.2_show_alert.gif&#34; alt=&#34;8.2_show_alert&#34; title=&#34;Show a alert&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; 通过这种方式展示一个 alert，当按下关闭按钮时，会自动将 &lt;code&gt;showingAlert&lt;/code&gt; 设置回 false。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>8.1_使用presentations</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.1_%E4%BD%BF%E7%94%A8presentations/</link>
      <pubDate>Mon, 05 Aug 2019 11:54:02 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.1_%E4%BD%BF%E7%94%A8presentations/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的声明性编程方法意味着我们不会像在 UIKit 中那样创建和呈现 &lt;strong&gt;警报(Alerts)&lt;/strong&gt; 和 &lt;strong&gt;操作表(Action sheets)&lt;/strong&gt;。 相反，我们定义了它们应该什么条件下显示，告诉它它们应该是什么样子，然后让它自己计算出其余部分。&lt;/p&gt;

&lt;p&gt;这一切都是通过使用 &lt;code&gt;presentation()&lt;/code&gt; 修饰符来完成的，该修饰符将新 UI 附加到我们的视图中，当满足某个条件时将显示该 UI。我们可以根据需要附加任意多个，并且它们实际上会等待观察，直到它们的状态变为真(true)，这个时候，它们显示自己的 UI。例如: 我们可以在按下按钮时切换一个布尔值，这会触发要显示的警报(alerts)。&lt;/p&gt;

&lt;p&gt;我们可以将演示文稿附加到主视图或其任何子视图，甚至是可以调整状态的按钮，以便触发演示文稿。这是一个微妙的区别，但重要的是要理解，这些演示文稿并没有附加到按钮上，因为它是一个按钮，也就是说，由于点按了按钮，所以不会以任何方式显示警报(alerts)。相反，我们将它附加到我们的视图层次结构中，以便 SwiftUI 知道它可能在任何时候显示。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.4_如何将视图组合在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.4_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Mon, 05 Aug 2019 11:22:27 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.4_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果我们需要将多个视图作为一个视图，例如: 一起转换。那么，我们应该使用 SwiftUI 的 &lt;code&gt;Group&lt;/code&gt; 视图。这一点尤为重要，因为出于底层的技术原因，我们一次性最多只能向父视图添加十个子视图。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;line - 0&amp;quot;)
            Text(&amp;quot;line - 1&amp;quot;)
            Text(&amp;quot;line - 2&amp;quot;)
            Text(&amp;quot;line - 3&amp;quot;)
            Text(&amp;quot;line - 4&amp;quot;)
            Text(&amp;quot;line - 5&amp;quot;)
            Text(&amp;quot;line - 6&amp;quot;)
            Text(&amp;quot;line - 7&amp;quot;)
            Text(&amp;quot;line - 8&amp;quot;)
            Text(&amp;quot;line - 9&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/group_10_lines.png&#34; alt=&#34;group_10_lines&#34; title=&#34;Show 10 lines&#34; /&gt;
一切正常，但是，当我们尝试添加第11行文本的时候，就会报错:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Ambiguous reference to member &#39;buildBlock&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误预览:
&lt;img src=&#34;img/grouo_11_lines_error.png&#34; alt=&#34;grouo_11_lines_error&#34; title=&#34;When show the 11th line, throw a error&#34; /&gt;
后面是一串这样的错误信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;ContentView.swift:10:16: Found this candidate (SwiftUI.ViewBuilder)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为 SwiftUI 的视图构建系统中有各种各样的代码设计，可以让我们添加1个视图、2个视图、2个视图、3个视图、4个视图、5个视图、6个视图、7个视图、8个视图、9个视图和10个视图，但是不适用于11个或更多视图 - 这不起作用。&lt;/p&gt;

&lt;p&gt;幸运的是，我们可以像这样使用 &lt;code&gt;group&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Group {
                Text(&amp;quot;line - 0&amp;quot;)
                Text(&amp;quot;line - 1&amp;quot;)
                Text(&amp;quot;line - 2&amp;quot;)
                Text(&amp;quot;line - 3&amp;quot;)
                Text(&amp;quot;line - 4&amp;quot;)
                Text(&amp;quot;line - 5&amp;quot;)
            }
            Group {
                Text(&amp;quot;line - 6&amp;quot;)
                Text(&amp;quot;line - 7&amp;quot;)
                Text(&amp;quot;line - 8&amp;quot;)
                Text(&amp;quot;line - 9&amp;quot;)
                Text(&amp;quot;line - 10&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/group_11_lines.png&#34; alt=&#34;group_11_lines&#34; title=&#34;Group 11 lines&#34; /&gt;
这产生了完全相同的结果，现在我们可以超过10个视图的限制，因为 &lt;code&gt;VStack&lt;/code&gt; 中只包含两个视图——两个组。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.3_如何给导航视图添加bar_items</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.3_%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0bar_items/</link>
      <pubDate>Mon, 05 Aug 2019 11:06:31 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.3_%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0bar_items/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过 &lt;code&gt;navigationBarItems()&lt;/code&gt; 修饰符，我们可以在导航视图的 &lt;em&gt;前缘(leading)&lt;/em&gt; 和 &lt;em&gt;后缘(trailing)&lt;/em&gt;  添加 &lt;strong&gt;bar items&lt;/strong&gt;。这些 &lt;strong&gt;bar items&lt;/strong&gt; 可能是一个可点击的按钮，但没有任何限制 - 您可以添加任何类型的视图。&lt;/p&gt;

&lt;p&gt;例如: 我们可以在导航视图的后缘(trailing)添加一个 &lt;strong&gt;帮助按钮&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        NavigationView {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;))
            .navigationBarItems(trailing:
                Button(action: {
                    print(&amp;quot;Help tapped!&amp;quot;)
                }, label: {
                    Text(&amp;quot;Help&amp;quot;)
                })
            )
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_add_bar_items.png&#34; alt=&#34;navigationview_add_bar_items&#34; title=&#34;Add bar items.&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.2_如何在导航视图中嵌入视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.2_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Fri, 02 Aug 2019 18:18:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.2_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;NavigationView&lt;/code&gt; 几乎等同于 UIKit 中的 &lt;code&gt;UINavigationController&lt;/code&gt;，因为它不仅可以呈现内容，而且它能够处理视图之间的导航，并在屏幕顶部放置一个导航栏。&lt;/p&gt;

&lt;h3 id=&#34;2-嵌入文本视图&#34;&gt;2. 嵌入文本视图&lt;/h3&gt;

&lt;p&gt;接下来，我们以最简单的形式，将文本视图放入导航视图中，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        NavigationView {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_embed_text_no_navigationbar.png&#34; alt=&#34;navigationview_embed_text_no_navigationbar&#34; title=&#34;Embed a text in  the navigationView&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-设置导航栏标题&#34;&gt;3. 设置导航栏标题&lt;/h3&gt;

&lt;p&gt;但是这样，顶部的导航栏为空。因此，通常在嵌入的内容上使用 &lt;code&gt;navigationBarTitle()&lt;/code&gt; 修饰符，因此，我们可以在屏幕顶部添加标题，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;NavigationView {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
        .navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_embed_text_has_navigationbar.png&#34; alt=&#34;navigationview_embed_text_has_navigationbar&#34; title=&#34;Embed a text in the navigationView which has a navigationBar&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-自定义导航标题&#34;&gt;4. 自定义导航标题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;navigationBarTitle()&lt;/code&gt; 修饰符为我们提供了一些自定义选项。&lt;/p&gt;

&lt;p&gt;例如: 默认情况下，它将从呈现它的任何视图继承大型标题显示模式，或者如果它是初始视图，那么它将使用大型标题。但是，如果我们想强制启用或禁用大标题，那么我们应该使用 &lt;code&gt;inline&lt;/code&gt; 参数，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;), displayMode: .inline)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_navigationbar_inline.png&#34; alt=&#34;navigationview_navigationbar_inline&#34; title=&#34;Display mode is inline.&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.1_使用容器</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.1_%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 02 Aug 2019 18:06:43 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.1_%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 设计为开箱即用，这意味着我们可以根据需要将一个视图放在另一个视图中。&lt;/p&gt;

&lt;p&gt;这在处理我们习惯的主要容器视图（如导航控制器和选项卡栏控制器）时特别有用。我们可以将想要的任何视图直接放置到另一个容器视图中，Swiftui将自动调整其布局。&lt;/p&gt;

&lt;p&gt;在这方面，Swiftui自己的容器—— &lt;code&gt;NavigationView&lt;/code&gt;、&lt;code&gt;TabbedView&lt;/code&gt;、&lt;code&gt;Group&lt;/code&gt; 等等——与我们用自己的视图组合制作的容器没有什么不同。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.6_显示或隐藏表单行</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.6_%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E8%A1%8C/</link>
      <pubDate>Fri, 02 Aug 2019 15:27:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.6_%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E8%A1%8C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 允许我们可以根据需要在表单中添加和删除项目，当我们希望调整基于先前选项可见的选项列表时，特别有用。&lt;/p&gt;

&lt;p&gt;例如，这会显示单个 &lt;em&gt;toggle&lt;/em&gt; ，提示用户是否要显示更多高级选项。启用该 &lt;em&gt;toggle&lt;/em&gt; 后，会出现第二个 &lt;em&gt;toggle&lt;/em&gt; ，允许他们启用日志记录:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showingAdvancedOptions = false
    @State var enableLogging = false
    
    var body: some View {
        Form {
            Section {
                Toggle(isOn: $showingAdvancedOptions) {
                    Text(&amp;quot;Show advanced options&amp;quot;)
                }
                
                if showingAdvancedOptions {
                    Toggle(isOn: $enableLogging) {
                        Text(&amp;quot;Enable logging&amp;quot;)
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.6_form_show_hide.gif&#34; alt=&#34;6.6_form_show_hide&#34; title=&#34;Form show or hide&#34; /&gt;
与其他绑定一样，可以要求 SwiftUI 对绑定更改导致的视图更改使用隐式动画，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State var showingAdvancedOptions = false
    @State var enableLogging = false
    
    var body: some View {
        Form {
            Section {
                Toggle(isOn: $showingAdvancedOptions.animation()) {
                    Text(&amp;quot;Showing Advanced Options&amp;quot;)
                }
            }
            
            if showingAdvancedOptions {
                Toggle(isOn: $enableLogging) {
                    Text(&amp;quot;Enable Logging&amp;quot;)
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.6_form_show_hide_animation.gif&#34; alt=&#34;6.6_form_show_hide_animation&#34; title=&#34;Form show or hide with animation&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.5_启用和禁用表单中的元素</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 02 Aug 2019 15:04:09 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 允许我们通过使用 &lt;code&gt;disabled()&lt;/code&gt; 修饰符来禁用表单的任何部分甚至整个表单。这需要一个布尔值来定义是否应禁止使用该元素。表单元素的样式会自动更新以反映其状态-例如，&lt;em&gt;buttons&lt;/em&gt; 和  &lt;em&gt;toggles&lt;/em&gt; 变为灰色。&lt;/p&gt;

&lt;p&gt;例如，这将创建一个包含两个 sections 的表单：一个 &lt;em&gt;section&lt;/em&gt; 包含 Toggle ，另一个 &lt;em&gt;section&lt;/em&gt; 包含仅在切换打开时才启用的 Button：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var agreedToTerms = false
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    Toggle(isOn: $agreedToTerms) {
                        Text(&amp;quot;Agree to terms and conditions&amp;quot;)
                    }
                }
                Section {
                    Button(action: {
                        // show next screen here
                    }) {
                        Text(&amp;quot;Continue&amp;quot;)
                    }
                    .disabled(!agreedToTerms)
                }
            }
            .navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.5_form_enable_disable.gif&#34; alt=&#34;6.5_form_enable_disable&#34; title=&#34;Form enable and disable&#34; /&gt;
如您所见，只需将禁用 &lt;code&gt;(!agreeToTerms)&lt;/code&gt; 添加到修改器列表中即可禁用该按钮。&lt;/p&gt;

&lt;p&gt;与许多其他SwiftIUI修饰符一样，您可以提升 &lt;code&gt;disabled()&lt;/code&gt;，以便它在 Section 上运行，甚至在整个表单上运行，这取决于您想要的行为——例如，只需移动 &lt;code&gt;disabled(!agreedToTerms)&lt;/code&gt; 使它位于该 section 之后:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Section {
    Button(action: {
        // show next screen here
    }) {
        Text(&amp;quot;Continue&amp;quot;)
    }
}
.disabled(!agreedToTerms)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>6.4_表单中选择器的使用</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 02 Aug 2019 13:49:59 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;在表单内部，SwiftUI 的 &lt;code&gt;选择器视图&lt;/code&gt; 具有特殊的行为，可根据我们使用它们的平台自动进行调整。在 iOS 上，这种行为尤其令人印象深刻，因为选择器可以折叠到一个列表行，该行导航到一个新的可能选项列表中——这是处理许多选项的一种非常自然的方式。&lt;/p&gt;

&lt;p&gt;例如，这将创建一个带有选择器的表单，并为其项使用数组：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var strengths = [&amp;quot;Mild&amp;quot;, &amp;quot;Medium&amp;quot;, &amp;quot;Mature&amp;quot;]
    @State var selectedStrength = 0
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    Picker(selection: $selectedStrength, label: Text(&amp;quot;Text strength&amp;quot;)) {
                        ForEach(0..&amp;lt;strengths.count) {
                            Text(self.strengths[$0]).tag($0)
                        }
                    }
                }
            }
            .navigationBarTitle(Text(&amp;quot;Select your cheese&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.4_form_pickers.gif&#34; alt=&#34;6.4_form_pickers&#34; title=&#34;Form pickers&#34; /&gt;
表单中的选择器
在 iOS 上，这将显示为一个单独的列表行，您可以点击该行进入一个新屏幕，显示所有可能的选项—— Mild、Medium 和 Mature。您当前的选择旁边将有一个复选标记，当您选择一个新选项时，它将返回上一个屏幕，并显示当前的选项。&lt;/p&gt;

&lt;p&gt;如果要禁用此行为，可以使用.PickerStyle(.wheel)修饰符强制选取器采用其常规样式，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Picker(selection: $selectedStrength, label: Text(&amp;quot;Text strength&amp;quot;)) {
    ForEach(0..&amp;lt;strengths.count) {
        Text(self.strengths[$0]).tag($0)
    }
}
.pickerStyle(WheelPickerStyle())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.4_form_pickers_wheel.gif&#34; alt=&#34;6.4_form_pickers_wheel&#34; title=&#34;Picker with wheel style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.3_将表单分成几个sections</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/</link>
      <pubDate>Fri, 02 Aug 2019 12:01:16 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的表单通常在分成多个部分时效果最好，就像常规的内容列表一样。 如何将它们分组取决于你，但是通常情况下，按照它们的目的进行分组效果最好 - 如果它是一个订单页面你可以将项目放在一个组中，在另一个组中进行定制，并在第三个组中进行交付。
很有帮助的是，表单 sections 与列表 sections 相同，这意味着您可以在两个地方重复使用相同的代码。因此，您可以向 sections 中添加 &lt;em&gt;header&lt;/em&gt; 和/或 &lt;em&gt;footer&lt;/em&gt; ，或者两者都不使用，只需在 sections 之间获得一些屏幕上的间距。&lt;/p&gt;

&lt;p&gt;例如，这将创建一个包含两个 section 的表单，第一个 section 带有 &lt;em&gt;segmented control&lt;/em&gt; 和 &lt;em&gt;toggle&lt;/em&gt; ，第二个 section 带有保存按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var enableLogging = false
    @State var selectedColor = 0
    @State var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        Form {
            Section(footer: Text(&amp;quot;Note: Enabling logging may slow down the app&amp;quot;)) {
                SegmentedControl(selection: $selectedColor) {
                    ForEach(0..&amp;lt;colors.count) {
                        Text(self.colors[$0]).tag($0)
                    }
                }
                Toggle(isOn: $enableLogging) {
                    Text(&amp;quot;Enable logging&amp;quot;)
                }
            }
            Section {
                Button(action: {
                    
                }) {
                    Text(&amp;quot;Save changes&amp;quot;)
                }
            }
        }
        .navigationBarTitle(Text(&amp;quot;Settings&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.3_form_sections.gif&#34; alt=&#34;6.3_form_sections&#34; title=&#34;Form sections&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.2_基本表单设计</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 02 Aug 2019 00:37:07 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;p&gt;SwiftUI 中的 &lt;code&gt;表单(forms)&lt;/code&gt; 可以当作容器使用，就像 &lt;code&gt;HStack&lt;/code&gt; 和 &lt;code&gt;VStack&lt;/code&gt; 一样，这意味着我们可以根据需要在其中添加其它视图。 但是，表单会自动调整某些控件的行为和样式，以便它们更好地适应表单环境。
例如，我们将创建一个带有 _toggle_、&lt;em&gt;segmentedControl&lt;/em&gt; 和 &lt;em&gt;button&lt;/em&gt; 的表单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var enableLogging = false
    @State var selectedColor = 0
    @State var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        NavigationView {
            Form {
                Picker(selection: $selectedColor, label: Text(&amp;quot;&amp;quot;)) {
                    ForEach(0..&amp;lt;colors.count) {
                        Text(self.colors[$0]).tag($0)
                    }
                }
                .pickerStyle(SegmentedPickerStyle())
                
                Toggle(isOn: $enableLogging) {
                    Text(&amp;quot;Enable logging!&amp;quot;)
                }
                Button(action: {
                    // activate theme!
                }) {
                    Text(&amp;quot;Save changes&amp;quot;)
                }
            }
            .navigationBarTitle(Text(&amp;quot;Settings&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.3_forms_basic_design.gif&#34; alt=&#34;6.3_forms_basic_design&#34; /&gt;
当代码运行时，我们将看到两件对表单行为至关重要的事情:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 iOS 上，表单自动采用 &lt;code&gt;分组列表&lt;/code&gt; 的样式，因此用户可以看到滚动选项。&lt;/li&gt;
&lt;li&gt;按钮已经调整了自己，看起来像一个可操作的列表行—— &lt;code&gt;左对齐，蓝色&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 我们可以根据需要在表单中包含尽可能多的行，但如果需要超过10，请记住使用组(groups)。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>6.1_表单的使用介绍</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 02 Aug 2019 00:21:32 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SwiftUI 专注于声明性用户界面，因此它为我们提供了一种构建 &lt;code&gt;表单(Form)&lt;/code&gt; 的绝佳机制也就不足为奇了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;表单(Form)&lt;/code&gt; 指的是用于&lt;strong&gt;收集信息&lt;/strong&gt;的用户输入控件的集合，例如 &lt;em&gt;订单表单&lt;/em&gt; 或 &lt;em&gt;设置界面&lt;/em&gt; 。&lt;/li&gt;
&lt;li&gt;更好的是，在表单中，SwiftUI 的几个部分会自适应放置——它们的外观和行为会发生变化，因此它们与其它输入控件组一起工作得更好。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你认为这很聪明，你会喜欢这个: 实际上 SwiftUI 会动态地调整布局，以便它可以根据代码运行的平台自动为我们生成全新的页面 - 它完全将控件的目的与它们的视觉效果分离开来。 这意味着我们描述了我们想要的东西，SwiftUI 找出了在当前平台上实现这一目标的惯用方法。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; &lt;code&gt;Form&lt;/code&gt; 和 &lt;code&gt;VStack&lt;/code&gt; 一样是常规容器，因此我们可以根据需要在这两者之间自由切换。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>5.9_如何使用隐式叠加</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/</link>
      <pubDate>Thu, 01 Aug 2019 23:23:26 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果创建一个动态列表并在每行中放置多个内容，会发生什么情况？SwiftUI 的解决方案简单、灵活，并且在默认情况下为我们提供了良好的行为: 它创建了一个隐式的 &lt;code&gt;HStack&lt;/code&gt; 来保存您的项目，因此它们会自动进行水平布局。
例如，如果我们想要创建一行，其中左侧有一张小图片，剩余的空间分配给一个文本字段，那么我们将从一个结构开始，这样保存数据:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User: Identifiable {
    var id = UUID()
    var username = &amp;quot;Anonymous&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我已经给出了这两个默认值，以便简化示例。
完成后，我们可以创建一个包含三个用户的数组，并在动态列表中显示它们，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    let users = [User(), User(), User()]

    var body: some View {
        List(users) { user in
            Image(&amp;quot;paul-hudson&amp;quot;)
                .resizable()
                .frame(width: 40, height: 40)
            Text(user.username)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_9_list_implicit_stacking.gif&#34; alt=&#34;5_9_list_implicit_stacking&#34; title=&#34;Implicit stacking&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.8_如何制作分组列表</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/</link>
      <pubDate>Thu, 01 Aug 2019 23:22:15 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 List 支持 &lt;em&gt;grouped&lt;/em&gt; 或 &lt;em&gt;plain&lt;/em&gt; 样式，就像 &lt;code&gt;UITableView&lt;/code&gt; 一样。默认为 &lt;em&gt;plain&lt;/em&gt; 样式，但如果要改为 &lt;em&gt;grouped&lt;/em&gt; 样式，则应使用 列表 的 &lt;code&gt;.listStyle(.grouped)&lt;/code&gt; 修饰符。
例如，这里定义了一个示例行，并将其放置在分组列表中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ExampleRow : View {
    var body: some View {
        Text(&amp;quot;Example Row&amp;quot;)
    }
}

struct ContentView : View {
    var body: some View {
        List {
            Section(header: Text(&amp;quot;Examples&amp;quot;)) {
                ExampleRow()
                ExampleRow()
                ExampleRow()
            }
        }.listStyle(.grouped)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_8_list_grouped_style.gif&#34; alt=&#34;5_8_list_grouped_style&#34; title=&#34;List - grouped style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.7_如何向列表中添加sections</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/</link>
      <pubDate>Thu, 01 Aug 2019 23:21:13 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/</guid>
      <description>&lt;p&gt;SwiftUI 的列表视图内置了对 &lt;em&gt;sections&lt;/em&gt; 和 &lt;em&gt;section headers&lt;/em&gt; 的支持，就像 UIKit 中的 &lt;code&gt;UITableView&lt;/code&gt; 一样。若要给某些 cells 添加一个 _section_，首先在其周围放置一个 &lt;code&gt;Section&lt;/code&gt;，也可以添加 &lt;em&gt;header&lt;/em&gt; 和 _footer_。
举个例子，这里有一行包含提醒应用的任务数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct TaskRow: View {
    var body: some View {
        Text(&amp;quot;Task data goes here&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们要做的是创建一个列表视图，它有两个Sections：一个用于重要任务，另一个用于次要任务。这是它的样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        List {
            Section(header: Text(&amp;quot;Important task&amp;quot;)) {
                TaskRow()
                TaskRow()
                TaskRow()
            }
            Section(header: Text(&amp;quot;Other task&amp;quot;)) {
                TaskRow()
                TaskRow()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_7_list_sections.gif&#34; alt=&#34;5_7_list_sections&#34; title=&#34;List sections&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.6_如何使用EditButton在列表上启用编辑</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/</link>
      <pubDate>Wed, 31 Jul 2019 00:40:13 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/</guid>
      <description>&lt;p&gt;如果您已配置 SwiftUI 列表视图以支持删除或编辑其项目，则可以允许用户通过在某个地方添加 &lt;code&gt;EditButton&lt;/code&gt; 来切换列表视图的编辑模式。
例如，这个 ContentView 结构定义了一个用户数组，附加了一个 &lt;code&gt;OnDelete()&lt;/code&gt; 方法，然后在导航栏中添加了一个编辑按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var users = [&amp;quot;Paul&amp;quot;, &amp;quot;Taylor&amp;quot;, &amp;quot;Adele&amp;quot;]
    
    var body: some View {
        NavigationView {
            List {
                ForEach(users.identified(by: \.self)) { user in
                    Text(user)
                }
                .onDelete(perform: delete)
            }
            .navigationBarItems(trailing: EditButton())
        }
    }
    
    func delete(at offsets: IndexSet) {
        if let first = offsets.first {
            users.remove(at: first)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后，您会发现您可以点击编辑按钮来启用或禁用列表中项目的编辑模式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.5_如何让用户移动列表中的行</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/</link>
      <pubDate>Wed, 31 Jul 2019 00:26:20 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 为我们提供了简单地列表挂钩（hooks），让我们可以移动行(rows)，尽管 WWDC 上演示的一些功能在当前的测试版中实际上不可用，所以我们需要一个变通的解决方法。
我们可以将 &lt;code&gt;onMove(perform:)&lt;/code&gt; 修饰符附加到列表中的项目，并让它在移动操作发生时调用我们选择的方法。 该方法需要接受 source IndexSet 和 destination Int，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func move(from source: IndexSet, to destination: Int) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移动多个项目时，最好先移动后一个项目，这样可以避免移动其他项目并混淆索引
例如，我们可以创建一个 ContentView 结构，它设置一个由三个用户名字符串组成的数组，并要求SwiftUI在调用 &lt;code&gt;move()&lt;/code&gt;方法时移动它们。为了激活“移动”（即显示拖动手柄），它还向导航视图添加了一个编辑按钮，以便用户切换编辑模式。
这是代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var users = [&amp;quot;Paul&amp;quot;, &amp;quot;Taylor&amp;quot;, &amp;quot;Adele&amp;quot;]
    
    var body: some View {
        NavigationView {
            List {
                ForEach(users, id: \.self, content: { user in
                    Text(user)
                })
                .onMove(perform: move)
            }
            .navigationBarItems(trailing: EditButton())
        }
    }
    
    func move(from source: IndexSet, to destination: Int) {
        // sort the indexes low to high
        let reverseSource = source.sorted()
        
        // then loop from the back to avoid reordering problems
        for index in reverseSource.reversed() {
            // for each item, remove it and insert it at the destination
            users.insert(users.remove(at: index), at: destination)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_5_list_move_row.gif&#34; alt=&#34;5_5_list_move_row&#34; title=&#34;Move row&#34; /&gt;
在WWDC会话演示中，他们的 &lt;code&gt;move()&lt;/code&gt; 方法只是一行代码，因为它在 Swift 数组上使用了一个对我们不可用的扩展——希望它很快就会到来！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.4_如何让用户从列表中删除行</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/</link>
      <pubDate>Tue, 30 Jul 2019 23:55:31 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过将 &lt;code&gt;OnDelete(perform:)&lt;/code&gt; 处理程序附加到部分或全部数据，SwiftUI 可以方便地让用户滑动以删除行。此处理程序需要具有一个特定签名，它可以接受多个索引以删除，如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func delete(at offsets: IndexSet) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，您可以循环访问集合中的每个索引，或者只读取第一个索引（如果您只想处理它的话）。因为SwiftUI 正在监视您的状态，所以您所做的任何更改都将自动反映在您的UI中。
注意：此功能的 WWDC 演示使用了一个名为 &lt;code&gt;remove(atOffsets:)&lt;/code&gt; 的不存在的Swift数组方法，它为我们完成了所有这些工作 - 希望这将在未来版本中出现。
例如，此代码创建一个包含三个项目列表的 ContentView 结构，然后附加一个 &lt;code&gt;OnDelete(perform:)&lt;/code&gt; 修饰符，用于删除列表中的任何项目:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State var users = [&amp;quot;Paul&amp;quot;, &amp;quot;Taylor&amp;quot;, &amp;quot;Adele&amp;quot;]
    
    var body: some View {
        List {
            ForEach(users, id: \.self) { user in
                Text(user)
            }
            .onDelete(perform: delete)
        }
    }
    
    func delete(at offsets: IndexSet) {
        if let first = offsets.first {
            users.remove(at: first)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_4_list_delete_row.gif&#34; alt=&#34;5_4_list_delete_row&#34; title=&#34;Delete a row&#34; /&gt;
如果您运行该代码，您会发现可以滑动以删除列表中的任何行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.3_如何创建动态项目列表</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jul 2019 22:26:03 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;为了处理动态项目，我们必须首先告诉 SwiftUI 如何识别哪个项目是哪个。 这是使用 &lt;code&gt;Identifiable&lt;/code&gt; 协议完成的，该协议只有一个要求: 某种类型的 id 值，SwiftUI 可以使用它来查看哪个项目是哪个。
例如，我们可以创建一个 &lt;code&gt;Restaurant&lt;/code&gt; 结构体，该结构表示餐馆具有 ID 和 name ，ID 是一个随机标识符，以便 SwiftUI 知道哪个是哪个:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Restaurant: Identifiable {
    var id = UUID()
    var name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们将定义列表行的外观。在我们的例子中，我们将定义一个 &lt;code&gt;Restaurantrow&lt;/code&gt; 视图，该视图存储一个餐厅并在文本视图中打印其名称:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow : View {
    
    var restaurant: Restaurant
    
    var body: some View {
        Text(&amp;quot;Come and eat at \(restaurant.name)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们可以创建一个列表视图来显示所有内容。这意味着创建一些示例数据，将其放入数组中，然后将其传递到要呈现的列表中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var body: some View {
        
        let first = Restaurant(name: &amp;quot;Joe&#39;s Original&amp;quot;)
        let second = Restaurant(name: &amp;quot;The Real Joe&#39;s Original&amp;quot;)
        let third = Restaurant(name: &amp;quot;Original Joe&#39;s&amp;quot;)
        let restaurants = [first, second, third]
        
        return List(restaurants) { restaurant in
            RestaurantRow(restaurant: restaurant)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中大部分只是创建数据——最后一部分是实际操作的地方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;return List(restaurants) { restaurant in
    RestaurantRow(restaurant: restaurant)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它从 restaurants 数组创建一个列表，对数组中的每个项目执行一次闭包。每次执行闭包时，餐厅的输入都将由数组中的一个项目填充，因此我们使用它来创建一个 Restaurantrow。
事实上，在这种小case下，我们可以使代码更短:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;return List(restaurants, rowContent: RestaurantRow.init)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_3_list_dynamic_items_list.gif&#34; alt=&#34;5_3_list_dynamic_items_list&#34; title=&#34;Dynamic list&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.2_如何创建静态项列表</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jul 2019 00:23:02 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;要创建静态项目列表，首先需要定义列表中每行的外观。 这是一个与其他视图一样的视图，因此您可以编写如下的视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow : View {
    
    var name: String
    
    var body: some View {
        Text(&amp;quot;Restaurant: \(name)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然已经定义了每一行的外观，那么就可以创建一个 &lt;code&gt;List&lt;/code&gt;，根据需要创建任意数量的行，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        List {
            RestaurantRow(name: &amp;quot;Joe&#39;s Original&amp;quot;)
            RestaurantRow(name: &amp;quot;The Real Joe&#39;s Original&amp;quot;)
            RestaurantRow(name: &amp;quot;Original Joe&#39;s&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_2_list_static_items_list.gif&#34; alt=&#34;5_2_list_static_items_list&#34; title=&#34;static list&#34; /&gt;
当该代码运行时，您将在表中看到三行，就像您在 UIKit 中使用 &lt;code&gt;UITableView&lt;/code&gt; 一样。
您不需要使每一行使用相同的视图类型，因此您可以根据需要混合和匹配行视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.1_使用List</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/</link>
      <pubDate>Mon, 29 Jul 2019 01:40:08 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;List&lt;/code&gt; 视图类似于 &lt;code&gt;UITableView&lt;/code&gt;，它可以根据您的需要显示静态或动态表视图单元格(table view cells)。 但是，它使用起来要简单得多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们不需要在 storyboard 中创建原型cell( &lt;em&gt;prototype cell&lt;/em&gt; );&lt;/li&gt;
&lt;li&gt;也不需要在代码中注册 Cell;&lt;/li&gt;
&lt;li&gt;我们不需要告诉它有多少行;&lt;/li&gt;
&lt;li&gt;我们不需要手动出列(dequeue)和配置单元格等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相反，SwiftUI 的列表是为可组合性而设计的 - 旨在能够从较小的东西构建更大的东西。 因此，SwiftUI 不需要一个手动配置单元的大视图控制器，而是让我们构建小视图，知道如何将自己配置为列表行，然后使用它们。&lt;/p&gt;

&lt;p&gt;在代码大小方面（如果没有其他的话），差异是惊人的——您可以删除几乎所有的表视图代码，仍然可以获得与您习惯的相同的出色外观和感觉。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4.3_如何使用@EnvironmentObject在视图之间共享数据</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 29 Jul 2019 01:17:25 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;对于应该与整个应用程序中所有视图共享的数据，SwiftUI 为我们提供了 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 。这使我们可以在任何需要的地方共享模型数据，同时确保当模型数据发生变化时，我们的视图自动保持更新。&lt;/p&gt;

&lt;p&gt;可以将 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 看作是在多个视图中使用 &lt;code&gt;@ObjectBinding&lt;/code&gt; 的一种更智能、更简单的方法。而不是在视图 A 中创建一些数据，然后将其传递给视图 B，然后查看视图 C，然后在最终使用数据之前查看视图 D，我们可以在视图中创建它并将其放入环境（environment）中，这样的话，视图B、C、D将会自动访问它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 环境对象必须由祖先视图（ancestor view）提供 &amp;ndash; 如果 SwiftUI 找不到正确类型的环境对象，将会导致崩溃（crash），这也适用于预览，所以要小心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 这里有一个可绑定对象，用于存储用户设置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Combine
import SwiftUI
​
class UserSettings: BindableObject {
    
    var didChange = PassthroughSubject&amp;lt;Void, Never&amp;gt;()
    
    var score = 0 {
        didSet {
            didChange.send(())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，它只存储一个值，但是没关系 &amp;ndash; 重要的是: 当值发生改变时，&lt;code&gt;PassthroughSubject&lt;/code&gt; 会告诉所有使用它（这个值）的的视图进行刷新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用户设置&lt;/strong&gt; 是我们可能希望能够在应用程序的任何地方共享的一个合理的数据，这样我们就不再需要手动处理同步。&lt;/p&gt;

&lt;p&gt;因此，当我们的应用程序首次启动时，我们将创建一个 &lt;code&gt;UserSettings&lt;/code&gt; 的实例。以便在我们的应用程序中随处都可以访问共享实例。&lt;/p&gt;

&lt;p&gt;如果打开 &lt;em&gt;Scenedelegate.swift&lt;/em&gt; ，您将在 &lt;code&gt;（_:willConnectTo:options:）&lt;/code&gt;方法：中找到这两行代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let window = UIWindow(windowScene: windowScene)
window.rootViewController = UIHostingController(rootView: ContentView())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行代码创建我们的初始内容视图（ContentView）并将其显示到屏幕上。这就是我们需要传入我们创建的任何环境对象的地方，以便 SwiftUI 可以在 ContentView 以及它使用的任何其它视图中使用我们创建的环境对象。&lt;/p&gt;

&lt;p&gt;首先，将其添加为 &lt;code&gt;SceneDelegate&lt;/code&gt; 的一个属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var settings = UserSettings() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会创建一个 &lt;em&gt;settings&lt;/em&gt; 实例，并安全地存储它。现在回到刚才展示的那两行代码，并更改第二行，以便将我们的 &lt;em&gt;settings&lt;/em&gt; 属性作为环境对象传递给 &lt;code&gt;ContentView&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;window.rootViewController = UIHostingController(rootView: ContentView().environmentObject(settings))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，共享的 &lt;code&gt;UserSettings&lt;/code&gt; 实例可用于 ContentView 以及它承载（hosts）或展现（presents）的任何其它视图。你只需要使用 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 属性包装器创建一个属性，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@EnvironmentObject var settings: UserSettings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不需要使用默认值进行初始化，因为它将自动从环境中读取。&lt;/p&gt;

&lt;p&gt;因此，我们可以创建一个 &lt;code&gt;ContentView&lt;/code&gt; 结构来增加我们的分数设置，甚至使它呈现出一个显示分数设置的 &lt;code&gt;Detailview&lt;/code&gt;，所有这些都不需要创建或传递任何 &lt;code&gt;UserSettings&lt;/code&gt; 的本地实例 &amp;ndash; 它总是使用环境。&lt;/p&gt;

&lt;p&gt;以下是实现这一目标的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @EnvironmentObject var settings: UserSettings
    
    var body: some View {
        NavigationView {
            VStack {
                Button(action: {
                    self.settings.score += 1
                }) {
                    Text(&amp;quot;Increase score&amp;quot;)
                }
                
                NavigationButton(destination: DetailView()) {
                    Text(&amp;quot;Show Detail View&amp;quot;)
                }
            }
        }
    }
}
​
struct DetailView : View {
    
    @EnvironmentObject var settings: UserSettings
    
    var body: some View {
        // A text view that reads from the environment settings
        Text(&amp;quot;Score: \(settings.score)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，一旦你将一个对象注入到环境中，你就可以立即在顶层视图中或者在下面的十层视图中使用它——这并不重要。最重要的是，每当任何视图改变环境时，依赖它的所有视图都会自动刷新，从而保持同步。&lt;/p&gt;

&lt;p&gt;如你所见，我们不需要将场景代理（scene delegate）中的 &lt;code&gt;UserSettings&lt;/code&gt; 实例与我们两个视图中的 &lt;code&gt;settings&lt;/code&gt; 属性显式关联 - SwiftUI 会自动发现它在环境中有一个 &lt;code&gt;UserSettings&lt;/code&gt; 实例，因此这就是要使用的实例。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;警告：既然我们的视图依赖于存在的环境对象，那么您还必须更新预览代码以提供一些要使用的示例设置。例如，使用 &lt;code&gt;ContentView().EnvironmentObject(UserSettings())&lt;/code&gt; 进行预览应该可以做到这一点。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>4.2_如何使用@ObjectBinding创建对象绑定</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Mon, 29 Jul 2019 00:09:24 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-两件重要的事情&#34;&gt;1. 两件重要的事情&lt;/h3&gt;

&lt;p&gt;当使用对象绑定时，我们需要处理两个细微不同的东西:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BindableObject 协议，用于一些可以存储数据的类。&lt;/li&gt;
&lt;li&gt;@ObjectBinding 属性包装器，在视图中用于存储可绑定对象实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;举个例子，这是一个遵循 &lt;code&gt;BindableObject&lt;/code&gt; 协议的 &lt;code&gt;UserSettings&lt;/code&gt; 类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Combine
import SwiftUI

class UserSettings: BindableObject {
    var didChange = PassthroughSubject&amp;lt;Void, Never&amp;gt;()
    
    var score = 0 {
        didSet {
            didChange.send(())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码代码量很小，但是却包含了相当多的知识点，接下来我们逐一解释:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一: &lt;code&gt;didChange&lt;/code&gt;是 &lt;code&gt;PassthroughSubject&lt;/code&gt; 的一个实例。

&lt;ul&gt;
&lt;li&gt;这个类来自 &lt;code&gt;Combine&lt;/code&gt; 框架，我们需要添加 &lt;code&gt;import Combine&lt;/code&gt; 以使我们的代码能够编译。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;passthrough subject&lt;/em&gt; 的工作很简单: 每当我们想要告诉世界我们的对象发生了变化，我们就要求  &lt;em&gt;passthrough subject&lt;/em&gt; 为我们做这件事情。它被称为 &lt;em&gt;pass through&lt;/em&gt; ，因为我们传递给它的值实际上会传递给任何正在观察变化对象的视图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PassthroughSubject&lt;/code&gt; 在技术上被称为 &lt;em&gt;publisher&lt;/em&gt; ，因为它对世界发布了变化的公告。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二: &lt;code&gt;PassthroughSubject&lt;/code&gt; 是 &lt;code&gt;Void&lt;/code&gt; 和 &lt;code&gt;Never&lt;/code&gt; 的泛型。

&lt;ul&gt;
&lt;li&gt;第一个参数 &lt;code&gt;Void&lt;/code&gt; 意味着 &amp;ldquo;&lt;strong&gt;我不发送任何值&lt;/strong&gt;&amp;ldquo;。在 SwiftUI 的情况下，我们不需要发送值，因为我们想要的是视图刷新 - 它将自动从 &lt;code&gt;@ObjectBinding&lt;/code&gt; 状态中获取新数据。&lt;/li&gt;
&lt;li&gt;第二个参数 &lt;code&gt;Never&lt;/code&gt;，意味着 &amp;ldquo;&lt;strong&gt;我永远不会抛出错误&lt;/strong&gt;&amp;ldquo;。如果你想，你可以定义一个自定义的错误类型，如 &lt;code&gt;NetworkError&lt;/code&gt;，并将其发送，但是通常会发现在可绑定对象内部本地处理错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三: 我们在 &lt;code&gt;UserSettings&lt;/code&gt; 的 &lt;em&gt;score&lt;/em&gt; 属性上附加了一个 &lt;code&gt;didSet&lt;/code&gt; 属性观察器，这样我们就可以在该值发生变化时运行代码。 在我们的示例代码中，每当得分发生变化时，我们都会调用 &lt;code&gt;didChange.send(())&lt;/code&gt;，这就是告诉 &lt;code&gt;didChange&lt;/code&gt; 发布者发布我们的数据已更改的消息，以便任何订阅的视图都可以刷新。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以在这样的视图中使用 &lt;code&gt;UserSettings&lt;/code&gt;类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @ObjectBinding var settings = UserSettings()
    
    var body: some View {
        VStack {
            Text(&amp;quot;Your score is \(settings.score)&amp;quot;)
            Button(action: {
                self.settings.score += 1
            }) {
                Text(&amp;quot;Increase Score&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你所看到的，除了使用带有 &lt;code&gt;@ObjectBinding&lt;/code&gt; 属性包装器的 &lt;em&gt;settings&lt;/em&gt; 之外，其他所有内容都或多或少看起来相同 - SwiftUI 负责处理我们的所有实现细节。
但是有一个重要区别: &lt;em&gt;settings&lt;/em&gt; 属性未声明为 &lt;code&gt;private&lt;/code&gt;。 这是因为绑定对象可以被多个视图使用，因此通常会公开共享它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;警告: 当您使用 publisher 宣布您的对象已更改时，这必须在主线程上发生。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>4.1_@ObjectBinding、@State 和 @EnvironmentObject三者之间的区别</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 28 Jul 2019 22:31:35 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-state&#34;&gt;1. &lt;code&gt;@State&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在任何现代应用程序中，&lt;strong&gt;状态（State）&lt;/strong&gt;都是不可避免的。&lt;/p&gt;

&lt;p&gt;但是对于 SwiftUI 来说，重要的是要记住:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们所有的视图都只是它们的状态的函数&lt;/li&gt;
&lt;li&gt;我们不会直接改变视图，而是操纵状态并让它决定结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SwiftUI 为我们提供了几种在应用程序中存储状态的方法，但是它们之间略有不同，理解它们之间的区别对于正确使用框架是很重要的。&lt;/p&gt;

&lt;p&gt;到目前为止，在我们所有的状态示例中，我们都使用 &lt;code&gt;@State&lt;/code&gt; 来创建如下属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    @State var score = 0
    // more code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码在视图中创建了一个属性，但它使用 &lt;code&gt;@State&lt;/code&gt; 属性包装器（property wrapper）来请求 SwiftUI 来管理内存。这一点很重要: 我们所有的视图都是结构体（structs），这意味着它们不能被改变，如果我们不能在一场比赛中给一个分数加1，那么这就不是一场比赛了。&lt;/p&gt;

&lt;p&gt;因此，当我们使用 &lt;code&gt;@State&lt;/code&gt; 创建一个属性时，就意味着将该属性的控制权交给了 SwiftUI，这样的话，只要视图存在，它就在内存中保持不变。当该状态发生变化时，SwiftUI 知道用最新的变化自动重新加载视图，以便反映其新信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@State&lt;/code&gt; 对于属于特定视图且从未在该视图之外使用的简单属性非常有用，因此通常最好将这些属性标记为私有属性，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@State private var score = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这再次强化了这样一种观点，即这种状态是专门设计的，永远不会脱离它的视图。简单理解，就是在视图内部使用的。&lt;/p&gt;

&lt;h3 id=&#34;2-objectbinding&#34;&gt;2. &lt;code&gt;@ObjectBinding&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;对于更复杂的属性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当你有一个要使用的自定义类型，该类型可能具有多个属性和方法&lt;/li&gt;
&lt;li&gt;可能在多个视图中共享时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，你应该使用 &lt;code&gt;@ObjectBinding&lt;/code&gt;。
这与 &lt;code&gt;@State&lt;/code&gt; 非常相似，只是现在我们使用的是外部引用类型，而不是简单地本地属性，如字符串或整数。我们仍然可以说视图取决于要更改的数据，除了我们负责管理自己的数据: 我们需要创建类的实例，创建自己的属性，等等。&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;@ObjectBinding&lt;/code&gt; 一起使用的任何类型都应该遵循 &lt;code&gt;BindableObject&lt;/code&gt; 协议，该协议只有一个要求: 您的类型必须实现某种类型的 &lt;code&gt;didchange&lt;/code&gt; 属性，该属性在数据发生更改时通知视图。&lt;/p&gt;

&lt;p&gt;这就是我的意思，当我说这是你负责管理自己的数据时——当你在绑定对象上设置一个属性时，你就可以决定是否应该强制视图刷新。你通常会的，但不是必须的。&lt;/p&gt;

&lt;p&gt;一个可绑定的对象可以使用 &lt;code&gt;Combine&lt;/code&gt; 框架中 &lt;em&gt;publisher&lt;/em&gt;  通知其视图重要数据已经更改。如果碰巧有几个视图使用可绑定对象的数据，那么它将自动通知所有这些视图。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;警告:&lt;/strong&gt; 当你使用 &lt;em&gt;publisher&lt;/em&gt; 宣布你的对象已更改，这个动作必须在主线程上执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;3-environmentobject&#34;&gt;3. &lt;code&gt;@EnvironmentObject&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们已经了解了如何通过 &lt;code&gt;@State&lt;/code&gt; 声明一个类型的简单属性，该类型数据在发生更改时自动导致视图更新，以及如何通过 &lt;code&gt;@Objectbinding&lt;/code&gt; 声明外部类型的属性，该属性在更改时可能会或可能不会导致视图更新。这两个都必须由我们的视图设置，但是 &lt;code&gt;@Objectbinding&lt;/code&gt; 可能与其他视图共享。&lt;/p&gt;

&lt;p&gt;针对这种情况，我们还有第三种类型的属性可供使用，即 &lt;code&gt;@EnvironmentObject&lt;/code&gt;。这是一个通过应用程序本身对视图可用的值 -&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它是每个视图都可以读取的共享数据，因此，如果你的应用程序有一些重要的模型数据，所有视图都需要读取，你可以把它从一个视图传递到另一个视图，或者把它放到每个视图都可以即时访问的环境中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们需要在应用程序中传递大量数据时，可以将 &lt;code&gt;@Environmentobject&lt;/code&gt; 视为一种极大的便利。由于所有视图都指向同一模型，因此如果一个视图更改模型，则所有视图都会立即更新 - 不会有使应用程序的不同部分不同的风险。&lt;/p&gt;

&lt;h3 id=&#34;4-总结差异&#34;&gt;4. 总结差异&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;@State&lt;/code&gt; 用于属于单个视图的简单属性。 它们通常应标记为 &lt;code&gt;private&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;@ObjectBinding&lt;/code&gt; 用于可能属于多个视图的复杂属性。 无论何时使用引用类型，都应该使用&lt;code&gt;@ObjectBinding&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 用于在应用程序中其他位置创建的属性，例如共享数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这三种方法中，您会发现 &lt;code&gt;@objectbinding&lt;/code&gt; 是最有用和最常用的，因此如果您不确定要使用哪种方法，请从那里开始。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.14_如何响应视图生命周期事件_appear_and_disappear</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/</link>
      <pubDate>Sun, 28 Jul 2019 20:37:20 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 以 &lt;code&gt;onAppear()&lt;/code&gt; 和 &lt;code&gt;onDisappear()&lt;/code&gt; 的形式为我们提供了 UIKit 的&lt;code&gt;viewDidAppear()&lt;/code&gt; 和 &lt;code&gt;viewDidDisappear()&lt;/code&gt; 的等价物。 您可以将任何代码附加到您想要的这两个事件，SwiftUI 将在它们发生时执行它们。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;注意：在当前的beta版本， onAppear() 工作得很好，但 onDisappear() 似乎没有被调用。
例如: 我们创建两个使用 onAppear() 和 onDisappear() 来打印消息的视图，并使用导航按钮在两者之间移动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView()) {
                Text(&amp;quot;Hello World&amp;quot;)
            }
        }.onAppear {
            print(&amp;quot;ContentView appeared!&amp;quot;)
        }.onDisappear {
            print(&amp;quot;ContentView disappeared!&amp;quot;)
        }
    }
}

struct DetailView : View {
    var body: some View {
        VStack {
            Text(&amp;quot;Second View&amp;quot;)
        }.onAppear {
            print(&amp;quot;DetailView appeared!&amp;quot;)
        }.onDisappear {
            print(&amp;quot;DetailView disappeared!&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_14_live_event_appear_disappear.gif&#34; alt=&#34;3_14_live_event_appear_disappear&#34; title=&#34;onAppear and onDisappear&#34; /&gt;
当代码运行时，我们应该能够在两个视图之间移动，并看到 Xcode 调试控制台中打印的消息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.13_如何给视图添加手势识别器</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/</link>
      <pubDate>Sun, 28 Jul 2019 19:59:32 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;任何 SwiftUI  视图都可以附加手势识别器，而这些手势识别器又可以附加闭包，在识别器被激活时执行闭包。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;有几个手势识别器可供使用，这里我们提供其中几个的代码示例，以帮助入门 - 我们将看到它们有多相似。&lt;/p&gt;

&lt;h4 id=&#34;2-1-tapgesture-点击手势&#34;&gt;2.1 &lt;code&gt;TapGesture&lt;/code&gt; 点击手势&lt;/h4&gt;

&lt;p&gt;创建 TapGesture 时，可以指定触发手势所需的 点击次数，然后附加将在手势发生时运行的 &lt;code&gt;onEnded&lt;/code&gt; 闭包。&lt;/p&gt;

&lt;p&gt;例如，我们来创建一个每次点击时都会变大的图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var scale: Length = 1
    
    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .scaleEffect(scale)
            .gesture(
                TapGesture()
                    .onEnded({ (_) in
                        self.scale += 0.1
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_13_tap_gesture_scale_image.gif&#34; alt=&#34;3_13_tap_gesture_scale_image&#34; title=&#34;Tap to scale a image&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-2-longpressgesture-长按手势&#34;&gt;2.2 &lt;code&gt;LongPressGesture&lt;/code&gt; 长按手势&lt;/h4&gt;

&lt;p&gt;LongPressGesture 可识别用户何时按下视图并保持至少一段用户指定的时间。
因此，我们创建一个图像视图，在按下该消息至少两秒时打印该消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {

    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .gesture(
                LongPressGesture(minimumDuration: 2.0)
                    .onEnded({ (_) in
                            print(&amp;quot;LongPressed!&amp;quot;)
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_13_long_press_gesture_duration_2s.gif&#34; alt=&#34;3_13_long_press_gesture_duration_2s&#34; title=&#34;Long pressed!&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-3-draggesture-拖拽手势&#34;&gt;2.3 &lt;code&gt;DragGesture&lt;/code&gt; 拖拽手势&lt;/h4&gt;

&lt;p&gt;最后，当用户按下视图并移动至少一定距离时，DragGesture 会触发。因此，我们创建一个带有拖动手势的图像，当它们移动至少50个点时会触发:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
 
    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .gesture(
                DragGesture(minimumDistance: 50)
                    .onEnded({ (_) in
                        print(&amp;quot;Dragged!&amp;quot;)
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/3_13_drag_gesture_distance_50.gif&#34; alt=&#34;3_13_drag_gesture_distance_50&#34; title=&#34;Drag gesture&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.12_如何设置tap和double Tap手势</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/</link>
      <pubDate>Sun, 28 Jul 2019 18:38:38 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;任何 SwiftUI 视图都可以附加 &lt;code&gt;点击操作(tap action)&lt;/code&gt;，我们可以指定在触发操作之前应该接收多少次点击。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个文本视图，在点击时将打印消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        Text(&amp;quot;Tap me!&amp;quot;)
            .tapAction {
                print(&amp;quot;Tapped&amp;quot;)
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/tap_gesture_tap_text.gif&#34; alt=&#34;tap_gesture_tap_text&#34; title=&#34;Tap a text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再创建一个图像视图，当双击时将打印消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        Image(&amp;quot;example-img&amp;quot;)
            .tapAction(count: 2) {
                print(&amp;quot;Double tapped!&amp;quot;)
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/tap_gesture_double_tap_image.gif&#34; alt=&#34;tap_gesture_double_tap_image&#34; title=&#34;Double tapped!&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.11_如何创建分段控件并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 10:16:45 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI中 的 &lt;code&gt;SegmentedControl&lt;/code&gt; 与 UIKit中的 &lt;code&gt;UISegmentedControl&lt;/code&gt; 的工作方式类似，但是它需要绑定到某种状态（state），并且必须确保为每个分段（segment）提供一个 tag 标记，以便能够识别它。&lt;strong&gt;分段(Segments) 可以是文本或者图片，其它任何东西都会自动失败&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;我们将创建一个分段控件，该控件使用 &lt;code&gt;favoriteColor&lt;/code&gt; 作为状态属性，并且在下面添加一个文本视图，用于显示所选的任何值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var favoriteColor = 0
    
    var body: some View {
        VStack {
            SegmentedControl(selection: $favoriteColor) {
                Text(&amp;quot;Red&amp;quot;).tag(0)
                Text(&amp;quot;Green&amp;quot;).tag(1)
                Text(&amp;quot;Blue&amp;quot;).tag(2)
            }
            Text(&amp;quot;Value: \(favoriteColor)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/segmented_control_favoritecolor.gif&#34; alt=&#34;segmented_control_favoritecolor&#34; title=&#34;Select a favorite color&#34; /&gt;
不过，在本例中，我们最好创建一个数组来存储各种颜色，然后使用 &lt;em&gt;foreach&lt;/em&gt; 在内部使用循环创建文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var favoriteColor = 0

    var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        VStack {
            SegmentedControl(selection: $favoriteColor) {
                ForEach(0..&amp;lt;colors.count) { index in
                    Text(self.colors[index]).tag(index)
                }
            }
            Text(&amp;quot;Value: \(colors[favoriteColor])&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/segmented_control_favoritecolor_string.gif&#34; alt=&#34;segmented_control_favoritecolor_string&#34; title=&#34;select a favorite color, display with string&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.10_如何创建DatePicker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 00:28:44 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;DatePicker&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UIDatePicker&lt;/code&gt;，它提供了各种选项来控制它的外观和工作方式。和所有存储值的控件一样，它也需要绑定到应用程序中的某种状态。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到 &lt;code&gt;birthDate&lt;/code&gt; 属性的日期选择器，然后显示日期选择器的值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        return formatter
    }
    
    @State var birthDate = Date()
    
    var body: some View {
        VStack {
            DatePicker($birthDate,
                       maximumDate: Date(),
                       displayedComponents: .date)
            Text(&amp;quot;Date is \(birthDate, formatter: dateFormatter)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/datepicker_select_birthdate.gif&#34; alt=&#34;datepicker_select_birthdate&#34; title=&#34;Select birth date&#34; /&gt;
可以看到我已经将 &lt;strong&gt;DisplayedComponents&lt;/strong&gt; 设置为 .Date，但您也可以使用 &lt;code&gt;.hourAndMinute&lt;/code&gt;来获取时间数据。
我还使用 &lt;em&gt;maximumDate&lt;/em&gt; 来阻止人们在将来指定出生日期，但是您可以指定 &lt;em&gt;minimumDate&lt;/em&gt; 来阻止人们指定早于您选择的日期。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.9_如何创建选择器Picker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:56:24 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Picker&lt;/code&gt; 视图将 UIPicker 和 UITableView 结合在一起。同时也适应其它操作系统上的其它样式。最棒的是我们真的不需要关系它是如何工作的 &amp;ndash; SwiftUI 可以很好的自动适应它的环境。
与大多数其它控件一样，必须将 picker 附加到某种 state，以跟踪 picker 的选择。例如: 这会创建一个 colors 数组和一个存储所选颜色的整数，然后将其与 picker，Text 视图一起使用，以便您可以看到正在读取的值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Orange&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Green&amp;quot;]
    @State private var selectedColor = 0
    
    var body: some View {
        VStack {
            Picker(selection: $selectedColor, label: Text(&amp;quot;Please choose a color&amp;quot;)) {
                ForEach(0..&amp;lt;colors.count) {
                    Text(self.colors[$0]).tag($0)
                }
            }
            Text(&amp;quot;You selected: \(colors[selectedColor]) &amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/picker_select_color.gif&#34; alt=&#34;picker_select_color&#34; title=&#34;Selected color&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意: 将选择器视图放在某个内容中非常重要，以确保它在iOS上以默认的轮子样式显示。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.8_如何创建Slider并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:40:23 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Slider&lt;/code&gt; 视图的工作原理与 &lt;code&gt;UISlider&lt;/code&gt; 非常相似，尽管您需要将其绑定到某个地方，以便存储其值。
当我们创建它时，可以提供多种参数，但我们可能最关心的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Value&lt;/code&gt;:  要绑定到的值是多少&lt;/li&gt;
&lt;li&gt;&lt;code&gt;From and To&lt;/code&gt;: 滑块的范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;By&lt;/code&gt;: 移动滑块时要更改多少值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到  Celsius 属性的滑块，然后在滑块移动时更新文本视图，以便在 &lt;strong&gt;Celsius(摄氏温度)&lt;/strong&gt; 和 &lt;strong&gt;Fahrenheit(华氏温度)&lt;/strong&gt; 之间进行转换:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var celsius: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $celsius, from: -100, through: 100, by: 0.1)
                .padding()
            Text(&amp;quot;\(celsius) Celsius is \(celsius * 9 / 5 + 32) Fahrenheit&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/slider_celsius_to_fahrenheit.gif&#34; alt=&#34;slider_celsius_to_fahrenheit&#34; title=&#34;celsius to fahrenheit&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.7_如何使用SecureField创建一个安全的文本输入框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 23:33:00 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;SecureTextField&lt;/code&gt; 的工作方式与常规的 &lt;code&gt;TextField&lt;/code&gt; 完全相同，只是为了保护隐私而屏蔽了字符。当然，它绑定的底层值（underlying value）仍然是一个普通的字符串，因此你可以根据需要检查它。
下面是一个示例，创建了一个绑定到本地 &lt;code&gt;@State&lt;/code&gt;  属性的 &lt;code&gt;SecureField&lt;/code&gt;，以便我们显示键入的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var password = &amp;quot;&amp;quot;
    
    var body: some View {
        VStack {
            SecureField($password, placeholder: Text(&amp;quot;Enter your password:&amp;quot;))
                .padding()
            Text(&amp;quot;Your entered: \(password)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/securefield_enter_password.gif&#34; alt=&#34;securefield_enter_password&#34; title=&#34;enter a password&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提示: 在 beta1 和 beta2 中，你应该使用:
SecureField($password)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.6_如何给TextField添加占位符</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</link>
      <pubDate>Sat, 27 Jul 2019 22:59:59 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 支持占位符文本，就像 &lt;code&gt;UITextField&lt;/code&gt; 一样 &amp;ndash; 当 TextField 为空时在 TextField 中显示灰色文本。要么使用提示（”Enter your password“），要么显示一些示例数据。&lt;/p&gt;

&lt;p&gt;要设置 placeholder，请将其作为 TextField 初始化设置的一部分传入，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var emailAddress = &amp;quot;&amp;quot;
    
    var body: some View {
        TextField($emailAddress, placeholder: Text(&amp;quot;test@gmail.com&amp;quot;))
            .textFieldStyle(.roundedBorder)
            .padding()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/textfield_placeholder.png &amp;quot;Set a placeholder for text field&#34; alt=&#34;textfield_placeholder&#34; /&gt;
这将在 TextField 中显示占位文本 &lt;code&gt;test@gmail.com&lt;/code&gt;，而 TextField 为空，但一旦用户在其中键入内容，占位文本就会消失。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.5_如何给TextField添加边框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 22:42:34 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更愿意在 &lt;code&gt;TextField&lt;/code&gt; 周围添加边框，以使其更清晰。
如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 &lt;code&gt;.textFieldStyle(.roundedBorder)&lt;/code&gt; 修饰符，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var text = &amp;quot;&amp;quot;
    var body: some View {
        TextField($text, placeholder: Text(&amp;quot;Enter some text&amp;quot;))
            .padding()
            .textFieldStyle(.roundedBorder)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/textfield_style_rounded_border.png&#34; alt=&#34;textfield_style_rounded_border&#34; title=&#34;textFieldStyle is roundedBorder style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.4_如何从TextField中读取文本</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</link>
      <pubDate>Sat, 27 Jul 2019 21:42:21 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UITextField&lt;/code&gt;，但是，在默认情况下 &lt;code&gt;TextField&lt;/code&gt; 看起来有点不同，并且它非常依赖于 &lt;strong&gt;状态绑定（binding to state）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-创建-textfield&#34;&gt;2. 创建 TextField&lt;/h3&gt;

&lt;p&gt;那么，要创建一个 TextField，我们应该给在 &lt;em&gt;text field&lt;/em&gt; 传入一个 &lt;code&gt;placeholder&lt;/code&gt;，再加上它应该绑定到的状态属性。&lt;/p&gt;

&lt;p&gt;例如: 现在，我们要创建一个 &lt;strong&gt;绑定到本地字符串的 TextField&lt;/strong&gt;，然后在其下面放置一个文本视图，在键入时显示 TextField 的输出:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var name = &amp;quot;Devin&amp;quot;
    
    var body: some View {
        VStack {
            TextField($name, placeholder: Text(&amp;quot;Enter your name&amp;quot;))
            Text(&amp;quot;Hello, \(name)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后，您应该能够在 TextField 中键入内容，并看到下面直接显示一条问候语。
运行效果:
&lt;img src=&#34;img/textfield_enter_your_name.gif&#34; alt=&#34;textfield_enter_your_name&#34; title=&#34;Enter your name&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提示: 在 beta1 和 beta2 中，应该改用 TextField($name)。
使用 TextField 时有两个重要的限制条件。首先，默认情况下，它没有边框，因此你可能看不到任何内容 &amp;ndash; 你需要大致点击其所在位置，以激活键盘。
其次，您可能会发现无法在布局的画布预览中键入内容。如果遇到这个问题，请按Cmd+R在模拟器中构建和运行代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.3_如何创建一个可点击的按钮</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</link>
      <pubDate>Sat, 27 Jul 2019 16:21:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-button-vs-uibutton&#34;&gt;1. Button vs UIButton&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;按钮(Button)&lt;/code&gt; 类似于 UIKit 中的 &lt;code&gt;UIButton&lt;/code&gt;，跟 UIButton 的区别在于:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在显示内容方面 SwiftUI 的按钮更为灵活&lt;/li&gt;
&lt;li&gt;SwiftUI 的按钮使用 &lt;code&gt;闭包&lt;/code&gt; 来实现其 action，而 UIButton 使用的是 &lt;code&gt;target/action&lt;/code&gt; 系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-button-初体验&#34;&gt;2. Button 初体验&lt;/h3&gt;

&lt;p&gt;那么，如何创建一个 SwiftUI 的按钮呢?，我们可以从以下代码开始:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Button(action: {
    // your action here
            
}) {
    Text(&amp;quot;Button title&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由以上代码可以看到，创建 Button 的的方法有两个参数，都是闭包，第一个闭包负责传入 action，第二个闭包负责传入按钮上的文本。&lt;/p&gt;

&lt;h3 id=&#34;3-button-简单用例&#34;&gt;3. Button 简单用例&lt;/h3&gt;

&lt;p&gt;例如: 我们可以创建一个按钮，在点击按钮时显示或隐藏一些详细信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showDetails = false
    
    var body: some View {
        VStack {
            Button(action: {
               self.showDetails.toggle()
            }) {
                Text(&amp;quot;Show detail information&amp;quot;)
            }
            
            if showDetails {
                Text(&amp;quot;You should follow me on M X Website&amp;quot;)
                    .font(.largeTitle)
                    .lineLimit(nil)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/button_show_detail_information.gif&#34; alt=&#34;button_show_detail_information&#34; title=&#34;Click button to show detail information&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-提示&#34;&gt;4. 提示&lt;/h3&gt;

&lt;p&gt;在学习框架时最常做的事情是分散调用 &lt;code&gt;print()&lt;/code&gt;，这样我们就可以看到什么时候发生了什么事情。 如果我们想通过按钮 action 来尝试，首先应右键单击预览画布中的播放按钮，然后选择 &lt;strong&gt;调试预览&lt;/strong&gt;，以便调用 &lt;code&gt;print()&lt;/code&gt; 工作。
按钮内的标题可以是任何类型的视图，因此您可以创建这样的图像按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Button(action: {
    self.showDetails.toggle()
}) {
    Image(&amp;quot;example-image&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/button_image_show_detail.gif&#34; alt=&#34;button_image_show_detail&#34; title=&#34;Set an image for button&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.2_如何创建拨动开关</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/</link>
      <pubDate>Sat, 27 Jul 2019 15:55:42 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8B%A8%E5%8A%A8%E5%BC%80%E5%85%B3/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;toggle&lt;/code&gt; 允许用户在 &lt;strong&gt;true&lt;/strong&gt; 和 &lt;strong&gt;false&lt;/strong&gt; 之间移动，就像 UIKit 中的 &lt;code&gt;UISwitch&lt;/code&gt; 一样。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;我们可以创建一个 &lt;em&gt;toggle&lt;/em&gt; ，然后根据 &lt;em&gt;toggle&lt;/em&gt; 是否启动来决定显示或者不显示消息。但是我们不希望手动跟踪 &lt;em&gt;toggle&lt;/em&gt; 的状态 &amp;ndash; 我们希望 SwiftUI 为我们做这件事。
与以往不同，在这里，我们应该定义一个 &lt;code&gt;@State Boolean&lt;/code&gt; 属性，用于存储 toggle 的当前值。然后我们可以使用它来显示或隐藏其它视图。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showGreeting = true
    
    var body: some View {
        VStack {
            Toggle(isOn: $showGreeting) {
                Text(&amp;quot;Show welcome message!&amp;quot;)
            }.padding()
            
            if showGreeting {
                Text(&amp;quot;Hello world&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/toggle_show_welcomemessage.gif&#34; alt=&#34;toggle_show_welcomemessage&#34; title=&#34;Show welcome message&#34; /&gt;
这段代码，只有当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;true&lt;/em&gt; 时才会返回文本视图，这意味着当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;false&lt;/em&gt; 时，&lt;code&gt;VStack&lt;/code&gt; 的大小会减小 - 它的堆栈中没有第二个视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.1_使用 state</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</link>
      <pubDate>Fri, 26 Jul 2019 22:48:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-概念&#34;&gt;1. 概念&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;所有应用程序都会改变状态。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户可能点击了一个按钮来显示更多信息&lt;/li&gt;
&lt;li&gt;用户可能已经在文本框中输入了一些文本&lt;/li&gt;
&lt;li&gt;用户从日期选择器中选择了一个日期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有涉及应用程序 &lt;strong&gt;从一种状态转变到另一种状态&lt;/strong&gt; 的事情，都叫做应用程序改变状态。&lt;/p&gt;

&lt;h3 id=&#34;2-问题所在&#34;&gt;2. 问题所在&lt;/h3&gt;

&lt;p&gt;状态的问题在于它是混乱的: &lt;strong&gt;当它发生变化时，我们需要发现变化并更新我们的布局来匹配变化&lt;/strong&gt;。 这个一开始听起来可能很简单，但是随着我们的状态的不断增长，它就会变得越来越难 - 因为这个时候，我们很容易忘记更新一件事，或者更新顺序出错，以致于用户界面状态达不到预期效果。&lt;/p&gt;

&lt;h3 id=&#34;3-swiftui-如何破解&#34;&gt;3. SwiftUI 如何破解？&lt;/h3&gt;

&lt;p&gt;SwiftUI 通过 &lt;strong&gt;从控件中移除状态&lt;/strong&gt; 来解决这个问题。&lt;/p&gt;

&lt;p&gt;当我们向视图添加属性时，这些属性实际上是惰性的 - 当然，它们有值，但是更改这些值并不会做任何事情。 但是如果我们在这些属性之前添加了特殊的&lt;code&gt;@State&lt;/code&gt; 来包装属性，SwiftUI将自动监视属性变化并更新使用该属性的视图的任何部分。&lt;/p&gt;

&lt;p&gt;示例代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@state var name: String = &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;code&gt;@state&lt;/code&gt; 这种语法称为 属性包装器，这里不作详细介绍，可以自行查找文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当涉及到某种状态时 - 例如，当切换开关（toggle switch）改变时告诉状态属性改变。
&lt;strong&gt;这里需要注意的是&lt;/strong&gt;: 我们不能直接引用这个属性属性。这是因为 Swift 会认为我们现在所指的是&lt;code&gt;&amp;quot;属性当前的值&amp;quot;&lt;/code&gt;，而不是说 &lt;code&gt;&amp;quot;请注意这件事情(属性状态变化)&amp;quot;&lt;/code&gt;。幸运的是，SwiftUI 的解决方案是在属性名称前放置一个&lt;code&gt;美元符号($)&lt;/code&gt;，这样的话，我们就可以引用属性本身而不是它当前的值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当然，这里一开始理解起有点令人困惑，但在当我们学习一两个示例之后就会理解，非常简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，请记住，SwiftUI 是声明性的，这意味着我们预先告诉它所有可能状态的所有布局，并让它知道当属性发生变化时如何在它们之间移动。我们称之为 &lt;strong&gt;&lt;em&gt;绑定（binding）&lt;/em&gt;&lt;/strong&gt; - 要求 SwiftUI 同步UI控件和底层属性之间的更改。
如果你已经习惯了一种更为迫切的编程风格，那么使用 state 一开始会让你头疼一些，但不要担心 - 一旦你完成了它，你就很明确了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.8_如何将视图放到安全区域之外</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</link>
      <pubDate>Fri, 26 Jul 2019 22:12:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;默认情况下，我们的 SwiftUI 视图将主要位于安全区域内 - 它将会到达屏幕底部，但不会靠近设备顶部的任何凹口。
如果我们想改变它 - 想让视图真正全屏，即使这意味着被一个缺口或其他硬件切口部分遮挡 - 那么我们应该使用 &lt;code&gt;edgesIgnoringSafeArea()&lt;/code&gt; 修饰符。
例如，这会创建一个红色文本视图，要求填充所有可用空间，然后将其设置为忽略任何安全区域，以使其真正边缘到边缘。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello World&amp;quot;)
        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)    
        .background(Color.red)
        .edgesIgnoringSafeArea(.all)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/edgesIgnoringSafeArea.png&#34; alt=&#34;edgesIgnoringSafeArea&#34; title=&#34;edgesIgnoringSafeArea all&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.7_如何使用size_classes创建不同的布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 26 Jul 2019 16:52:17 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 通过在环境中暴露 &lt;em&gt;size classes&lt;/em&gt; 来原生支持它。如果要使用它，我们首先需要创建一个 &lt;code&gt;@Environment&lt;/code&gt; 对象来存储其值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Environment(\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在我们需要时检查该属性的值，查找 &lt;code&gt;.compact&lt;/code&gt; 或 &lt;code&gt;.regular&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if horizontalSizeClass == .compact {
    return Text(&amp;quot;Compact&amp;quot;)
} else {
    return Text(&amp;quot;Regular&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将所有代码组合在一起，可以创建这样的视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @Environment(\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?
    
    var body: some View {
        if horizontalSizeClass == .compact {
            return Text(&amp;quot;Compact&amp;quot;)
        } else {
            return Text(&amp;quot;Regular&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:&lt;/p&gt;

&lt;p&gt;(1) 正向竖屏
&lt;img src=&#34;img/size_classes_compact.png&#34; alt=&#34;size_classes_compact&#34; title=&#34;Text - Compact&#34; /&gt;
(2) 横屏 - 刘海在右侧
&lt;img src=&#34;img/size_classes_regular01.png&#34; alt=&#34;size_classes_regular01&#34; title=&#34;Text - Regular01&#34; /&gt;
(3) 横屏 - 刘海在左侧
&lt;img src=&#34;img/size_classes_regular02.png&#34; alt=&#34;size_classes_regular02&#34; title=&#34;Text - Regular02&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.6_如何使用ForEach在循环中创建视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Fri, 26 Jul 2019 00:21:40 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;p&gt;我们通常会发现，我们需要循环一个序列来创建视图，而在 SwiftUI 中，这是通过 &lt;code&gt;ForEach&lt;/code&gt; 来完成的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;:
我们很容易一看到 &lt;em&gt;ForEach&lt;/em&gt; 就认为它与 Swift 序列中的 &lt;em&gt;forEach()&lt;/em&gt; 方法相同，但事实并非如你所见。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SwiftUI 中的 &lt;code&gt;ForEach&lt;/code&gt; 本身是一个视图结构，这就意味着我们可以根据需要直接从视图 &lt;em&gt;Body&lt;/em&gt; 返回它。&lt;/li&gt;
&lt;li&gt;我们为它提供一系列项目，可能还需要告诉 SwiftUI 它如何唯一地标识每个项目，以便 SwiftUI 知道如何在值更改时更新它们。&lt;/li&gt;
&lt;li&gt;我们还传递一个要运行的闭包，来为循环中的每个项创建一个视图。&lt;/li&gt;
&lt;li&gt;对于范围内的简单循环，您可以将范围直接传递给ForEach。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-循环-1-10-创建文本视图&#34;&gt;1. 循环 1&amp;hellip;10 创建文本视图&lt;/h3&gt;

&lt;p&gt;例如，这从10减少到1然后在最后添加一条消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack(alignment: .leading) {
        ForEach((1...10).reversed()) {
            Text(&amp;quot;\($0)…&amp;quot;)
        }
            
        Text(&amp;quot;Ready or not, here I come!&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foreach_create_views.png&#34; alt=&#34;foreach_create_views&#34; title=&#34;Create views using ForEach&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-foreach-colors&#34;&gt;2. ForEach colors&lt;/h3&gt;

&lt;p&gt;对于简单类型数组（如字符串、整数、颜色等）的循环，可以在数组上使用 &lt;code&gt;.identified(by: \.self)&lt;/code&gt;，让 SwiftUI  使用值本身作为标识符。因此，如果您的数组是 &lt;code&gt;[&amp;quot;cat&amp;quot;, &amp;quot;Dog&amp;quot;, &amp;quot;monkey&amp;quot;]&lt;/code&gt;，那么 SwiftUI 会将这些字符串本身作为您的视图的标识符。
因此，此代码创建一个包含三种颜色的数组，在它们上面循环，并使用每个颜色名称和颜色值创建文本视图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let colors: [Color] = [.red, .green, .blue]
    
var body: some View {
        
    VStack {
        ForEach(colors.identified(by: \.self)) { color in
            Text(color.description.capitalized)
                .padding()
                .background(color)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foreach_colors_array.png&#34; alt=&#34;foreach_colors_array&#34; title=&#34;foreach colors&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-foreach-custom-type&#34;&gt;3. ForEach custom type&lt;/h3&gt;

&lt;p&gt;如果您的数组中有自定义类型，则应使用  &lt;code&gt;.identified(by:)&lt;/code&gt; 与您的类型中的任何属性唯一标识它。
例如，这是一个存储测试结果的结构，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Result {
    var id = UUID()
    var score: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它有一个带有 &lt;code&gt;UUID&lt;/code&gt; 的 &lt;code&gt;id&lt;/code&gt; 属性，这意味着它保证是唯一的 - 完美的用于我们的目的。 如果我们想循环一个结果数组，创建一个显示 &lt;code&gt;VStack&lt;/code&gt; 中每个结果的文本视图，那么我们将使用它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let results = [Result(score: 8), Result(score: 5), Result(score: 10)]
    
var body: some View {
    VStack {
        ForEach(results.identified(by: \.id)) { result in
            Text(&amp;quot;Result: \(result.score)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foreach_custom_type.png&#34; alt=&#34;foreach_custom_type&#34; title=&#34;ForEach custom type&#34; /&gt;
这告诉 SwiftUI 它可以通过查看它们的 &lt;code&gt;id&lt;/code&gt; 属性来区分 &lt;code&gt;ForEach&lt;/code&gt; 中的视图。
&lt;strong&gt;提示&lt;/strong&gt;：如果您使 &lt;code&gt;Result&lt;/code&gt; 符合 &lt;code&gt;Identifiable&lt;/code&gt; protocol，您只需编写 &lt;code&gt;ForEach（Result）&lt;/code&gt;。 符合此协议意味着添加唯一标识每个对象的 &lt;code&gt;id&lt;/code&gt; 属性，在我们的示例中我们已经拥有，因此您只需编写 &lt;code&gt;struct Result：Identifiable {&lt;/code&gt;！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.5_如何返回不同的视图类型</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 25 Jul 2019 13:47:21 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/</guid>
      <description>

&lt;p&gt;当我们从视图的 body 返回 &lt;code&gt;some View&lt;/code&gt; 的时候，Swift 理解这意味着我们有一个特定的返回类型。&lt;/p&gt;

&lt;p&gt;例如: 如果我们想掷硬币并显示 &amp;ldquo;你赢了!&amp;ldquo;，但是我们不能这样写: 要么返回一个 Image，要么返回一个 Text，写着 &amp;ldquo;下次祝你好运&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    if Bool.random() {
        Image(&amp;quot;example-image&amp;quot;)
    } else {
        Text(&amp;quot;Better luck next time&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码会报错:
&lt;img src=&#34;img/error_return_view_type.png&#34; alt=&#34;error_return_view_type&#34; title=&#34;Compilation error&#34; /&gt;
因为它可能返回 &lt;em&gt;Image&lt;/em&gt; 或者 &lt;em&gt;Text&lt;/em&gt; ，这是不允许的 &amp;ndash;  我们&lt;code&gt;必须精确返回一种类型&lt;/code&gt;。
有两种方法可以解决这个问题。&lt;/p&gt;

&lt;h3 id=&#34;1-group&#34;&gt;1. Group&lt;/h3&gt;

&lt;p&gt;第一种方法是将输出包装在一个 &lt;code&gt;group&lt;/code&gt; 中，这样无论我们发送图像视图还是文本视图，它们都将返回到一个 &lt;code&gt;group&lt;/code&gt; 中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Group {
        if Bool.random() {
            Image(&amp;quot;example-image&amp;quot;)
        } else {
            Text(&amp;quot;Better luck next time&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/return_image.png&#34; alt=&#34;return_image&#34; title=&#34;Return an image or a text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-anyview&#34;&gt;2. AnyView&lt;/h3&gt;

&lt;p&gt;第二种方法，SwiftUI 提供了一个名为 &lt;code&gt;AnyView&lt;/code&gt; 的类型，我们可以返回这种类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: AnyView {
    if Bool.random() {
        return AnyView(Image(&amp;quot;example-image&amp;quot;))
    } else {
        return AnyView(Text(&amp;quot;Better luck next time&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你还没有听说过这个概念，它会强制让 Swift 忘记 &lt;code&gt;AnyView&lt;/code&gt; 中包含的特定类型，让它们看起来像是一样的东西。但这有性能成本，所以不要经常使用它。
尽管 &lt;code&gt;Group&lt;/code&gt; 和 &lt;code&gt;AnyView&lt;/code&gt; 都为我们的布局实现了相同的结果，但通常最好使用 &lt;code&gt;Group&lt;/code&gt;，因为它对 SwiftUI 更有效。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.4_如何使用ZStack将视图叠加在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Thu, 25 Jul 2019 13:26:52 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>

&lt;p&gt;SwiftUI 有一个专用的 &lt;em&gt;stack&lt;/em&gt; 类型，用于创建重叠内容，例如，如果我们想在图片上放置一些文本，它就很有用。它被称为 &lt;code&gt;ZStack&lt;/code&gt;，其工作原理与其他两种 &lt;em&gt;stack&lt;/em&gt; 类型相同。&lt;/p&gt;

&lt;h3 id=&#34;1-在文本下面放置图片&#34;&gt;1. 在文本下面放置图片&lt;/h3&gt;

&lt;p&gt;例如: 我们可以在如下文本下面放置一个大图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    ZStack() {
        Image(&amp;quot;example-image&amp;quot;)
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(Color.black)
            .foregroundColor(.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/zstack_image_text.png&#34; alt=&#34;zstack_image_text&#34; title=&#34;Set zstack with a image and a text, image is below text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-对齐&#34;&gt;2. 对齐&lt;/h3&gt;

&lt;p&gt;与其它 &lt;em&gt;stack&lt;/em&gt; 类型一样，&lt;code&gt;ZStack&lt;/code&gt; 也可以设置对齐方式，这样它就不会总是将事物置于自身的中心位置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    ZStack(alignment: .leading) {
        Image(&amp;quot;example-image&amp;quot;)
            .resizable()
            .aspectRatio(contentMode: .fit)
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(Color.black)
            .foregroundColor(.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/zstack_alignment_leading.png&#34; alt=&#34;zstack_alignment_leading&#34; title=&#34;Set zstack&#39;s alignment as .leading&#34; /&gt;
但是，它没有 &lt;em&gt;spacing&lt;/em&gt; 属性，因为它实际上没有意义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.3_如何使用padding控制单个视图周围的间距</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/</link>
      <pubDate>Thu, 25 Jul 2019 11:39:45 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/</guid>
      <description>

&lt;p&gt;SwiftUI 允许我们使用 &lt;code&gt;padding()&lt;/code&gt; 修饰符在视图周围设置单独的填充。&lt;/p&gt;

&lt;h3 id=&#34;1-系统默认-padding&#34;&gt;1. 系统默认 padding&lt;/h3&gt;

&lt;p&gt;如果在不传参数的情况下使用 &lt;em&gt;padding()&lt;/em&gt; ，您将在所有边上获得系统默认填充，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .background(Color.red)
            .padding()
        Text(&amp;quot;Hello M X&amp;quot;)
            .background(Color.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/padding_system_default.png&#34; alt=&#34;padding_system_default&#34; title=&#34;Set padding with system default&#34; /&gt;
注意: 这里默认设置了视图四周的填充。&lt;/p&gt;

&lt;h3 id=&#34;2-只设置一侧系统默认-padding&#34;&gt;2. 只设置一侧系统默认 padding&lt;/h3&gt;

&lt;p&gt;我们也可以自定义要 apply 的 &lt;em&gt;padding&lt;/em&gt; 和位置。因此，我们只希望将系统填充应用于一侧:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .background(Color.red)
            .padding(.bottom)
        Text(&amp;quot;Hello M X&amp;quot;)
            .background(Color.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/padding_system_bottom.png&#34; alt=&#34;padding_system_bottom&#34; title=&#34;Set bottom padding with system default&#34; /&gt;
注意: 这里只设置了底部填充，与上面的例子不同。&lt;/p&gt;

&lt;h3 id=&#34;3-用具体数值来设置-padding&#34;&gt;3. 用具体数值来设置 padding&lt;/h3&gt;

&lt;p&gt;我们可能希望控制对所有边应用了多少填充:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .background(Color.red)
            .padding(100)
        Text(&amp;quot;Hello M X&amp;quot;)
            .background(Color.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/padding_100.png&#34; alt=&#34;padding_100&#34; title=&#34;Set padding as 100&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-在视图一侧添加特定数量的填充&#34;&gt;4. 在视图一侧添加特定数量的填充&lt;/h3&gt;

&lt;p&gt;我们也可以将这两者结合起来，在视图的一侧添加特定数量的填充：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
  VStack {
      Text(&amp;quot;Hello SwiftUI&amp;quot;)
          .background(Color.red)
          .padding(.bottom, 100)
      Text(&amp;quot;Hello M X&amp;quot;)
          .background(Color.blue)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/padding_bottom_100.png&#34; alt=&#34;padding_bottom_100&#34; title=&#34;Set bottom padding as 100&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.2_如何通过alignment和spacing自定义stack布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 25 Jul 2019 10:54:52 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/</guid>
      <description>

&lt;h3 id=&#34;1-spacing&#34;&gt;1. &lt;code&gt;spacing&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以通过在 SwiftUI stacks 的构造方法中填一个值来设置间距，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack(spacing: 50) {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .background(Color.red)
        Text(&amp;quot;Hello M X&amp;quot;)
            .background(Color.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/stack_spacing.png&#34; alt=&#34;stack_spacing&#34; title=&#34;Set a spacing for stack&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-divider&#34;&gt;2. &lt;code&gt;Divider&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以在项目之间创建分隔符，以便 SwiftUI 在 &lt;em&gt;stack&lt;/em&gt; 中的每个项目之间进行小的视觉区分，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
           .background(Color.red)
        Divider()
        Text(&amp;quot;Hello M X&amp;quot;)
           .background(Color.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/stack_divider.png&#34; alt=&#34;stack_divider&#34; title=&#34;Set a divider for stack&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-alignment&#34;&gt;3. &lt;code&gt;alignment&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;默认情况下，&lt;em&gt;stacks&lt;/em&gt; 中的项目居中对齐。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;em&gt;HStack&lt;/em&gt; 中: 项目在中间垂直对齐，因此如果有两个不同高度的文本视图，它们都将与垂直中心对齐。&lt;/li&gt;
&lt;li&gt;在 &lt;em&gt;VStack&lt;/em&gt; 中: 项目在中间水平对齐，因此如果有两个长度不同的文本视图，它们都将与水平中心对齐。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要调整这种情况，请在创建 &lt;em&gt;stack&lt;/em&gt; 时按以下方式传递一个 &lt;em&gt;alignment&lt;/em&gt; 参数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack(alignment: .leading) {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
           .background(Color.red)
        Text(&amp;quot;Hello M X&amp;quot;)
            .background(Color.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/stack_alignment_leading.png&#34; alt=&#34;stack_alignment_leading&#34; title=&#34;Set alignment to .leading&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这将使 &lt;code&gt;Hello SwiftUI&lt;/code&gt; 和 &lt;code&gt;Hello M X&lt;/code&gt; 左对齐，但它们最终将位于屏幕的中间，因为 stack 只占用所需的空间。&lt;/p&gt;

&lt;h3 id=&#34;4-同时设置-alignment-和-spacing&#34;&gt;4.同时设置 &lt;code&gt;alignment&lt;/code&gt; 和 &lt;code&gt;spacing&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以同时使用 &lt;em&gt;alignment&lt;/em&gt; 和 &lt;em&gt;spacing&lt;/em&gt; ，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack(alignment: .leading, spacing: 20) {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .background(Color.red)
        Text(&amp;quot;Hello M X&amp;quot;)
            .background(Color.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/stack_alignment_spacing.png&#34; alt=&#34;stack_alignment_spacing&#34; title=&#34;Using alignment and spacing in stack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这将使两个文本视图水平对齐到 &lt;code&gt;leading&lt;/code&gt;（对于从左到右的语言是左对齐），并在它们之间放置20个点的垂直间距。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.1_如何使用VStack和HStack创建stacks</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/</link>
      <pubDate>Thu, 25 Jul 2019 10:10:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/</guid>
      <description>

&lt;p&gt;SwiftUI 的内容视图 &lt;em&gt;content views&lt;/em&gt; 必须返回一个视图，即我们希望它们显示的视图。当我们想要一次在屏幕上显示多个视图时，我们需要告诉 SwiftUI 如何排列它们，这就是 &lt;code&gt;堆栈（stacks）&lt;/code&gt;的来源。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;堆栈（Stacks）&lt;/code&gt; 相当于 UIKit 中的 &lt;em&gt;UIStackView&lt;/em&gt; 。有三种形式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;水平（HStack）&lt;/li&gt;
&lt;li&gt;垂直（VStack）&lt;/li&gt;
&lt;li&gt;基于深度（ZStack）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们想放置子视图以便它们重叠时可以使用后者。&lt;/p&gt;

&lt;h3 id=&#34;1-vstack&#34;&gt;1. VStack&lt;/h3&gt;

&lt;p&gt;让我们从一些简单的事情开始，先创建一个文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
        .background(Color.red)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/single_text.png&#34; alt=&#34;single_text&#34; title=&#34;A single text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有了一个文本视图，如果我们想在下面再写一个，我们不能只写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
    Text(&amp;quot;Hello M X&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话，编译器会直接报错。
记住，我们只能返回一个视图，否则代码就不会工作。&lt;/p&gt;

&lt;p&gt;那么怎么办呢？我们需要将其放置在 &lt;code&gt;VStack&lt;/code&gt; 中，以便将文本视图放置在彼此上方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    VStack {
       Text(&amp;quot;Hello SwiftUI&amp;quot;)
           .background(Color.red)
       Text(&amp;quot;Hello M X&amp;quot;)   
           .background(Color.blue)         
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/two_text_in_vstack.png&#34; alt=&#34;two_text_in_vstack&#34; title=&#34;Two texts in VStack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;您会注意到 &lt;code&gt;VStack&lt;/code&gt; 放置在屏幕的中心，标签也居中，它们之间有一些自动空间。&lt;/p&gt;

&lt;h3 id=&#34;2-hstack&#34;&gt;2. HStack&lt;/h3&gt;

&lt;p&gt;如果我们希望文本视图并排水平放置，请使用如下方式将 &lt;code&gt;VStack&lt;/code&gt; 替换为 &lt;code&gt;HStack&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    HStack {
       Text(&amp;quot;Hello SwiftUI&amp;quot;)
           .background(Color.red)
       Text(&amp;quot;Hello M X&amp;quot;)   
           .background(Color.blue)         
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/two_text_in_hstack.png&#34; alt=&#34;two_text_in_hstack&#34; title=&#34;Two texts in HStack&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.9_如何使用图像和其它视图作为背景</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/</link>
      <pubDate>Wed, 24 Jul 2019 15:46:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/</guid>
      <description>

&lt;p&gt;我们可以使用相同的 &lt;code&gt;background()&lt;/code&gt; 修饰符来设置背景图像，而不是设置背景颜色。&lt;/p&gt;

&lt;h3 id=&#34;1-给文本视图设置图像背景&#34;&gt;1. 给文本视图设置图像背景&lt;/h3&gt;

&lt;p&gt;例如: 现在，我们要创建一个大字体的文本视图，然后在其后面放置一个 &lt;code&gt;100x100 的图像&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(
                Image(&amp;quot;example-image&amp;quot;)
                    .resizable()
                    .frame(width: 100, height: 100)
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/background_image.png&#34; alt=&#34;background_image&#34; title=&#34;Set background with image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-给文本视图设置一个红色圆圈作为背景&#34;&gt;2. 给文本视图设置一个红色圆圈作为背景&lt;/h3&gt;

&lt;p&gt;在 SwiftUI 中，背景 View 并不一定是一个图像，实际上我们可以使用任何类型的视图作为背景。
例如: 现在将创建相同的文本视图，然后在其后面放置一个 &lt;code&gt;200x200 的红色圆圈&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    // 红色圆圈作背景
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
        .font(.largeTitle)
        .background(
            Circle()
                .fill(Color.red)
                .frame(width: 200, height: 200)
        )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，背景视图会自动占用尽可能多的空间以完全可见，但如果需要，可以使用 &lt;code&gt;clipped(&lt;/code&gt;) 修饰符将其剪裁为父视图的大小：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    // 红色圆圈作背景
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
        .font(.largeTitle)
        .background(
            Circle()
                .fill(Color.red)
                .frame(width: 200, height: 200)
                .clipped()
        )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/background_red_circle.png&#34; alt=&#34;background_red_circle&#34; title=&#34;Set background with a red circle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;明确地说，您可以使用任何视图作为背景，例如，如果需要，可以使用另一个文本视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.8_如何显示几何形状</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/</link>
      <pubDate>Wed, 24 Jul 2019 15:46:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/</guid>
      <description>

&lt;p&gt;如果我们想在应用程序中使用简单地几何形状，我们可以直接创建它们，然后根据需要对它们进行着色和定位。&lt;/p&gt;

&lt;h3 id=&#34;1-矩形&#34;&gt;1. 矩形&lt;/h3&gt;

&lt;p&gt;例如，如果我们想要一个 &lt;code&gt;200x200&lt;/code&gt; 红色矩形，可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Rectangle()
        .fill(Color.red)
        .frame(width: 200, height: 200)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/square_red_wh200.png&#34; alt=&#34;square_red_wh200&#34; title=&#34;Square: 200 x 200&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-圆&#34;&gt;2. 圆&lt;/h3&gt;

&lt;p&gt;同样，如果你想要一个 &lt;code&gt;50x50&lt;/code&gt; 的蓝色圆圈，您可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Circle()
        .fill(Color.blue)
        .frame(width: 50, height: 50)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/circle_blue_r50.png&#34; alt=&#34;circle_blue_r50&#34; title=&#34;Circle: 50 x 50&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.7_如何渲染渐变</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/</link>
      <pubDate>Wed, 24 Jul 2019 15:45:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/</guid>
      <description>

&lt;p&gt;SwiftUI 为我们提供了各种渐变选项（gradient options），所有这些选项都可以以各种方式来使用。例如:&lt;/p&gt;

&lt;h3 id=&#34;1-垂直线性渐变&#34;&gt;1. 垂直线性渐变&lt;/h3&gt;

&lt;p&gt;我们使用从白色到黑色的线性渐变来渲染文本视图，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello World&amp;quot;)
        .padding()
        .foregroundColor(.white)
        .background(LinearGradient(gradient: Gradient(colors: [.white, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/gradient_vertical_white_black.png&#34; alt=&#34;gradient_vertical_white_black&#34; title=&#34;vertical gradient: white -&amp;gt; black&#34; /&gt;&lt;/p&gt;

&lt;p&gt;颜色被指定为一个数组，我们可以设置任意多我们想要的颜色 - 默认情况下，SwiftUI 将会平均分配这些颜色。所以，我们也可以这样从 白色 -&amp;gt; 红色 -&amp;gt; 黑色 来设置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello World&amp;quot;)
        .padding()
        .foregroundColor(.white)
        .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .top, endPoint: .bottom), cornerRadius: 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/gradient_vertical_white_red_black.png&#34; alt=&#34;gradient_vertical_white_red_black&#34; title=&#34;vertical gradient: white -&amp;gt; red -&amp;gt; black&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-水平线性渐变&#34;&gt;2. 水平线性渐变&lt;/h3&gt;

&lt;p&gt;要实现一个水平渐变（a horizontal gradient）而不是一个垂直渐变（a vertical one），使用 &lt;code&gt;.leading&lt;/code&gt; 和 &lt;code&gt;.trailing&lt;/code&gt; 来作为 &lt;em&gt;startPoint&lt;/em&gt; 和 &lt;em&gt;endPoint&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello World&amp;quot;)
       .padding()
       .foregroundColor(.white)
       .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .leading, endPoint: .trailing), cornerRadius: 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/gradient_horizontal_white_red_black.png&#34; alt=&#34;gradient_horizontal_white_red_black&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-对角线线性渐变&#34;&gt;3. 对角线线性渐变&lt;/h3&gt;

&lt;p&gt;要实现对角线渐变，可以使用 &lt;code&gt;.topLeading&lt;/code&gt; 和 &lt;code&gt;.bottomTrailing&lt;/code&gt; 作为 &lt;em&gt;startPoint&lt;/em&gt; 和 &lt;em&gt;endPoint&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello World&amp;quot;)
        .padding()
        .foregroundColor(.white)
        .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .topLeading, endPoint: .bottomTrailing), cornerRadius: 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/gradient_diagonal.png&#34; alt=&#34;gradient_diagonal&#34; title=&#34;diagonal gradient: white -&amp;gt; red -&amp;gt; black &#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.6_如何调整图像视图的填充模式</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:45:07 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;img/ba_xian_tai.png&#34; alt=&#34;ba_xian_tai&#34; /&gt;
SwiftUI 的 &lt;code&gt;Image&lt;/code&gt; 能够以不同的方式进行缩放，就像 &lt;code&gt;UIImageView&lt;/code&gt; 的 &lt;em&gt;content mode&lt;/em&gt; 一样。&lt;/p&gt;

&lt;h3 id=&#34;1-默认&#34;&gt;1.默认&lt;/h3&gt;

&lt;p&gt;默认情况下，图像视图会自动调整其内容的大小，这可能会使它们超出屏幕。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/the_default_content_mode.png&#34; alt=&#34;the_default_content_mode&#34; title=&#34;default content mode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果添加了 &lt;code&gt;resizable()&lt;/code&gt; 修饰符，则图像将自动调整大小，以填充所有可用空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/resizable_image.png&#34; alt=&#34;resizable_image&#34; title=&#34;resizable image&#34; /&gt;
然而，这也可能导致图像的原始纵横比失真，因为它将在所有维度上被拉伸任意数量，以使其填充空间。&lt;/p&gt;

&lt;h3 id=&#34;2-fill-和-fit&#34;&gt;2. .fill 和 .fit&lt;/h3&gt;

&lt;p&gt;如果要保持其纵横比，应使用 &lt;code&gt;.fill&lt;/code&gt; 或 &lt;code&gt;.fit&lt;/code&gt;添加一个&lt;code&gt;aspectRatio()&lt;/code&gt;修饰符，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
    .aspectRatio(contentMode: .fill)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/fill_content_mode.png&#34; alt=&#34;fill_content_mode&#34; title=&#34;content mode = .fill&#34; /&gt;
&lt;img src=&#34;img/fit_content_mode.png&#34; alt=&#34;fit_content_mode&#34; title=&#34;content mode = .fit&#34; /&gt;
注意: 在当前的测试版中，有一个bug，&lt;code&gt;.fit&lt;/code&gt; 内容模式仍然会导致图像被拉伸。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.5_如何使用图像视图绘制图像</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:44:15 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</guid>
      <description>

&lt;p&gt;使用图像视图 &lt;code&gt;Image&lt;/code&gt; 可以在 SwiftUI 布局中渲染图像（images）。我们可以从 &lt;code&gt;Bundle&lt;/code&gt;、&lt;code&gt;System icons&lt;/code&gt;、&lt;code&gt;UIImage&lt;/code&gt; 等中加载图像，但这三个将是最常见的。&lt;/p&gt;

&lt;h3 id=&#34;1-从-bundle-加载&#34;&gt;1. 从 Bundle 加载&lt;/h3&gt;

&lt;p&gt;要从 Bundle 中加载图像并将其显示在图像视图中，只需使用以下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Image(&amp;quot;example-image&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/load_image_from_bundle.png&#34; alt=&#34;load_image_from_bundle&#34; title=&#34;load image from buldle&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-从-system-icons-加载&#34;&gt;2. 从 System icons 加载&lt;/h3&gt;

&lt;p&gt;要从苹果旧金山符号集(Apple’s San Francisco Symbol set)中加载图标，请使用 &lt;code&gt;Image(systemName: )&lt;/code&gt; 初始化器，传入图标字符串进行加载，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/load_image_from_systemicon.png&#34; alt=&#34;load_image_from_systemicon&#34; title=&#34;load image from system icons&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-从-uiimage-加载&#34;&gt;3. 从 UIImage 加载&lt;/h3&gt;

&lt;p&gt;最后，可以从现有的 UIImage 创建一个图像视图。因为这需要更多的代码，所以需要显式地使用 return 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let image = UIImage(named: &amp;quot;example-image&amp;quot;) else {
    fatalError(&amp;quot;Unable to load image&amp;quot;)
}

return Image(uiImage: image)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/load_image_from_uiimage.png&#34; alt=&#34;load_image_from_uiimage&#34; title=&#34;load image from uiimage&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-foregroundcolor&#34;&gt;4. foregroundColor&lt;/h3&gt;

&lt;p&gt;如果你使用的是 系统图标集，则返回的图像是 &lt;code&gt;可缩放&lt;/code&gt; 和 &lt;code&gt;可着色&lt;/code&gt; 的，这意味着你可以使用 &lt;code&gt;foregroundColor()&lt;/code&gt; 修改器对图像着色。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
    .foregroundColor(.red)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foreground_color_image.png&#34; alt=&#34;foreground_color_image&#34; title=&#34;set foreground color for system icon&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-动态文本样式&#34;&gt;5. 动态文本样式&lt;/h3&gt;

&lt;p&gt;这意味着你可以通过匹配任何 &lt;code&gt;Dynamic Type&lt;/code&gt; 文本样式，来要求 SwiftUI 放大图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
    .font(.largeTitle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/font_largetitle_image.png&#34; alt=&#34;font_largetitle_image&#34; title=&#34;set font as largeTitle for system icons&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.4_如何格式化文本视图中的文本</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/</link>
      <pubDate>Wed, 24 Jul 2019 15:43:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/</guid>
      <description>&lt;p&gt;SwiftUI 的文本视图有一个可选的 &lt;code&gt;formatter&lt;/code&gt; 参数，可以让我们用来自定义数据在标签（label）内的显示方式。这一点很重要，因为在我们的程序中发生某些事情时，通常会为我们更新值，因此通过附加 &lt;code&gt;formatter&lt;/code&gt;， SwiftUI 可以确保我们的数据以我们期望的方式来正确显示。&lt;/p&gt;

&lt;p&gt;例如，这定义了一个日期格式（date formatter）化程序，并使用它来确保 任务日期 以人类可读的形式显示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftUI

struct ContentView : View {
    
    static let taskDateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        return formatter
    }()
    
    var dueDate = Date()
    
    var body: some View {
        Text(&amp;quot;Task due date: \(dueDate, formatter: Self.taskDateFormatter)&amp;quot;)
    }
}

#if DEBUG
struct ContentView_Previews : PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/date_formatter_text.png&#34; alt=&#34;date_formatter&#34; title=&#34;date formatter&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.3_如何使用字体颜色行距等设置文本视图的样式</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:42:28 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/</guid>
      <description>

&lt;!-- more --&gt;

&lt;p&gt;文本视图不仅在外观方面给了我们一个可预见的广泛控制，而且还设计成与苹果的核心技术（如 &lt;code&gt;Dynamic Type&lt;/code&gt;）无缝配合。&lt;/p&gt;

&lt;h3 id=&#34;1-字体&#34;&gt;1. 字体&lt;/h3&gt;

&lt;p&gt;默认情况下，文本视图有一个 &lt;code&gt;Body&lt;/code&gt; 动态类型样式，但是我们可以通过以下方式调用 &lt;code&gt;.font()&lt;/code&gt;，从其它 &lt;em&gt;sizes&lt;/em&gt; 和 &lt;em&gt;weights&lt;/em&gt; 进行选择:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones&amp;quot;)
    .lineLimit(nil)
    .font(.largeTitle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/large_title_font.png&#34; alt=&#34;large_title_font_text&#34; title=&#34;largeTitle font&#34; /&gt;
我们现在在文本视图下面使用了两个修饰符，这没关系 - 你可以将它们堆叠起来，并且它们都会生效。&lt;/p&gt;

&lt;h3 id=&#34;2-文本对齐&#34;&gt;2. 文本对齐&lt;/h3&gt;

&lt;p&gt;特别是，现在我们有多行文本，我们需要调整文本的对齐方式，使其居中，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones&amp;quot;)
    .lineLimit(nil)
    .font(.largeTitle)
    .multilineTextAlignment(.center)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/center_alignment.png&#34; alt=&#34;center_alignment_text&#34; title=&#34;center alignment&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-字体颜色&#34;&gt;3. 字体颜色&lt;/h3&gt;

&lt;p&gt;我们可以通过 &lt;code&gt;.foregroundColor()&lt;/code&gt; 修饰符来设置文本颜色，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;The best laid plans&amp;quot;)
    .foregroundColor(Color.red)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/foregroundcolor_text.png&#34; alt=&#34;foregroundcolor_text&#34; title=&#34;foreground color&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-背景&#34;&gt;4. 背景&lt;/h3&gt;

&lt;p&gt;我们可以使用 &lt;code&gt;.background()&lt;/code&gt; 来设置背景颜色，但是它不仅仅可以用来设置背景颜色，也可以设置背景视图。无论如何，为了给我们的文本视图设置一个黄色背景，代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;The best laid plans&amp;quot;)
    .foregroundColor(Color.red)
    .background(Color.yellow)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/backgroundcolor_text.png&#34; alt=&#34;backgroundcolor_text&#34; title=&#34;background color&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-行间距&#34;&gt;5. 行间距&lt;/h3&gt;

&lt;p&gt;我们可以设置多行文本的行间距，行间距默认值为0，表示没有额外的行间距，但是我们可以通过以下方式在行与行之间指定一个值来添加额外的行间距。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones&amp;quot;)
    .lineLimit(nil)
    .font(.largeTitle)
    .lineSpacing(50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/line_spacing_text.png&#34; alt=&#34;line_spacing_text&#34; title=&#34;line spacing&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.2 如何使用文本视图创建静态标签</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Wed, 24 Jul 2019 13:35:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-基本用法&#34;&gt;1. 基本用法&lt;/h3&gt;

&lt;p&gt;文本视图 &lt;code&gt;Text&lt;/code&gt; 主要用于在屏幕上显示静态文本，相当于 UIKit 中的 UILabel。最基本的用法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在内容视图的预览窗口中，您可能会看到 &lt;code&gt;Automatic preview updating paused&lt;/code&gt;， 继续按 Resume 以让 Swift 开始构建代码并向您展示其外观的实时预览。&lt;/p&gt;

&lt;h3 id=&#34;2-设置显示行数&#34;&gt;2. 设置显示行数&lt;/h3&gt;

&lt;p&gt;默认情况下，Text 只显示一行 - 如果空间不足，字符将被剪切并替换为 &lt;code&gt;...&lt;/code&gt;。因此如果我们要显示的文本很长，就会看到这种情况发生。如果要改变这种行为 - 比如你希望  Text 可以显示多行文本，那么可以这样做，使其具有特定的行数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Hello world&amp;quot;)
    .lineLimit(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 请注意 &lt;code&gt;lineLimit(3)&lt;/code&gt; 位于 &lt;code&gt;Text(&amp;quot;Hello World&amp;quot;)&lt;/code&gt; 下方靠右侧的方式。这不是必需的，但它确实使您的代码更易于阅读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;或者，可以将 &lt;code&gt;nil&lt;/code&gt; 指定给 &lt;code&gt;lineLimit()&lt;/code&gt; 方法，该方法允许它根据需要运行在任意多行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Hello World&amp;quot;)
    .lineLimit(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 这里设置 &lt;code&gt;lineLimit(0)&lt;/code&gt; 不能实现多行显示，这一点跟 UIKit 中是不一样的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;3-文本截断&#34;&gt;3. 文本截断&lt;/h3&gt;

&lt;p&gt;我们也可以调整 SwiftUI 截断文本的方式，而不是调整行数。默认情况下，从末尾删除文本并显示省略号，但也可以将省略号放在中间或开头，具体取决于字符串各个部分的重要程度。&lt;/p&gt;

&lt;p&gt;例如: 以下代码会在中间截断文本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones.&amp;quot;)
    .truncationMode(.middle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不管我们如何截断文本，我们将看到文本视图始终位于主视图（main view）的中心。这是 SwiftUI 的默认行为 &amp;ndash; 除非我们明确告诉 SwiftUI 将视图定位到其他位置，否则 SwiftUI 会将视图定位到相对于屏幕中心的位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.1 工程模板介绍</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 23 Jul 2019 15:51:58 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;!-- more --&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 您可能认为本章完全可以跳过，但除非你是一个 Swift 天才，否则你应该读到最后再确定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;img/swiftui_project_template.png&#34; alt=&#34;swiftui_project_template&#34; /&gt;
如图，自 Xcode 11 之后，基本的 &lt;em&gt;Single View App&lt;/em&gt; 模板为我们提供以下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AppDelegate.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这个文件负责监视外部事件。例如，如果另一个应用程序试图向您发送要打开的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SceneDelegate.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这个文件负责管理应用程序的显示方式。例如让多个实例同时运行，或者当一个实例移动到后台时采取操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContentView.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这个文件是我们的初始用户界面。如果这是一个 UIKit 项目，这个文件相当于是 Xcode 提供给我们的 &lt;em&gt;ViewController&lt;/em&gt; 类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Assets.xcassets&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这个文件是项目的资产目录。存储着我们项目中使用的所有图像和颜色。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LaunchScreen.storyboard&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这是应用加载时显示的屏幕。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Info.plist&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这是一个属性列表文件，在本例中，它用于存储应用程序的系统级设置。例如，应该在 iOS 主屏幕的图标下面显示什么名称。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preview content&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;一个名为 &lt;em&gt;Preview content&lt;/em&gt; 的组，其中包含另一个名为 &lt;em&gt;Preview Assests&lt;/em&gt; 的资产目录。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就是这样 - 这是一个令人愉快的少量代码和资源，这意味着我们可以在此基础上进行构建。&lt;/p&gt;

&lt;p&gt;我们真正关心的是 &lt;code&gt;ContentView.swift&lt;/code&gt;，  事实上，这是唯一重要的部分。这是我们应用程序的主要功能，在这里我们可以立即开始尝试各种 &lt;code&gt;SwiftUI&lt;/code&gt; 代码。&lt;/p&gt;

&lt;p&gt;首先，是什么让 &lt;code&gt;ContentView.swift&lt;/code&gt; 显示在屏幕上？&lt;br /&gt;
好吧，如果你还记得我说过 &lt;code&gt;SceneDelegate.swift&lt;/code&gt;  负责管理应用程序的显示方式。那么，继续打开 &lt;code&gt;SceneDelegate.swift&lt;/code&gt;，您会看到下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let window = UIWindow(windowScene: windowScene)
window.rootViewController = UIHostingController(rootView: ContentView())
self.window = window
window.makeKeyAndVisible()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码创建了一个新的 &lt;code&gt;ContentView&lt;/code&gt; 实例（这是我们即将看到的主要功能），并将其放在 &lt;code&gt;window&lt;/code&gt; 中，以便在屏幕上显示。它通过显示 &lt;code&gt;ContentView&lt;/code&gt; 的第一个实例，可以有效地引导我们的应用程序，并从那里结束 - 你想做什么？&lt;/p&gt;

&lt;p&gt;打开  &lt;code&gt;ContentView.swift&lt;/code&gt; ，让我们看看实际的 SwiftUI 代码。您应该看到这样的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftUI

struct ContentView : View {
    var body: some View {
        Text(&amp;quot;Hello World&amp;quot;)
    }
}

#if DEBUG
struct ContentView_Previews : PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不是很多代码，但它确实包含了大量代码。&lt;/p&gt;

&lt;p&gt;首先，请注意，&lt;code&gt;ContentView&lt;/code&gt; 是一个结构体（struct）。熟悉 UIKit 的开发人员知道 - 我们从用户界面的所有值类型的不可变性和简单性中获益巨大！不熟悉 UIKit 的人&amp;hellip; 嗯，只是点头微笑 - 你从来不知道我们曾经的痛苦。&lt;/p&gt;

&lt;p&gt;其次，&lt;code&gt;ContentView&lt;/code&gt; 符合 &lt;code&gt;View&lt;/code&gt; 协议。你想在 SwiftUI 中显示的所有内容都需要符合 &lt;code&gt;View&lt;/code&gt;，这实际上只意味着一件事: 你需要一个名为 body 的属性来返回某种 View。&lt;/p&gt;

&lt;p&gt;第三，&lt;code&gt;body&lt;/code&gt; 的返回类型是 &lt;code&gt;some View&lt;/code&gt;。&lt;code&gt;some&lt;/code&gt; 关键字是在 Swift 5.1 中新增的，是一个名为 &lt;em&gt;不透明返回类型（opaque return types）&lt;/em&gt; 的功能的一部分，在这种情况下，它的意思是 &lt;em&gt;将返回某种视图，但 SwiftUI 不需要知道（或关心）什么。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要说明:&lt;/strong&gt; 返回 &lt;code&gt;some View&lt;/code&gt; 意味着 &lt;code&gt;body&lt;/code&gt; 属性将返回符合 &lt;code&gt;View&lt;/code&gt; 协议的内容。你不能返回很多东西或忘记返回任何东西 &amp;ndash; Swift 编译器将拒绝构建你的代码。要清楚，您的视图正文必须返回一个子视图。&lt;/p&gt;

&lt;p&gt;第四，body属性中有 &lt;code&gt;Text(&amp;quot;hello world&amp;quot;)&lt;/code&gt;，它创建了文本内容为 “hello world”的标签。&lt;/p&gt;

&lt;p&gt;最后，在 ContentView 下面的是一个类似但不同的 struct，称为 &lt;code&gt;ContentView_Previews&lt;/code&gt;。它不符合 &lt;code&gt;View&lt;/code&gt; 协议，因为它专门用于在 Xcode 中显示 视图预览（Preview），而不是在真实 app 中显示在屏幕上。这就是为什么你会看到它在 &lt;code&gt;#if DEBUG&lt;/code&gt; 和 &lt;code&gt;#endif&lt;/code&gt; 之间 - 当我们的应用程序在调试环境中运行时，这段代码只构建在 *成品（finished product）*中，因为它在生产应用程序（Production app）中没有意义。&lt;/p&gt;

&lt;p&gt;我们很快就会更详细地看一下这些组件（components），但首先让我们看一下 &lt;code&gt;Text&lt;/code&gt; 组件。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
