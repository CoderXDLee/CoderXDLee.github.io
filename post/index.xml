<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on M X</title>
    <link>https://coderxdlee.github.io/post/</link>
    <description>Recent content in Posts on M X</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>M X ©{year}</copyright>
    <lastBuildDate>Mon, 14 Oct 2019 23:51:29 +0800</lastBuildDate>
    
	    <atom:link href="https://coderxdlee.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2.12_如何使用GeometryReader提供相对大小</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.12_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8geometryreader%E6%8F%90%E4%BE%9B%E7%9B%B8%E5%AF%B9%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Mon, 14 Oct 2019 23:51:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.12_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8geometryreader%E6%8F%90%E4%BE%9B%E7%9B%B8%E5%AF%B9%E5%A4%A7%E5%B0%8F/</guid>
      <description>

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;尽管通常最好让 SwiftUI 使用堆栈执行自动布局，但也可以使用 &lt;code&gt;GeometryReader&lt;/code&gt; 给出视图相对于其容器的尺寸。 例如，如果我们希望两个视图占用屏幕上可用宽度的一半，则无法使用硬编码值，因为我们无法提前知道屏幕的宽度是多少。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，&lt;code&gt;GeometryReader&lt;/code&gt; 为我们提供了一个输入值，告诉我们可用的宽度和高度，然后我们可以在需要的任何计算中使用它。 因此，要使两个视图占据相等的宽度，我们可以将可用空间分成两半，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                Text(&amp;quot;Left&amp;quot;)
                    .frame(width: geometry.size.width / 2, height: 50)
                    .background(Color.orange)
                Text(&amp;quot;Right&amp;quot;)
                    .frame(width: geometry.size.width / 2, height: 50)
                    .background(Color.yellow)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.12_geometry_reader.png&#34; alt=&#34;2.12_geometry_reader&#34; title=&#34;Use GeometryReader&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: GeometryReader 并未考虑视图层次结构中更下方的任何偏移量或间距，这就是为什么 HStack 上没有间距的原因–如果我们在其中允许间距，则视图对于可用空间会有点太大 。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>2.11_如何给视图自定义Frame</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%87%AA%E5%AE%9A%E4%B9%89frame/</link>
      <pubDate>Mon, 14 Oct 2019 23:30:07 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%87%AA%E5%AE%9A%E4%B9%89frame/</guid>
      <description>

&lt;p&gt;默认情况下，视图仅占用所需的空间，但是如果要更改视图，可以使用 &lt;code&gt;frame()&lt;/code&gt; 修饰符告诉 SwiftUI 我们想要的大小范围。&lt;/p&gt;

&lt;h3 id=&#34;1-创建-200x200-可点击区域的按钮&#34;&gt;1. 创建 200x200 可点击区域的按钮&lt;/h3&gt;

&lt;p&gt;例如，我们可以创建一个具有 200x200 可点击区域的按钮，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 创建 200x200 可点击区域的按钮
        Button(action: {
            print(&amp;quot;Button tapped!&amp;quot;)
        }, label: {
            Text(&amp;quot;Welcome&amp;quot;)
            .frame(minWidth: 0, maxWidth: 200, minHeight: 0, maxHeight: 200)
                .font(.largeTitle)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.11_custom_frame_200_200_rectangle.png&#34; alt=&#34;2.11_custom_frame_200_200_rectangle&#34; title=&#34;Create a 200 * 200 rectangle.&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-指定-frame-使文本视图填充整个屏幕&#34;&gt;2. 指定 frame 使文本视图填充整个屏幕&lt;/h3&gt;

&lt;p&gt;我们可以通过指定一个框架来使文本视图填充整个屏幕（减去安全区域），该框架的最小宽度和高度为零，最大宽度和高度为无穷大，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 指定 frame 使文本视图填充整个屏幕
        Text(&amp;quot;Please log in&amp;quot;)
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)
            .foregroundColor(.white)
            .background(Color.red)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.11_custom_frame_text_fill_fullscreen.png&#34; alt=&#34;2.11_custom_frame_text_fill_fullscreen&#34; title=&#34;Set a frame to make text view fill the full screen.&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 如果要使视图进入安全区域，请确保添加 &lt;code&gt;.edgesIgnoringSafeArea(.all)&lt;/code&gt;修饰符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.11_custom_frame_edge_ignore_safe_area.png&#34; alt=&#34;2.11_custom_frame_edge_ignore_safe_area&#34; title=&#34;Add .edgesIgnoringSafeArea all&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.7_如何使用Z索引更改视图分层的顺序</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8z%E7%B4%A2%E5%BC%95%E6%9B%B4%E6%94%B9%E8%A7%86%E5%9B%BE%E5%88%86%E5%B1%82%E7%9A%84%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Sat, 12 Oct 2019 23:42:35 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8z%E7%B4%A2%E5%BC%95%E6%9B%B4%E6%94%B9%E8%A7%86%E5%9B%BE%E5%88%86%E5%B1%82%E7%9A%84%E9%A1%BA%E5%BA%8F/</guid>
      <description>

&lt;h3 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h3&gt;

&lt;p&gt;默认情况下，ZStack 使用 painter 的算法对其视图进行分层，以确定视图的深度: 首先放入 ZStack 中的内容会被首先绘制，然后在其上分层后续视图。&lt;/p&gt;

&lt;p&gt;尽管这通常是我们想要的，但有时我们需要更多的控制权 - 例如，我们可能希望在应用运行时将一个视图推到另一个视图的后面，或者在点击某个视图时将其移到最前面。&lt;/p&gt;

&lt;p&gt;要做到这一点，我们需要使用 &lt;code&gt;zIndex()&lt;/code&gt; 修饰符，该修饰符允许我们精确地指定视图在单个 ZStack 中的分层方式。视图的默认z索引为0，但可以提供正值或负值，分别将它们放置在其他视图的上方或下方。&lt;/p&gt;

&lt;h3 id=&#34;2-示例-绿色矩形放置在红色矩形之上&#34;&gt;2. 示例: 绿色矩形放置在红色矩形之上&lt;/h3&gt;

&lt;p&gt;例如，此 ZStack 包含两个重叠的矩形，但是绿色矩形仍然可见，因为它使用的Z索引值为1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 绿色矩形放置在红色矩形之上
        ZStack {
            Rectangle()
                .fill(Color.green)
                .frame(width: 50, height: 50)
                .zIndex(1)
            Rectangle()
                .fill(Color.red)
                .frame(width: 100, height: 100) 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.7_zIndex_green_red_rectangle.png&#34; alt=&#34;2.7_zIndex_green_red_rectangle&#34; title=&#34;Green rectangle is above on the red rectangle&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: &lt;code&gt;zIndex()&lt;/code&gt; 修饰符仅影响当前 ZStack 内的绘制顺序。 这意味着，如果我们有两个重叠的堆栈，则需要考虑堆栈的Z索引以及堆栈内部的视图。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>2.5_如何创建固定尺寸的Spacer</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E7%9A%84spacer/</link>
      <pubDate>Sat, 12 Oct 2019 23:25:11 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.5_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E7%9A%84spacer/</guid>
      <description>&lt;p&gt;SwiftUI 的 &lt;code&gt;Spacer&lt;/code&gt; 视图会自动填充其扩展轴上的所有可用空间，这是一种奇特的说法: 即根据我们所放置的内容，它们在水平或垂直方向上会占用尽可能多的空间。&lt;/p&gt;

&lt;p&gt;如果要制作一个精确大小的 &lt;code&gt;Spacer&lt;/code&gt;，则可以执行与其他视图相同的操作: 使用具有所需大小的 &lt;code&gt;frame()&lt;/code&gt; 修饰符。&lt;/p&gt;

&lt;p&gt;例如，这显示了两个文本视图，它们之间有一个50点的空格：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;First Label&amp;quot;)
                .background(Color.red)
            Spacer()
                .frame(height: 50)
            Text(&amp;quot;Second Label&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.5_make_a_fix_spacer.png&#34; alt=&#34;2.5_make_a_fix_spacer.png&#34; title=&#34;Make a fix size spacer view&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.4_如何使用Spacer将视图强制移到堆栈中的一侧</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8spacer%E5%B0%86%E8%A7%86%E5%9B%BE%E5%BC%BA%E5%88%B6%E7%A7%BB%E5%88%B0%E5%A0%86%E6%A0%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BE%A7/</link>
      <pubDate>Sat, 12 Oct 2019 21:27:39 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.4_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8spacer%E5%B0%86%E8%A7%86%E5%9B%BE%E5%BC%BA%E5%88%B6%E7%A7%BB%E5%88%B0%E5%A0%86%E6%A0%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BE%A7/</guid>
      <description>

&lt;p&gt;默认情况下，SwiftUI 会将其视图居中，这意味着: 如果将三个文本视图放在 VStack 中，则这三个文本视图将垂直居中显示在屏幕上。如果要更改此设置(如果要强制视图朝向屏幕的顶部/底部/左侧/右侧)，则应使用 &lt;code&gt;Spacer&lt;/code&gt; 视图。&lt;/p&gt;

&lt;h3 id=&#34;1-不使用-spacer&#34;&gt;1. 不使用 Spacer&lt;/h3&gt;

&lt;p&gt;例如，我们将一个文本视图放置在 VStack 内，这意味着它将垂直居中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        
        // 1. 不使用 Spacer
        VStack {
            Text(&amp;quot;Hello World&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_default_without_spacer.png&#34; alt=&#34;2.4_default_without_spacer&#34; title=&#34;Without spacer view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-将文本视图推到父视图的顶部&#34;&gt;2. 将文本视图推到父视图的顶部&lt;/h3&gt;

&lt;p&gt;要将文本视图推到父视图的顶部，我们将在其下面放置一个 &lt;code&gt;Spacer&lt;/code&gt; 视图，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 使用 Spacer 将文本视图推到父视图顶部
        VStack {
            Text(&amp;quot;Hello World&amp;quot;)
            Spacer()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_push_text_to_top.png&#34; alt=&#34;2.4_push_text_to_top&#34; title=&#34;Push text view to super view&#39;s top using spacer view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-在-hstack-中使用-spacer&#34;&gt;3. 在 HStack 中使用 Spacer&lt;/h3&gt;

&lt;p&gt;如果我们希望在 HStack 的前后边缘上有两段文字，可以使用这样的分隔符:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 在 HStack 中使用 Spacer
        HStack {
            Text(&amp;quot;Hello&amp;quot;)
            Spacer()
            Text(&amp;quot;World&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_using_spacer_in_hstack.png&#34; alt=&#34;2.4_using_spacer_in_hstack&#34; title=&#34;Using spacer view in HStack, to seperate two text views&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-多个-spacer-分割空间&#34;&gt;4. 多个 Spacer 分割空间&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Spacer&lt;/code&gt; 会自动分割所有剩余空间，这意味着如果您使用多个 Spacer，则可以按不同数量分割空间。&lt;/p&gt;

&lt;p&gt;例如，这将通过在其上放置一个空格，在其后放置两个空格，将文本视图置于其父视图的三分之一以下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 多个 Spacer 分割空间
        VStack {
            Spacer()
            Text(&amp;quot;Hello world.&amp;quot;)
            Spacer()
            Spacer()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.4_using_multi_spacer.png&#34; alt=&#34;2.4_using_multi_spacer&#34; title=&#34;Using multi spacer view to divide up all remaining space&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果为 &lt;code&gt;Spacer&lt;/code&gt; 提供一定范围的值，例如使用 &lt;code&gt;.frame（minHeight: 50,maxHeight:500）&lt;/code&gt;，则它将自动占用尽可能多的空间，直到您设置的最大值。 以这种方式添加一些灵活性通常是一个好主意，这样我们的用户界面就可以更轻松地跨设备扩展。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.2_搭建 Flutter 的开发环境</title>
      <link>https://coderxdlee.github.io/post/flutter/01-getting_started_with_flutter/1.2_setting_up_development_environment/</link>
      <pubDate>Thu, 19 Sep 2019 00:17:27 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/flutter/01-getting_started_with_flutter/1.2_setting_up_development_environment/</guid>
      <description>

&lt;!-- more --&gt;

&lt;p&gt;我们可以在 macOS，Linux 或 Windows 上进行 Flutter 开发。 虽然我们可以使用任何带有 &lt;strong&gt;Flutter 工具链&lt;/strong&gt; 的编辑器，但是 &lt;code&gt;IntelliJ IDEA&lt;/code&gt;，&lt;code&gt;Android Studio&lt;/code&gt; 和 &lt;code&gt;Visual Studio Code&lt;/code&gt; 的 IDE 插件可以简化开发周期。 我们将使用 &lt;strong&gt;VS Code&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&#34;1-下载-sdk&#34;&gt;1 - 下载 SDK&lt;/h1&gt;

&lt;p&gt;下载开发机器操作系统对应的安装包，以获取 &lt;code&gt;Flutter SDK&lt;/code&gt; 的最新稳定版本。这里，我使用的是 Mac 操作系统:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;macOS Catalina&lt;/li&gt;
&lt;li&gt;10.15 Beta版(19A558d)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-1-系统要求&#34;&gt;1.1 系统要求&lt;/h2&gt;

&lt;p&gt;要安装和运行 Flutter，我们的开发环境必须满足以下最低要求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作系统: macOS(64位)&lt;/li&gt;
&lt;li&gt;磁盘空间: 2.8 GB（不包括IDE /工具的磁盘空间）&lt;/li&gt;
&lt;li&gt;工具: Flutter 依赖于您的环境中可用的这些命令行工具

&lt;ul&gt;
&lt;li&gt;bash&lt;/li&gt;
&lt;li&gt;curl&lt;/li&gt;
&lt;li&gt;git 2.x&lt;/li&gt;
&lt;li&gt;mkdir&lt;/li&gt;
&lt;li&gt;rm&lt;/li&gt;
&lt;li&gt;unzip&lt;/li&gt;
&lt;li&gt;which&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-获取-flutter-sdk&#34;&gt;1.2 获取 Flutter SDK&lt;/h2&gt;

&lt;h3 id=&#34;1-2-1-下载以下安装包以获取-flutter-sdk-的最新稳定版本&#34;&gt;1.2.1 下载以下安装包以获取 Flutter SDK 的最新稳定版本&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://flutter.dev/docs/development/tools/sdk/releases?tab=macos&#34; target=&#34;_blank&#34;&gt;Flutter SDK archive for macOS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我下载的是当前最新版本 &lt;code&gt;flutter_macos_v1.9.1+hotfix.2-stable&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;1-2-2-在目标位置提取文件&#34;&gt;1.2.2 在目标位置提取文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt; cd ~/development
 unzip ~/Downloads/flutter_macos_v1.9.1+hotfix.2-stable.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-3-将-flutter-工具添加到我们的路径-path&#34;&gt;1.2.3 将 Flutter 工具添加到我们的路径(PATH)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;临时路径&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;export PATH=&amp;quot;$PATH:`pwd`/flutter/bin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此命令仅为当前终端窗口设置 PATH 变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;永久路径&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;export PATH=&amp;quot;$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以在命令行更新当前会话的 PATH 变量，如临时路径中所示。 但是，我们可能希望永久更新此变量，以便于我们可以在任何终端会话中运行 flutter 命令。&lt;/p&gt;

&lt;p&gt;为所有终端会话永久修改此变量的步骤是特定于计算机的。通常，您会在打开新窗口时执行的文件中添加一行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第1步: 确定放置 Flutter SDK 的目录。第 3 步需要用到。&lt;/li&gt;
&lt;li&gt;第2步: 为你的 shell 打开或创建 &lt;code&gt;rc&lt;/code&gt; 文件。

&lt;ul&gt;
&lt;li&gt;macOS Mojave(及更早版本) 默认使用 &lt;code&gt;Bash shell&lt;/code&gt;，因此编辑 &lt;code&gt;$HOME/.bashrc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;macOS Catalina 默认使用 &lt;code&gt;Z shell&lt;/code&gt;，因此编辑 &lt;code&gt;$HOME/.zshrc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果你使用的是其他 shell，则计算机上的文件路径和文件名将有所不同。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第3步: 添加以下行并将 &lt;code&gt;[PATH_TO_FLUTTER_GIT_DIRECTORY]&lt;/code&gt; 更改为克隆 Flutter 的 git repo 的路径:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;export PATH=&amp;quot;$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的路径为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;export PATH=&amp;quot;/Users/devin/development/flutter/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第4步: 运行 &lt;code&gt;source $ HOME /.&amp;lt;rc file&amp;gt;&lt;/code&gt; 刷新当前窗口使 &lt;code&gt;rc&lt;/code&gt; 文件立即生效，或打开一个新的终端窗口以自动获取文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第5步: 通过运行以下命令验证 &lt;code&gt;flutter/bin&lt;/code&gt; 目录现在位于PATH中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;echo $PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过运行以下命令验证 flutter 命令是否可用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;which flutter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/1.2_echo_$PATH_which_flutter.png&#34; alt=&#34;1.2_echo_$PATH_which_flutter&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-2-4-可选操作-预先下载开发二进制文件&#34;&gt;1.2.4 可选操作: 预先下载开发二进制文件&lt;/h3&gt;

&lt;p&gt;Flutter 工具根据需要下载特定平台的开发二进制文件。可以通过运行以下方式提前下载iOS和Android二进制文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;flutter precache
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-3-执行-flutter-doctor-命令&#34;&gt;1.3 执行 flutter doctor 命令&lt;/h2&gt;

&lt;p&gt;运行以下命令以查看是否需要安装任何依赖项来完成设置（对于详细输出，请添加-v标志）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;flutter doctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此命令检查您的环境并向终端窗口显示报告。 Dart SDK 与 Flutter 捆绑在一起; 没有必要单独安装 Dart。 仔细检查输出以了解可能需要安装的其他软件或执行的其他任务（以粗体显示）。&lt;/p&gt;

&lt;p&gt;例如:
&lt;img src=&#34;img/1.2_flutter_doctor.png&#34; alt=&#34;1.2_flutter_doctor&#34; /&gt;
如图可知，我们需要安装的依赖项如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Flutter SDK

&lt;ul&gt;
&lt;li&gt;我们已经通过之前的步骤安装成功。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Android toolchain

&lt;ul&gt;
&lt;li&gt;Android SDK 我们可以通过 Android Studio 的 SDK Manager 来下载安装，这里最新版本需要下载 &lt;code&gt;android-29&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Xcode

&lt;ul&gt;
&lt;li&gt;通过 AppStore 或者 苹果开发者网站&lt;a href=&#34;https://developer.apple.com/download/&#34; target=&#34;_blank&#34;&gt;下载&lt;/a&gt;即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Android Studio

&lt;ul&gt;
&lt;li&gt;Android Studio 官网&lt;a href=&#34;https://developer.android.com/studio&#34; target=&#34;_blank&#34;&gt;下载&lt;/a&gt;即可。&lt;/li&gt;
&lt;li&gt;需要在 Android Studio 客户端上安装 &lt;code&gt;Flutter plugin&lt;/code&gt; 和 &lt;code&gt;Dart plugin&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;VS Code

&lt;ul&gt;
&lt;li&gt;Visual Studio Code 官网&lt;a href=&#34;https://code.visualstudio.com/&#34; target=&#34;_blank&#34;&gt;下载&lt;/a&gt;即可。&lt;/li&gt;
&lt;li&gt;需要在 Visual Studio Code 客户端上安装 &lt;code&gt;Flutter plugin&lt;/code&gt; 和 &lt;code&gt;Dart plugin&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Connected device

&lt;ul&gt;
&lt;li&gt;iOS 可以通过执行 &lt;code&gt;open -a simulator&lt;/code&gt; 快速打开一个模拟器；Android 可以通过 Android Studio 打开一个 emulator。
下图表示所有依赖项安装完毕:
&lt;img src=&#34;img/1.2_flutter_doctor_v_done.png&#34; alt=&#34;1.2_flutter_doctor_v_done&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，Flutter 的开发环境就搭建完成了，接下来，我们就可以进行 flutter 的开发了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.1_Flutter 简介</title>
      <link>https://coderxdlee.github.io/post/flutter/01-getting_started_with_flutter/1.1_introduction_to_flutter/</link>
      <pubDate>Tue, 17 Sep 2019 10:20:30 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/flutter/01-getting_started_with_flutter/1.1_introduction_to_flutter/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h1 id=&#34;1-前言&#34;&gt;1 - 前言&lt;/h1&gt;

&lt;p&gt;自从十年前 iOS 和 Android 平台出现爆发式增长以来，跨平台开发(cross-platform development)一直是移动开发界的一个目标。同时为 iOS 和 Android 编写一个应用程序的能力可以为您的公司和团队节省大量的时间和精力。&lt;/p&gt;

&lt;p&gt;多年来，已经发布了各种用于跨平台开发的工具，包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于 Web 的工具: 如 Adobe 的 &lt;code&gt;PhoneGap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;强大的框架: 如 Microsoft 的 &lt;code&gt;Xamarin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;较新的工具: 如 Facebook 的 &lt;code&gt;React Native&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个工具集都有优缺点，它们在移动行业中都取得了不同程度的成功。&lt;/p&gt;

&lt;p&gt;当然，进入跨平台开发领域的最新框架是来自 Google 的 &lt;code&gt;Flutter&lt;/code&gt;。Flutter 在两个平台上都具有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;快速的开发周期&lt;/li&gt;
&lt;li&gt;快速的 UI 渲染&lt;/li&gt;
&lt;li&gt;独特的 UI 设计&lt;/li&gt;
&lt;li&gt;原生应用程序性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-介绍&#34;&gt;2 - 介绍&lt;/h1&gt;

&lt;p&gt;Flutter 应用程序是使用 &lt;code&gt;Dart&lt;/code&gt; 编程语言编写的，也是源自 Google，现在是 ECMA 标准。Dart 与其他现代语言（如 &lt;code&gt;Kotlin&lt;/code&gt; 和 &lt;code&gt;Swift&lt;/code&gt;）具有许多相同的特性，可以被编译成&lt;code&gt;Javascript&lt;/code&gt; 代码。&lt;/p&gt;

&lt;h2 id=&#34;支持-aot&#34;&gt;支持 AOT&lt;/h2&gt;

&lt;p&gt;作为一个跨平台框架，Flutter 与 React Native 最为相似，因为 Flutter 允许一种 &lt;strong&gt;响应式&lt;/strong&gt; 和 &lt;strong&gt;声明式&lt;/strong&gt; 的编程风格。 然而，与 React Native 不同，Flutter 不需要使用 &lt;code&gt;Javascript bridge&lt;/code&gt;，这样就可以改善应用程序启动时间和整体性能。 Dart 通过使用 &lt;code&gt;Ahead-Of-Time&lt;/code&gt; 或 &lt;code&gt;AOT&lt;/code&gt; 编译来实现此目的。&lt;/p&gt;

&lt;h2 id=&#34;支持-jit&#34;&gt;支持 JIT&lt;/h2&gt;

&lt;p&gt;Dart 的另一个独特之处是它也可以使用 &lt;code&gt;Just-In-Time&lt;/code&gt; 或 &lt;code&gt;JIT&lt;/code&gt; 编译。 使用 Flutter进行 JIT 编译通过允许 &lt;strong&gt;热重载(hot reload)&lt;/strong&gt; 功能在开发期间刷新 UI， 而无需全新的构建，从而改进了开发工作流程。&lt;/p&gt;

&lt;h2 id=&#34;widgets&#34;&gt;Widgets&lt;/h2&gt;

&lt;p&gt;Flutter 框架是围绕 &lt;code&gt;窗口小部件(Widgets)&lt;/code&gt; 的思想构建的。在 Flutter 中，widgets 不仅用于应用程序的视图，还用于整个屏幕，甚至用于应用程序本身。&lt;/p&gt;

&lt;h2 id=&#34;fuchsia&#34;&gt;Fuchsia&lt;/h2&gt;

&lt;p&gt;除了跨平台的 iOS 和 Android 开发之外，学习 Flutter 还将为您开发 &lt;code&gt;Fuchsia&lt;/code&gt; 平台提供一个良好的开端，该平台目前是 Google 开发的实验性操作系统。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>14_SwiftUI的提示和技巧</title>
      <link>https://coderxdlee.github.io/post/swiftui/14-swift_tips_and_tricks/14-swiftui%E7%9A%84%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sat, 10 Aug 2019 22:31:10 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/14-swift_tips_and_tricks/14-swiftui%E7%9A%84%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7/</guid>
      <description>

&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 拥有强大的标题功能，但也有许多较小的提示和技巧可以帮助我们编写更好的应用程序。&lt;/p&gt;

&lt;h3 id=&#34;1-恢复实时预览-resume-the-live-preview&#34;&gt;1. 恢复实时预览(Resume the live preview)&lt;/h3&gt;

&lt;p&gt;在编写代码时对我们的布局进行实时预览是 Xcode 的一个很好的功能，但是我们通常会看到它暂停了，因为我们做了很多更改，而 Xcode 无法跟上。
这是 SwiftUI 开发者最重要的键盘快捷键: 按 &lt;code&gt;Option + Cmd + P&lt;/code&gt; 可立即重新加载预览窗口，并恢复其实时更新，而不是一直通过触摸板来按 &lt;code&gt;Resume&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-使-state-私有化-make-state-private&#34;&gt;2. 使 &lt;code&gt;@State&lt;/code&gt; 私有化(Make @State private)&lt;/h3&gt;

&lt;h3 id=&#34;3-具有常量绑定的原型-prototype-with-constant-bindings&#34;&gt;3. 具有常量绑定的原型(Prototype with constant bindings)&lt;/h3&gt;

&lt;h3 id=&#34;4-显示测试视图-presenting-test-views&#34;&gt;4. 显示测试视图(Presenting test views)&lt;/h3&gt;

&lt;h3 id=&#34;5-超过10个视图限制-go-past-the-10-view-limit&#34;&gt;5. 超过10个视图限制(Go past the 10 view limit)&lt;/h3&gt;

&lt;h3 id=&#34;6-使用语义颜色-use-semantic-colors&#34;&gt;6. 使用语义颜色(Use semantic colors)&lt;/h3&gt;

&lt;h3 id=&#34;7-依靠自适应填充-rely-on-adaptive-padding&#34;&gt;7. 依靠自适应填充(Rely on adaptive padding)&lt;/h3&gt;

&lt;h3 id=&#34;8-合并文本视图-combine-text-views&#34;&gt;8. 合并文本视图(Combine text views)&lt;/h3&gt;

&lt;h3 id=&#34;9-如何使-print-工作-how-to-make-print-work&#34;&gt;9. 如何使 &lt;code&gt;print()&lt;/code&gt; 工作(How to make print() work)&lt;/h3&gt;

&lt;h3 id=&#34;10-依赖隐式-hstack-relying-on-the-implicit-hstack&#34;&gt;10. 依赖隐式 &lt;code&gt;HStack&lt;/code&gt;(Relying on the implicit HStack)&lt;/h3&gt;

&lt;h3 id=&#34;11-分割大视图-splitting-up-large-views&#34;&gt;11. 分割大视图(Splitting up large views)&lt;/h3&gt;

&lt;h3 id=&#34;12-更好的预览-better-previewing&#34;&gt;12. 更好的预览(Better previewing)&lt;/h3&gt;

&lt;h3 id=&#34;13-创建自定义修改器-create-custom-modifiers&#34;&gt;13. 创建自定义修改器(Create custom modifiers)&lt;/h3&gt;

&lt;h3 id=&#34;14-轻松设置更改动画-animate-changes-easily&#34;&gt;14.轻松设置更改动画(Animate changes easily)&lt;/h3&gt;

&lt;h3 id=&#34;15-从绑定中发布新值-publishing-new-values-from-a-binding&#34;&gt;15. 从绑定中发布新值(Publishing new values from a binding)&lt;/h3&gt;

&lt;h3 id=&#34;16&#34;&gt;16.&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>13.5_如何使用Instruments来分析SwiftUI代码并识别缓慢的布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/13-tooling/13.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8instruments%E6%9D%A5%E5%88%86%E6%9E%90swiftui%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%AF%86%E5%88%AB%E7%BC%93%E6%85%A2%E7%9A%84%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 08 Aug 2019 10:14:06 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/13-tooling/13.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8instruments%E6%9D%A5%E5%88%86%E6%9E%90swiftui%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%AF%86%E5%88%AB%E7%BC%93%E6%85%A2%E7%9A%84%E5%B8%83%E5%B1%80/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;Xcode 的 &lt;code&gt;Instruments&lt;/code&gt; 工具为 SwiftUI 提供了一套出色的分析功能，允许我们确定重新绘制视图的频率、计算视图主体的缓慢次数，甚至可以确定状态随时间的变化情况。&lt;/p&gt;

&lt;h3 id=&#34;2-准备工作&#34;&gt;2. 准备工作&lt;/h3&gt;

&lt;p&gt;首先，我们需要一些能够提供我们在 &lt;code&gt;Instruments&lt;/code&gt; 中可以看到的有趣结果的东西。所以，这段代码创建了一个计时器，它每隔0.01秒触发一次，并且有一个显示随机UUID的Body视图和一个按钮，每当点击它时会增加它显示的值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Combine
import SwiftUI

class FrequentUpdater: ObservableObject, Identifiable {
   var didChange = PassthroughSubject&amp;lt;Void, Never&amp;gt;()
   var timer: Timer?

   init() {
      timer = Timer.scheduledTimer(
         withTimeInterval: 0.01,
         repeats: true
      ) { _ in
         self.didChange.send(())
      }
   }
}

struct ContentView : View {
   @ObservedObject var updater = FrequentUpdater()
   @State var tapCount = 0

   var body: some View {
      VStack {
         Text(&amp;quot;\(UUID().uuidString)&amp;quot;)

         Button(action: {
            self.tapCount += 1
         }) {
            Text(&amp;quot;Tap count: \(tapCount)&amp;quot;)
         }
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们在模拟器中运行该代码，我们将看到它不断重绘，因为它的值始终在变化。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 这是一个专门设计的压力测试，旨在使 SwiftUI 做很多工作，以便 Instruments 向我们展示有趣的数据 - 我们不想在实际应用中使用上述代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;3-检测我们的代码&#34;&gt;3. 检测我们的代码&lt;/h3&gt;

&lt;p&gt;现在按 &lt;code&gt;Cmd + I&lt;/code&gt; 通过 Instruments 运行代码，然后选择 SwiftUI instruments。
&lt;img src=&#34;img/13.5_instruments_template.png&#34; alt=&#34;13.5_instruments_template&#34; /&gt;
出现时，按录制按钮使其启动应用程序并开始观看。 现在让它运行几秒钟，同时单击按钮十次左右，然后在仪器中按停止 - 我们有足够的数据可以使用。&lt;/p&gt;

&lt;p&gt;默认情况下，SwiftUI仪器会告诉我们很多事情:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在这段时间内创建了多少个视图以及创建这些视图需要多长时间（&amp;rdquo;View Body&amp;rdquo;）。&lt;/li&gt;
&lt;li&gt;视图的属性是什么以及它们随时间的变化（&amp;rdquo;View Properties&amp;rdquo;）。&lt;/li&gt;
&lt;li&gt;发生了多少个核心动画提交（&amp;rdquo;Core Animation Commits&amp;rdquo;）。&lt;/li&gt;
&lt;li&gt;每个函数调用所用的确切时间（&amp;rdquo;Time Profiler&amp;rdquo;）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些工具中的每一个都可以帮助我们诊断和解决 SwiftUI 应用程序中的性能问题，因此值得花时间尝试一下。&lt;/p&gt;

&lt;p&gt;对于我们的小压力测试沙箱，您将看到 &lt;code&gt;View Body&lt;/code&gt;，&lt;code&gt;View Properties&lt;/code&gt; 和 &lt;code&gt;Core Animation Commits&lt;/code&gt; 的纯色墙，这是一个直接的红旗。 它告诉我们，SwiftUI 不仅要不断重新创建我们的视图，而且我们的属性也在不断变化，因此 Core Animation 必须加班加点才能跟上。&lt;/p&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/13.5_instruments_swiftui.png&#34; alt=&#34;13.5_instruments_swiftui&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-监控主题调用&#34;&gt;4. 监控主题调用&lt;/h3&gt;

&lt;p&gt;如果我们选择 &lt;code&gt;View Body&lt;/code&gt; 轨道 - 这是 instruments 列表中的第一行 - 我们应该能够看到 instruments 将结果分解为 &lt;code&gt;SwiftUI&lt;/code&gt; 和 &lt;code&gt;我们的项目&lt;/code&gt;，前者是原始类型，如文本视图和按钮，后者包含我们的自定义视图类型。 在我们的例子中，这意味着 &amp;ldquo;ContentView&amp;rdquo; 应该出现在自定义视图中，因为这是我们视图的名称。&lt;/p&gt;

&lt;p&gt;现在，在这里我们将看不到一个完美的代码到 SwiftUI 视图的一对一映射，因为 SwiftUI 会积极地折叠其视图层次结构，以尽可能少地进行工作。所以，不要期望在代码中看到任何 &lt;code&gt;VStack&lt;/code&gt; 创建——这对于这个应用程序来说是免费的。&lt;/p&gt;

&lt;p&gt;在这个屏幕上，重要的数字是 &lt;code&gt;计数(Count)&lt;/code&gt;和 &lt;code&gt;平均持续时间(Avg Duration)&lt;/code&gt; - 每件事创建的次数，以及花费的时间。 因为这是一个压力测试我们应该看到非常高的数字，但我们的布局是微不足道的，所以平均持续时间可能是几十微秒。&lt;/p&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/13.5_instruments_monitoring_body_invocations.png&#34; alt=&#34;13.5_instruments_monitoring_body_invocations&#34; title=&#34;Monitoring body invocations&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-跟踪状态变化&#34;&gt;5. 跟踪状态变化&lt;/h3&gt;

&lt;p&gt;接下来，选择 &lt;code&gt;View Properties&lt;/code&gt; 轨道，这是 instruments 列表中的第二行。 这将显示所有视图的所有属性，包括其当前值和所有先前值。&lt;/p&gt;

&lt;p&gt;我们的示例应用程序有一个按钮，通过在数字中给一个数字加1来更改其标签，并且在此工具中可见 - 请查看视图类型 ContentView 和 属性类型 &lt;code&gt;@State&amp;lt;Int&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;遗憾的是，&lt;code&gt;Instruments&lt;/code&gt; 还没有（还能）向我们展示那里的确切属性名称，如果你跟踪了几个整数状态，这可能会更加令人困惑。然而，它确实有一个不同的技巧：在记录窗口的顶部是一个标记当前视图位置的箭头，如果你拖动它，你会看到应用程序状态随时间的变化 - 每次你点击按钮，你会看到状态整数上升一个，你可以前进和后退来看它发生。&lt;/p&gt;

&lt;p&gt;这可以解锁大量的功能，因为它可以让我们直接看到状态变化导致慢速重绘或其他工作 - 这几乎就像是在时间机器中，您可以在运行期间的每个点检查应用程序的确切状态。
&lt;img src=&#34;img/13.5_instruments_tracking_state_changes.png&#34; alt=&#34;13.5_instruments_tracking_state_changes&#34; title=&#34;Tracking state changes&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-识别缓慢绘制&#34;&gt;6. 识别缓慢绘制&lt;/h3&gt;

&lt;p&gt;虽然 SwiftUI 能够直接下载到 Metal 以提高性能，但大多数情况下它更喜欢使用 &lt;code&gt;Core Animation&lt;/code&gt; 进行渲染。 这意味着我们会自动从 Instruments 获取内置的 &lt;code&gt;Core Animation分析工具&lt;/code&gt;，包括检测昂贵提交的能力。&lt;/p&gt;

&lt;p&gt;当多个更改一起放入一个组（称为事务）时，Core Animation 的效果最佳。 我们在一个事务中有效地堆叠了一系列工作，然后要求CA继续渲染工作 - 称为提交事务。&lt;/p&gt;

&lt;p&gt;因此，当 Instruments 向我们展示昂贵的 Core Animation 提交时，它真正向我们展示的是SwiftUI 因为更新而被迫重绘屏幕上的像素的次数。 理论上，这应该只在我们的应用程序的实际状态导致不同的视图层次结构时发生，因为 SwiftUI 应该能够将我们的 body 属性的新输出与先前的输出进行比较。
&lt;img src=&#34;img/13.5_instruments_identifying_slow_draws.png&#34; alt=&#34;13.5_instruments_identifying_slow_draws&#34; title=&#34;Identifying slow draws&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;7-查找缓慢的函数调用&#34;&gt;7. 查找缓慢的函数调用&lt;/h3&gt;

&lt;p&gt;最后一个重要的轨道是最后一个，&lt;code&gt;Time Profiler&lt;/code&gt;，它向我们展示了在代码的每个部分花费了多少时间。 这与乐器中的常规时间分析器完全相同，但如果您之前没有尝试过，那么您至少需要知道：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;右边的扩展细节窗口显示了默认情况下最重的堆栈跟踪，这是运行时间最长的一段代码。亮代码（白色或黑色，取决于您的MacOS颜色方案）是您编写的代码；暗代码（灰色）是系统库代码。&lt;/li&gt;
&lt;li&gt;在左边，您可以看到所有创建的线程，以及让您深入到它们调用的函数和那些被调用的函数的公开指示器，等等。大部分工作将在“开始”中进行。&lt;/li&gt;
&lt;li&gt;为了避免混乱，您可能需要单击底部的调用树按钮，然后选择隐藏系统库。这只会显示您编写的代码，但是如果您的问题是您使用的系统库不好，这可能没有帮助。&lt;/li&gt;
&lt;li&gt;为了直接了解具体的细节，您还可以单击Call Tree并选择Invert Call Tree来翻转内容，这样叶子函数（位于树的末尾）就会显示在顶部，而披露指标现在可以让您向下钻取（向上钻取？）调用它们的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然时间分析器对于识别性能问题非常有用，但通常仅查看最重的堆栈跟踪将突出显示最大的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/13.5_instruments_looking_for_slow_function_calls.png&#34; alt=&#34;13.5_instruments_looking_for_slow_function_calls&#34; title=&#34;Looking for slow function calls&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;8-最后的提示&#34;&gt;8. 最后的提示&lt;/h3&gt;

&lt;p&gt;在您收取配置自己的代码之前，有一些事情需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在检查应用程序性能的一小部分时，您应该单击并拖动相关范围，以便仅查看该应用程序部分的统计信息。这使您可以专注于特定操作的性能，例如响应按下按钮。&lt;/li&gt;
&lt;li&gt;即使你在仪器中看到纯色条，它们只是从远处看起来那样 - 你可以通过按住 Cmd 并按 - 和+来查看更多细节&lt;/li&gt;
&lt;li&gt;要获得最准确的数字，请始终在真实设备上进行配置。&lt;/li&gt;
&lt;li&gt;如果要通过分析代码进行更改，请始终一次进行一项更改。如果你进行两次更改，可能会使你的性能提高20％而另一种会降低10％，但是将它们合在一起意味着你可能会认为它们整体性能提高了10％。&lt;/li&gt;
&lt;li&gt;Instruments 在发布模式下运行您的代码，从而实现 Swift 的所有优化。这也会影响您添加到代码中的任何调试标志，因此请小心。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>13.4_如何在导航视图中预览布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/13-tooling/13.4_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 08 Aug 2019 10:02:39 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/13-tooling/13.4_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果我们设计了一个视图，我们知道它将作为导航堆栈的一部分显示，但本身不包含导航视图，那么默认情况下，我们将看不到它的导航栏标题或按钮。&lt;/p&gt;

&lt;p&gt;幸运的是，我们可以将视图添加到预览中的导航视图中——这模拟了在顶部有一个导航栏，而实际上没有为实时代码添加一个导航栏，因此我们可以准确地看到它的外观。&lt;/p&gt;

&lt;p&gt;例如，此视图没有导航视图，但配置为在作为一个视图的一部分呈现时以特定方式显示 - 即从另一个视图推送:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello World&amp;quot;)
            .navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要在导航视图中预览，只需在预览中的内容视图周围添加 &lt;code&gt;NavigationView&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            ContentView()
        }
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这使我们可以准确地查看视图的外观，而无需修改视图的实际布局。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>13.3_如何在不同设备中预览布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/13-tooling/13.3_%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 08 Aug 2019 09:42:15 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/13-tooling/13.3_%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E4%B8%AD%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;Xcode 的 SwiftUI 预览允许我们使用 &lt;code&gt;.previewDevice()&lt;/code&gt; 修改器同时以多种屏幕尺寸显示我们的设计。 这需要提供设备的确切名称，如 Xcode 的目的地菜单中所示，例如， &amp;ldquo;iPhone XS Max&amp;rdquo;。&lt;/p&gt;

&lt;h3 id=&#34;2-在-iphone-se-上预览&#34;&gt;2. 在 iPhone SE 上预览&lt;/h3&gt;

&lt;p&gt;例如，下面代码显示了 iPhone SE上的预览:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello World&amp;quot;)
            .background(Color.red)
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
           ContentView()
              .previewDevice(PreviewDevice(rawValue: &amp;quot;iPhone SE&amp;quot;))
        }
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/13.3_preview_in_device_iphonese_without_devicename.png&#34; alt=&#34;13.3_preview_in_device_iphonese&#34; title=&#34;&amp;quot;Preview in iPhone SE without device name&amp;quot;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-显示设备名称&#34;&gt;3. 显示设备名称&lt;/h3&gt;

&lt;p&gt;使用特定设备进行预览时，我们可能会发现添加 &lt;code&gt;.previewDisplayName()&lt;/code&gt; 修改器非常有用，它允许我们在预览窗口中的设备下添加名称。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello World&amp;quot;)
            .background(Color.red)
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
           ContentView()
              .previewDevice(PreviewDevice(rawValue: &amp;quot;iPhone SE&amp;quot;))
              .previewDisplayName(&amp;quot;iPhone SE&amp;quot;)
        }
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/13.3_preview_in_device_iphonese_with_devicename.png&#34; alt=&#34;13.3_preview_in_device_iphonese_with_devicename&#34; title=&#34;Preview in iPhone SE with device name&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-创建多个设备的预览&#34;&gt;4. 创建多个设备的预览&lt;/h3&gt;

&lt;p&gt;例如，下面代码会为两个不同的设备创建两个预览，添加每个设备的名称以明确发生了什么:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello World&amp;quot;)
            .background(Color.red)
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView()
                .previewDevice(PreviewDevice(rawValue: &amp;quot;iPhone SE&amp;quot;))
                .previewDisplayName(&amp;quot;iPhone SE&amp;quot;)
            ContentView()
                .previewDevice(PreviewDevice(rawValue: &amp;quot;iPhone XS Max&amp;quot;))
                .previewDisplayName(&amp;quot;iPhone XS Max&amp;quot;)
        }
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>13.2_如何在light和dark模式下预览布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/13-tooling/13.2_%E5%A6%82%E4%BD%95%E5%9C%A8light%E5%92%8Cdark%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</link>
      <pubDate>Wed, 07 Aug 2019 18:25:14 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/13-tooling/13.2_%E5%A6%82%E4%BD%95%E5%9C%A8light%E5%92%8Cdark%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;Apple的大多数操作系统都支持亮模式和暗模式用户界面，因此 SwiftUI 内置支持此功能也就不足为奇了。&lt;/p&gt;

&lt;p&gt;更好的是，一旦我们设计了界面，Xcode 允许我们通过在预览中设置 &lt;code&gt;\.colorScheme&lt;/code&gt; 环境值来以任一颜色方案预览布局。&lt;/p&gt;

&lt;p&gt;例如，下面显示使用暗模式的预览:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG
struct ContentView_Previews : PreviewProvider {
   static var previews: some View {
      Group {
         ContentView()
            .environment(\.colorScheme, .dark)
      }
   }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们要并排查看明暗模式，请在组中放置多个预览，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView()
                .environment(\.colorScheme, .light)
            
            ContentView()
                .environment(\.colorScheme, .dark)
        }
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/13.2_preview_your_layout_in_light_and_dark_mode.gif&#34; alt=&#34;13.2_preview_your_layout_in_light_and_dark_mode&#34; title=&#34;Preview your layout in light and dark mode&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;提示: 如果我们的预览已缩放，则应滚动或缩小到其他预览。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>13.1_如何以不同的动态类型大小预览布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/13-tooling/13.1_%E5%A6%82%E4%BD%95%E4%BB%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</link>
      <pubDate>Wed, 07 Aug 2019 18:14:51 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/13-tooling/13.1_%E5%A6%82%E4%BD%95%E4%BB%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E9%A2%84%E8%A7%88%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;构建应用程序时，确保布局在所有动态类型范围内都能正常运行至关重要。 这部分是因为 SwiftUI 本身支持它，部分原因是许多人使用较小的字体大小，因为他们需要更高的信息密度，但主要是因为许多具有可访问性需求的人都依赖它。&lt;/p&gt;

&lt;p&gt;幸运的是，SwiftUI 的所有组件本身都适应动态类型大小，通过在预览中使用 &lt;code&gt;\.sizeCategory&lt;/code&gt; 环境值，可以轻松预览各种大小的设计。&lt;/p&gt;

&lt;p&gt;例如，如果我们想要查看视图如何使用额外的小文本，我们可以将 &lt;code&gt;.environment（\.size Category，.extra Small)&lt;/code&gt; 添加到内容视图预览中，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView()
                .environment(\.sizeCategory, .extraSmall)
        }
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以发回一组预览，所有预览都使用不同的大小类别。 这使我们可以并排查看各种字体大小的相同设计。&lt;/p&gt;

&lt;p&gt;因此，此代码显示了超小尺寸，常规尺寸和最大尺寸的设计:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView()
                .environment(\.sizeCategory, .extraSmall)
            
            ContentView()
            
            ContentView()
            .environment(\.sizeCategory, .accessibilityExtraExtraExtraLarge)
        }
    }
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/13.1_preview_your_layout_at_different_dynamic_type_sizes.gif&#34; alt=&#34;13.1_preview_your_layout_at_different_dynamic_type_sizes&#34; title=&#34;Preview in extraSmall, regular, accessibilityExtraExtraExtraLarge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们的设计在所有这三个方面都很有效，那么我们很高兴。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;提示: 如果我们的预览已缩放，则应滚动或缩小到其他预览。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>12.4_如何创建自定义修改器</title>
      <link>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E5%99%A8/</link>
      <pubDate>Wed, 07 Aug 2019 17:26:02 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E5%99%A8/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;如果您发现自己不断地将同一组修改器附加到一个视图上（例如，给它一个背景色、一些填充、一个特定的字体等等），那么您可以通过创建一个封装所有这些更改的自定义视图修改器来避免重复。所以，与其说“让它变红，使用大字体”等等，你可以说“让它看起来像一个警告”，然后应用一组预先制作的修改器。&lt;/p&gt;

&lt;p&gt;如果要创建自己的结构，请定义符合 &lt;code&gt;ViewModifier&lt;/code&gt; 协议的结构。 此协议要求您接受 &lt;code&gt;body（content:)&lt;/code&gt; 方法，该方法可以根据需要转换某种内容，并返回结果。&lt;/p&gt;

&lt;h3 id=&#34;2-实践&#34;&gt;2. 实践&lt;/h3&gt;

&lt;p&gt;例如，我们将创建一个新的 &lt;code&gt;PrimaryLabel&lt;/code&gt; 修改器，用于添加填充，红色背景，白色文本和大字体:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct PrimaryLabel: ViewModifier {
    
    func body(content: Content) -&amp;gt; some View {
        content
            .padding()
            .background(Color.red)
            .foregroundColor(.white)
            .font(.largeTitle)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要在我们的一个视图中使用它，请添加 &lt;code&gt;.modifier（PrimaryLabel())&lt;/code&gt;修饰符，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .modifier(PrimaryLabel())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/12.4_custom_view_modifier.png&#34; alt=&#34;12.4_custom_view_modifier&#34; title=&#34;Custom view modifier&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>12.3_如何将视图存储为属性</title>
      <link>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.3_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E4%B8%BA%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Wed, 07 Aug 2019 17:14:38 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.3_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E4%B8%BA%E5%B1%9E%E6%80%A7/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果我们有多个嵌套在另一个视图中的视图，我们可能会发现为其中一些或全部视图创建属性非常有用，以使我们的布局代码更容易。 然后，我们可以在视图代码中内联引用这些属性，从而帮助保持代码的清晰。&lt;/p&gt;

&lt;p&gt;例如，下面代码会创建两个文本视图作为属性，然后将它们放在VStack中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    let title = Text(&amp;quot;M X&amp;quot;)
        .font(.largeTitle)
    let subtitle = Text(&amp;quot;Admin&amp;quot;)
        .foregroundColor(.secondary)
    
    var body: some View {
        VStack {
            title
            subtitle
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/12.3_store_views_as_properties.png&#34; alt=&#34;12.3_store_views_as_properties&#34; title=&#34;Store two text views as properties&#34; /&gt;
如您所见，我们只需在堆栈中写入属性名称就足以放置它们。&lt;/p&gt;

&lt;p&gt;但是，更好的是我们可以将修改器附加到这些属性名称，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    let title = Text(&amp;quot;M X&amp;quot;)
        .font(.largeTitle)
    let subtitle = Text(&amp;quot;Admin&amp;quot;)
        .foregroundColor(.secondary)
    
    var body: some View {
        VStack {
            title
                .foregroundColor(.red)
            subtitle
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/12.3_add_modifier_for_view_property.png&#34; alt=&#34;12.3_add_modifier_for_view_property&#34; title=&#34;Add a modifier for the view peoperty&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这不会改变标题的基本风格，只会改变它的一个特定用法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>12.2_如何将文本视图组合在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.2_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Wed, 07 Aug 2019 16:46:10 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.2_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的文本视图会重载 &lt;code&gt;+&lt;/code&gt; 运算符，以便我们可以将它们组合在一起以创建新的文本视图。&lt;/p&gt;

&lt;p&gt;当我们需要在视图中使用不同的格式时，这很有用，因为我们可以使每个文本视图看起来完全符合我们的要求，然后将它们连接在一起以创建单个组合文本视图。 更好的是，&lt;code&gt;VoiceOver&lt;/code&gt; 在阅读它们时会自动将它们识别为单个文本。&lt;/p&gt;

&lt;h3 id=&#34;2-组合3个文本视图-不同字体&#34;&gt;2. 组合3个文本视图 - 不同字体&lt;/h3&gt;

&lt;p&gt;例如，下面代码会创建三个文本视图，然后使用 &lt;code&gt;+&lt;/code&gt; 将它们连接到要返回的单个文本视图中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;SwiftUI&amp;quot;)
            .font(.largeTitle)
        + Text(&amp;quot;is &amp;quot;)
            .font(.headline)
        + Text(&amp;quot;awesome&amp;quot;)
            .font(.footnote)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/12.2_combine_three_text_views.png&#34; alt=&#34;12.2_combine_three_text_views&#34; title=&#34;Combine three text views&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-组合3个文本视图-不同文本颜色&#34;&gt;3. 组合3个文本视图 - 不同文本颜色&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;SwiftUI &amp;quot;)
            .foregroundColor(.red)
        + Text(&amp;quot;is &amp;quot;)
            .foregroundColor(.orange)
        + Text(&amp;quot;awesome&amp;quot;)
            .foregroundColor(.blue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/12.2_combine_three_text_views_different_foregroundcolor.png&#34; alt=&#34;12.2_combine_three_text_views_different_foregroundcolor&#34; title=&#34;Combine three text views with different foreground colors&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 像这样组合文本视图与我们在 SwiftUI 中组合字符串一样接近。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>12.1_如何创建和撰写自定义视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E6%92%B0%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Wed, 07 Aug 2019 15:44:51 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/12-composing_views/12.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E6%92%B0%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的核心原则之一是组合，这意味着它是为我们设计的，可以创建许多小视图，然后将它们组合在一起以创建更大的视图。 这使得我们能够大规模地重用视图，这意味着我们的工作量减少了。 更好的是，组合小的子视图几乎没有运行时开销，因此我们可以自由地使用它们。&lt;/p&gt;

&lt;h3 id=&#34;2-实践&#34;&gt;2. 实践&lt;/h3&gt;

&lt;p&gt;关键是要从小做起，逐步提升。&lt;/p&gt;

&lt;h4 id=&#34;第1步-定义-user-模型&#34;&gt;第1步: 定义 &lt;code&gt;User&lt;/code&gt; 模型&lt;/h4&gt;

&lt;p&gt;例如，许多应用程序必须与看起来像这样的用户一起工作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User {
    var name: String
    var jobTitle: String
    var emailAddress: String
    var profilePicture: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第2步-定义-profilepicture-视图&#34;&gt;第2步: 定义 &lt;code&gt;ProfilePicture&lt;/code&gt; 视图&lt;/h4&gt;

&lt;p&gt;如果我们希望在应用程序中为用户配置文件图片提供一致的设计，可以创建一个具有圆形的100x100图像视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ProfilePicture: View {
    var imageName: String

    var body: some View {
        Image(imageName)
            .resizable()
            .frame(width: 100, height: 100)
            .clipShape(Circle())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第3步-定义-emailaddress-视图&#34;&gt;第3步: 定义 &lt;code&gt;EmailAddress&lt;/code&gt; 视图&lt;/h4&gt;

&lt;p&gt;我们的设计师可能会告诉我们，只要看到电子邮件地址，我们就应该在其旁边显示一个小信封图标作为视觉提示，这样我们就可以创建一个 &lt;code&gt;EmailAddress&lt;/code&gt; 视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct EmailAdress: View {
    var address: String
    
    var body: some View {
        HStack {
            Image(systemName: &amp;quot;envelope&amp;quot;)
            Text(address)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第4步-定义-userdetail-视图&#34;&gt;第4步: 定义 &lt;code&gt;UserDetail&lt;/code&gt; 视图&lt;/h4&gt;

&lt;p&gt;在显示用户的详细信息时，我们可以创建一个视图，该视图的名称和职务格式整齐，并使用我们的&lt;code&gt;EmailAddress&lt;/code&gt; 视图通过其电子邮件地址进行备份，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct UserDetail: View {
    var user: User

    var body: some View {
        VStack(alignment: .leading) {
            Text(user.name)
                .font(.largeTitle)
                .foregroundColor(Color.red)
            Text(user.jobTitle)
                .foregroundColor(Color.gray)
            EmailAdress(address: user.emailAddress)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第5步-定义-userview-视图&#34;&gt;第5步: 定义 &lt;code&gt;UserView&lt;/code&gt; 视图&lt;/h4&gt;

&lt;p&gt;我们甚至可以创建一个更大的视图，将 &lt;code&gt;ProfilePicture&lt;/code&gt; 放在 &lt;code&gt;UserDetail&lt;/code&gt; 旁边，以便为用户提供单一的可视化表示，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct UserView: View {
    var user: User
    
    var body: some View {
        VStack {
            ProfilePicture(imageName: user.profilePicture)
            UserDetail(user: user)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第6步-组合&#34;&gt;第6步: 组合&lt;/h4&gt;

&lt;p&gt;有了这种结构，我们现在有几种方式向用户展示：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只是他们的照片&lt;/li&gt;
&lt;li&gt;只是他们的电邮地址&lt;/li&gt;
&lt;li&gt;只是他们的工作细节&lt;/li&gt;
&lt;li&gt;在同一时间展示所有信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更重要的是，这意味着当涉及到使用所有这些工作时，我们的主要内容视图不必担心用户的外观或应如何对待它们 - 所有这些工作都融入到我们较小的视图中。&lt;/p&gt;

&lt;p&gt;这意味着我们可以使用示例用户创建一个 &lt;code&gt;UserView&lt;/code&gt; 并使其正常工作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    let user = User(name: &amp;quot;M X&amp;quot;, jobTitle: &amp;quot;Admin, M X WEBSITE&amp;quot;, emailAddress: &amp;quot;test@gmail.com&amp;quot;, profilePicture: &amp;quot;avatar&amp;quot;)
    var body: some View {
        UserView(user: user)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/12.1_composing_views.png&#34; alt=&#34;12.1_composing_views&#34; title=&#34;Composing views&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11.7_如何创建非对称转换</title>
      <link>https://coderxdlee.github.io/post/swiftui/11-animation/11.7_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Wed, 07 Aug 2019 15:14:58 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/11-animation/11.7_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 允许我们在添加视图时指定一个转换，在删除视图时指定另一个转换，所有转换都使用  &lt;code&gt;asymmetric()&lt;/code&gt; 转换类型完成。&lt;/p&gt;

&lt;p&gt;例如，我们可以创建一个使用非对称过渡的文本视图，以便在添加时从前缘移入，并在移除时向下移动到底边，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Details go here.&amp;quot;).transition(.asymmetric(insertion: .move(edge: .leading), removal: .move(edge: .bottom)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>11.6_如何组合transactions</title>
      <link>https://coderxdlee.github.io/post/swiftui/11-animation/11.6_%E5%A6%82%E4%BD%95%E7%BB%84%E5%90%88transactions/</link>
      <pubDate>Wed, 07 Aug 2019 09:43:38 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/11-animation/11.6_%E5%A6%82%E4%BD%95%E7%BB%84%E5%90%88transactions/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;添加或删除视图时，SwiftUI 允许我们使用 &lt;code&gt;combined(with:)&lt;/code&gt; 方法组合 &lt;strong&gt;转换&lt;/strong&gt; 以创建新的动画样式。&lt;/p&gt;

&lt;p&gt;例如，我们可以同时将视图移动（一次转换）和淡入淡出（第二次转换），如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Details go here...&amp;quot;)
    .transition(AnyTransition.opacity.combined(with: .slide))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了使组合转换更易于使用和重用，我们可以在 &lt;code&gt;AnyTransition&lt;/code&gt; 上将它们创建为扩展，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension AnyTransition {
    static var moveAndScale: AnyTransition {
        AnyTransition.move(edge: .bottom).combined(with: .scale)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个，我们现在可以使用以下内容添加或删除文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Details go here...&amp;quot;)
    .transition(.moveAndScale)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>11.5_如何添加和删除带有转换的视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/11-animation/11.5_%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%A6%E6%9C%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 18:11:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/11-animation/11.5_%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%B8%A6%E6%9C%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;p&gt;我们可以使用常规的 Swift 条件在设计中包含或排除某个视图。&lt;/p&gt;

&lt;h3 id=&#34;1-默认动画-fade&#34;&gt;1. 默认动画 - fade&lt;/h3&gt;

&lt;p&gt;例如，当点击按钮时，这会添加或删除一些详细信息文本:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var showDetails = false

    var body: some View {
        VStack {
            Button(action: {
                withAnimation {
                    self.showDetails.toggle()
                }
            }, label: {
                Text(&amp;quot;Tap to show details&amp;quot;)
            })

            if showDetails {
                Text(&amp;quot;Details go here.&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.5_show_details_by_click_button.gif&#34; alt=&#34;11.5_show_details_by_click_button&#34; title=&#34;Show details&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-使用-transition-控制视图从底部滑入&#34;&gt;2. 使用 transition 控制视图从底部滑入&lt;/h3&gt;

&lt;p&gt;默认情况下，SwiftUI 使用 &lt;code&gt;fade淡入淡出动画&lt;/code&gt; 来插入或删除视图，但如果需要，可以通过将&lt;code&gt;transition()&lt;/code&gt; 修改器附加到视图来更改它。
例如，我们可以将详细信息文本视图从底部滑入或滑出，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var showDetails = false

    var body: some View {
        VStack {
            Button(action: {
                withAnimation {
                    self.showDetails.toggle()
                }
            }, label: {
                Text(&amp;quot;Tap to show details&amp;quot;)
            })

            if showDetails {
                Text(&amp;quot;Details go here.&amp;quot;)
                    .transition(.move(edge: .bottom))
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.5_show_details_from_bottom.gif&#34; alt=&#34;11.5_show_details_from_bottom&#34; title=&#34;Show details from bottom&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-使用-transaction-slide&#34;&gt;3. 使用 transaction(.slide)&lt;/h3&gt;

&lt;p&gt;还有 &lt;code&gt;.slide&lt;/code&gt; 过渡，它导致视图从其前导中动画化并在其后缘上动画化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var showDetails = false

    var body: some View {
        VStack {
            Button(action: {
                withAnimation {
                    self.showDetails.toggle()
                }
            }, label: {
                Text(&amp;quot;Tap to show details&amp;quot;)
            })

            if showDetails {
                Text(&amp;quot;Details go here.&amp;quot;)
                    .transition(.slide)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.5_show_details_transaction_slide.gif&#34; alt=&#34;11.5_show_details_transaction_slide&#34; title=&#34;Show details with transaction.slide&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-设置-transition-scale&#34;&gt;4. 设置 transition(.scale)&lt;/h3&gt;

&lt;p&gt;以及 &lt;code&gt;.scale&lt;/code&gt; 转换，它使视图在进入时从零缩放到全尺寸，然后在退出时返回到零：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var showDetails = false

    var body: some View {
        VStack {
            Button(action: {
                withAnimation {
                    self.showDetails.toggle()
                }
            }, label: {
                Text(&amp;quot;Tap to show details&amp;quot;)
            })

            if showDetails {
                Text(&amp;quot;Details go here.&amp;quot;)
                    .transition(.scale)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.5_show_details_transaction_scale.gif&#34; alt=&#34;11.5_show_details_transaction_scale&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11.4_如何创建显式动画</title>
      <link>https://coderxdlee.github.io/post/swiftui/11-animation/11.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%98%BE%E5%BC%8F%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Tue, 06 Aug 2019 17:36:12 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/11-animation/11.4_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%98%BE%E5%BC%8F%E5%8A%A8%E7%94%BB/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;如果将动画修改器附加到一个视图上，最终会得到 &lt;code&gt;隐式动画&lt;/code&gt; - 即使我们只是递增整数或切换布尔值，更改视图中其他位置的某些状态也可能会使用动画。&lt;/p&gt;

&lt;p&gt;另一种方法是使用显式动画，在这种情况下，您不会将修改器附加到相关视图，而是要求SwiftUI为您要进行的精确更改设置动画。 为此，请在对 &lt;code&gt;withAnimation()&lt;/code&gt; 的调用中包装更改。&lt;/p&gt;

&lt;h3 id=&#34;2-简单显式动画&#34;&gt;2. 简单显式动画&lt;/h3&gt;

&lt;p&gt;例如，下面代码使用显式动画使每次点击时按钮逐渐消失:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var opacity: Double = 1

    var body: some View {
        Button(action: {
            withAnimation {
                self.opacity -= 0.2
            }
        }, label: {
            Text(&amp;quot;Tap here!&amp;quot;)
                .padding()
                .opacity(opacity)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.4_explicit_animation_opacity.gif&#34; alt=&#34;11.4_explicit_animation_opacity&#34; title=&#34;Set a explicit animation for opacity&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-设置显式动画类型&#34;&gt;3. 设置显式动画类型&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;withAnimation()&lt;/code&gt; 接收一个指定所需动画类型的参数，因此我们可以创建一个三秒钟的线性动画，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var opacity: Double = 1

    var body: some View {
        Button(action: {
            withAnimation(.linear(duration: 3), {
                self.opacity -= 0.2
            })
        }, label: {
            Text(&amp;quot;Tap here!&amp;quot;)
                .padding()
                .opacity(opacity)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
![11.4_explicit_animation_linear_opacity](img/11.4_explicit_animation_linear_opacity.gif &amp;ldquo;Set a explicit linear animation for opacity&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;4-总结&#34;&gt;4. 总结&lt;/h3&gt;

&lt;p&gt;显式动画通常很有用，因为它们会使每个受影响的视图都出现动画，而不仅仅是那些附加了隐式动画的视图。 例如，如果视图A必须为视图B腾出空间作为动画的一部分，但只有视图B附加了动画，那么除非使用显式动画，否则视图A将跳转到其新位置而不进行动画处理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11.3_如何设置绑定值更改的动画</title>
      <link>https://coderxdlee.github.io/post/swiftui/11-animation/11.3_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%80%BC%E6%9B%B4%E6%94%B9%E7%9A%84%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Tue, 06 Aug 2019 17:16:47 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/11-animation/11.3_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BB%91%E5%AE%9A%E5%80%BC%E6%9B%B4%E6%94%B9%E7%9A%84%E5%8A%A8%E7%94%BB/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的双向绑定让我们可以调整程序的状态，我们可以通过调整视图层次结构来响应它。 例如，我们可能会使某些文本显示或消失，或调整视图的不透明度。&lt;/p&gt;

&lt;p&gt;我们可以通过向绑定添加 &lt;code&gt;animation()&lt;/code&gt; 来对绑定进行修改而引起的更改进行动画处理，而不是立即进行状态更改。例如，此视图有一个切换按钮，根据切换的阶段显示或隐藏文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showingWelcome = false
    
    var body: some View {
        VStack {
            Toggle(isOn: $showingWelcome, label: {
                Text(&amp;quot;Toggle label&amp;quot;)
            })
            
            if showingWelcome {
                Text(&amp;quot;Hellow SwiftUI&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.3_binding_without_animation.gif&#34; alt=&#34;11.3_binding_without_animation&#34; title=&#34;Binding without animation&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果没有动画，文本视图将立即显示或消失，从而导致视觉跳跃。 如果我们修改了 toggle
，那么它被绑定到 &lt;code&gt;$showingWelcome.animation()&lt;/code&gt; ，那么文本视图将平滑滑入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showingWelcome = false
    
    var body: some View {
        VStack {
            Toggle(isOn: $showingWelcome.animation(), label: {
                Text(&amp;quot;Toggle label&amp;quot;)
            })
            
            if showingWelcome {
                Text(&amp;quot;Hellow SwiftUI&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.3_binding_with_animation.gif&#34; alt=&#34;11.3_binding_with_animation&#34; title=&#34;Binding with animation&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果希望对动画有更多的控制，可以将参数传递给影响转换方式的 &lt;code&gt;animation()&lt;/code&gt;。例如，下面代码将使文本与弹簧动画一起出现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.3_binding_with_spring_animation.gif&#34; alt=&#34;11.3_binding_with_spring_animation&#34; title=&#34;Binding with a spring animation&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11.2_如何创建弹性动画</title>
      <link>https://coderxdlee.github.io/post/swiftui/11-animation/11.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%BC%B9%E6%80%A7%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Tue, 06 Aug 2019 16:58:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/11-animation/11.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%BC%B9%E6%80%A7%E5%8A%A8%E7%94%BB/</guid>
      <description>

&lt;p&gt;SwiftUI 内置了对弹性动画的支持，这些动画可以移动到目标点，越过一点，然后反弹。&lt;/p&gt;

&lt;h3 id=&#34;1-简单演示&#34;&gt;1. 简单演示&lt;/h3&gt;

&lt;p&gt;如果只单独使用 &lt;code&gt;.spring()&lt;/code&gt;，而没有参数，则会得到一个合理的默认值。因此，下面代码将创建一个弹性动画，每次点击按钮时，它将旋转45度:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var angle: Double = 0

    var body: some View {
        Button(action: {
            self.angle += 45
        }, label: {
            Text(&amp;quot;Tap here!&amp;quot;)
                .padding()
                .rotationEffect(.degrees(angle))
                .animation(.spring())
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.2_spring_animation_rotate_button.gif&#34; alt=&#34;11.2_spring_animation_rotate_button&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-细粒度控制弹性动画&#34;&gt;2. 细粒度控制弹性动画&lt;/h3&gt;

&lt;p&gt;如果我们想要对弹性动画进行细粒度的控制，可以发送任何我们感兴趣的参数: 对象的质量、弹簧的刚度、弹性减慢的速度以及它在启动时开始移动的速度。&lt;/p&gt;

&lt;p&gt;例如，下面代码会创建一个弹性阻尼非常低的按钮，这意味着它会在达到目标角度之前长时间反弹:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var angle: Double = 0

    var body: some View {
        Button(action: {
            self.angle += 45
        }, label: {
            Text(&amp;quot;Tap here!&amp;quot;)
                .padding()
                .rotationEffect(.degrees(angle))
                .animation(.interpolatingSpring(mass: 1, stiffness: 1, damping: 0.1, initialVelocity: 10))
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.2_interpolatingspring_animation_rotate_button.gif&#34; alt=&#34;11.2_interpolatingspring_animation_rotate_button&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11.1_如何创建基本动画</title>
      <link>https://coderxdlee.github.io/post/swiftui/11-animation/11.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Tue, 06 Aug 2019 16:16:55 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/11-animation/11.1_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E5%8A%A8%E7%94%BB/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI 通过其 &lt;code&gt;animation()&lt;/code&gt; 修改器内置了对动画的支持。 要使用此修改器，请将其放在视图的任何其它修改器之后，并告诉它我们想要什么样的动画。&lt;/p&gt;

&lt;h3 id=&#34;2-缩放动画&#34;&gt;2. 缩放动画&lt;/h3&gt;

&lt;p&gt;例如，下面代码创建一个按钮，每次按下它时，其缩放效果会增加1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var scale: CGFloat = 1
    
    var body: some View {
        Button(action: {
            self.scale += 1
        }, label: {
            Text(&amp;quot;Tap here!&amp;quot;)
            .scaleEffect(scale)
                .animation(.default)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.1_animation_default_scale_button.gif&#34; alt=&#34;11.1_animation_default_scale_button&#34; title=&#34;Scale a button using the default animation&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-设置动画持续时间&#34;&gt;2. 设置动画持续时间&lt;/h3&gt;

&lt;p&gt;如果需要，我们可以为动画指定精确的持续时间。 例如，下面代码会在三秒钟内激活缩放效果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var scale: CGFloat = 1
    
    var body: some View {
        Button(action: {
            self.scale += 1
        }, label: {
            Text(&amp;quot;Tap here!&amp;quot;)
            .scaleEffect(scale)
                .animation(.linear(duration: 3))
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.1_animation_linear_scale_button_3s.gif&#34; alt=&#34;11.1_animation_linear_scale_button_3s&#34; title=&#34;Set a linear animation with 3s duration&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-曲线动画&#34;&gt;3. 曲线动画&lt;/h3&gt;

&lt;p&gt;我们也可以指定曲线动画，在 &lt;code&gt;.easeIn&lt;/code&gt;, &lt;code&gt;.easeOut&lt;/code&gt;, &lt;code&gt;.easeInOut&lt;/code&gt;, and &lt;code&gt;.custom&lt;/code&gt; 之间进行选择，后者允许我们指定自己的控制点。&lt;/p&gt;

&lt;p&gt;例如，下面代码会激活缩放效果，使其开始慢并逐渐变快:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var scale: CGFloat = 1
    
    var body: some View {
        Button(action: {
            self.scale += 1
        }, label: {
            Text(&amp;quot;Tap here!&amp;quot;)
            .scaleEffect(scale)
                .animation(.easeIn)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.1_animation_easein_scale_button.gif&#34; alt=&#34;11.1_animation_easein_scale_button&#34; title=&#34;Set a easeIn animation&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-设置多个动画变量&#34;&gt;4. 设置多个动画变量&lt;/h3&gt;

&lt;p&gt;我们可以为许多其他修改器设置动画，例如2D和3D旋转，不透明度，边框等。 例如，下面代码会使按钮旋转并在每次点击时增加其边框:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var angle: Double = 0
    @State private var borderThickness: CGFloat = 1

    var body: some View {
        Button(action: {
            self.angle += 45
            self.borderThickness += 1
        }, label: {
            Text(&amp;quot;Tap here&amp;quot;)
                .padding()
                .border(Color.red, width: borderThickness)
                .rotationEffect(.degrees(angle))
                .animation(.default)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/11.1_animation_default_multi_var.gif&#34; alt=&#34;11.1_animation_default_multi_var&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.17_如何通过着色和去饱和度等调整视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.17_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%9D%80%E8%89%B2%E5%92%8C%E5%8E%BB%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%AD%89%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 15:59:46 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.17_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%9D%80%E8%89%B2%E5%92%8C%E5%8E%BB%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%AD%89%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 允许我们通过使用各种修改器来调整视图的亮度、色调、色调、饱和度等等来精细地控制视图的外观。&lt;/p&gt;

&lt;h3 id=&#34;1-给图像视图着色&#34;&gt;1. 给图像视图着色&lt;/h3&gt;

&lt;p&gt;例如，下面代码会创建一个图像视图并将整个事物着色为红色:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Image(&amp;quot;avatar&amp;quot;)
            .resizable()
            .frame(width: 300, height: 300)
            .colorMultiply(.red)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.17_colormultiply_red.png&#34; alt=&#34;10.17_colormultiply_red&#34; title=&#34;Set colorMultiply to red&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-调整视图饱和度&#34;&gt;2. 调整视图饱和度&lt;/h3&gt;

&lt;p&gt;我们可以将视图的饱和度调整为任意数量，其中0.0为完全灰色，1.0为其原始颜色:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Image(&amp;quot;avatar&amp;quot;)
        .resizable()
        .frame(width: 300, height: 300)
            .saturation(0.5)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.17_saturation_0.5.png&#34; alt=&#34;10.17_saturation_0.5&#34; title=&#34;Set saturation to 0.5&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-动态调整视图对比度&#34;&gt;3. 动态调整视图对比度&lt;/h3&gt;

&lt;p&gt;甚至可以使用 &lt;code&gt;contrast()&lt;/code&gt; 修改器动态调整视图的对比度。如果值为0.0，则不会产生对比度（浅灰色图像），1.0将提供原始图像，高于1.0的所有内容都会添加对比度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Image(&amp;quot;avatar&amp;quot;)
        .resizable()
        .frame(width: 300, height: 300)
            .contrast(0.5)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.17_contract_0.5.png&#34; alt=&#34;10.17_contract_0.5&#34; title=&#34;Set contrast to 0.5&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.16_如何将视图混合在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.16_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%B7%B7%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Tue, 06 Aug 2019 15:49:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.16_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%B7%B7%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;将一个视图放在另一个视图上时，可以使用 &lt;code&gt;blendMode()&lt;/code&gt; 修改器控制它们重叠的方式。 这包含多种可以将颜色混合在一起的方法，例如使用它们的差异或使用颜色刻录 - 如果您之前使用过 Core Graphics 或类似 Photoshop，这些方法会很熟悉。&lt;/p&gt;

&lt;p&gt;为了证明这一点，我们可以创建一个内部有两个图像的 &lt;code&gt;ZStack&lt;/code&gt; ，其中第二个具有 &lt;code&gt;.multiply&lt;/code&gt; 混合模式，以便使其后面的颜色变暗:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        ZStack {
            Image(&amp;quot;stripes&amp;quot;)
            Image(&amp;quot;example-image&amp;quot;)
                .blendMode(.multiply)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.16_blend.png&#34; alt=&#34;10.16_blend&#34; title=&#34;Blend two image view with multiply mode&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.15_如何模糊视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.15_%E5%A6%82%E4%BD%95%E6%A8%A1%E7%B3%8A%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 15:37:49 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.15_%E5%A6%82%E4%BD%95%E6%A8%A1%E7%B3%8A%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;blur()&lt;/code&gt; 修改器允许我们根据自己的选择对视图应用实时高斯模糊。&lt;/p&gt;

&lt;h3 id=&#34;2-给图像设置模糊&#34;&gt;2. 给图像设置模糊&lt;/h3&gt;

&lt;p&gt;例如: 下面代码会创建一个 &lt;code&gt;300x300&lt;/code&gt; 的个人资料图片，然后添加一个20点的高斯模糊:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Image(&amp;quot;avatar&amp;quot;)
            .resizable()
            .frame(width: 300, height: 300)
            .blur(radius: 20)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.15_blur_20_radius.png&#34; alt=&#34;10.15_blur_20_radius&#34; title=&#34;Set a blur for a image view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-给文本设置模糊&#34;&gt;3. 给文本设置模糊&lt;/h3&gt;

&lt;p&gt;我们可以模糊我们想要的任何内容，包括文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Welcome to my SwiftUI app&amp;quot;)
            .blur(radius: 2)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.15_set_blur_for_text.png&#34; alt=&#34;10.15_set_blur_for_text&#34; title=&#34;Set a blur for a text view&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.14_如何用另一个视图遮罩一个视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.14_%E5%A6%82%E4%BD%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E9%81%AE%E7%BD%A9%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 15:16:56 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.14_%E5%A6%82%E4%BD%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E9%81%AE%E7%BD%A9%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 为我们提供了 &lt;code&gt;mask()&lt;/code&gt; 修改器，用于将一个图像作为另一个视图的蒙版，这意味着我们可以使用文本来作为图像的蒙版，或使用图像作为图像的蒙版，或更多。&lt;/p&gt;

&lt;p&gt;例如，下面代码会创建一个 &lt;code&gt;300x300&lt;/code&gt; 的条纹图像，然后使用文本 &amp;ldquo;SWIFT!&amp;rdquo; 对其进行遮罩，以便字母充当图像的剪切区域:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Image(&amp;quot;stripes&amp;quot;)
            .resizable()
            .frame(width: 300, height: 300)
            .mask(
                Text(&amp;quot;SWIFT!&amp;quot;)
                    .font(Font.system(size: 72, weight: .black, design: .serif))
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.14_mask_image_with_text.png&#34; alt=&#34;10.14_mask_image_with_text&#34; title=&#34;Mask a image view with a text view&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.13_如何调整视图的强调色</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.13_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%B0%83%E8%89%B2/</link>
      <pubDate>Tue, 06 Aug 2019 14:35:43 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.13_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%B0%83%E8%89%B2/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;iOS 使用 &lt;code&gt;tints colors&lt;/code&gt; 为应用程序提供协调的主题，SwiftUI 中的 &lt;code&gt;accent colors&lt;/code&gt; 也提供了相同的功能。就像在 UIKit 中一样，当您设置一个视图的 &lt;code&gt;accent color&lt;/code&gt; 时，它会影响其中的所有内容，因此如果您设置顶级控件的 &lt;code&gt;accent color&lt;/code&gt;，那么一切都会变色。&lt;/p&gt;

&lt;p&gt;例如，下面代码会在 &lt;code&gt;VStack&lt;/code&gt; 中创建一个按钮，然后给它一个橙色的强调颜色:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Button(action: {}, label: {
                Text(&amp;quot;Tap here&amp;quot;)
            })
        }
        .accentColor(Color.orange)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.13_accent_color.png&#34; alt=&#34;10.13_accent_color&#34; title=&#34;Set accent color&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.12_如何调整视图的不透明度</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.12_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6/</link>
      <pubDate>Tue, 06 Aug 2019 14:19:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.12_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过 &lt;code&gt;opacity()&lt;/code&gt; 修改器，我们可以将任何 SwiftUI 视图设置成部分或全部透明。它接收 &lt;em&gt;0(完全不可见)&lt;/em&gt; 到 &lt;em&gt;1(完全不透明)&lt;/em&gt; 之间的值。就像 UIKit 中 &lt;code&gt;UIView&lt;/code&gt; 的 &lt;code&gt;alpha&lt;/code&gt; 属性一样。&lt;/p&gt;

&lt;p&gt;例如: 下面代码创建一个带有红色背景的文本视图，然后给它30％的不透明度:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Now you see me&amp;quot;)
            .padding()
            .background(Color.red)
            .opacity(0.3)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.12_opacity.png&#34; alt=&#34;10.12_opacity&#34; title=&#34;Set opacity is 0.3&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.11_如何给视图设置圆角</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</link>
      <pubDate>Tue, 06 Aug 2019 14:06:51 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.11_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过 &lt;code&gt;cornerRadius()&lt;/code&gt; 修改器，我们可以给任何 SwiftUI 视图设置圆角。这需要一个简单地值来限定如何明确地成圆。&lt;/p&gt;

&lt;p&gt;因此，我们可以创建一个25点圆角的文本视图，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Round me&amp;quot;)
            .padding()
            .background(Color.red)
            .cornerRadius(20)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.11_round_the_corner_25.png&#34; alt=&#34;10.11_round_the_corner_25&#34; title=&#34;Round the corner&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.10_如何向上或向下缩放视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.10_%E5%A6%82%E4%BD%95%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%E7%BC%A9%E6%94%BE%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 13:13:23 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.10_%E5%A6%82%E4%BD%95%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%E7%BC%A9%E6%94%BE%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI的 &lt;code&gt;scaleEffect()&lt;/code&gt; 修改器允许我们自由地增大或减小视图的大小。&lt;/p&gt;

&lt;h3 id=&#34;2-放大视图&#34;&gt;2. 放大视图&lt;/h3&gt;

&lt;p&gt;例如，我们可以将文本视图设置为常规大小的五倍，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .scaleEffect(5)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.10_scale_up_5.png&#34; alt=&#34;10.10_scale_up_5&#34; title=&#34;Make a text view five times its regular size&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-独立缩放xy&#34;&gt;3. 独立缩放XY&lt;/h3&gt;

&lt;p&gt;如果需要，可以独立缩放X和Y尺寸，从而可以挤压以下视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .scaleEffect(x: 1, y: 5)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.10_scale_x_y.png&#34; alt=&#34;10.10_scale_x_y&#34; title=&#34;Scale the X and Y dimensions independently&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-设置锚点&#34;&gt;4. 设置锚点&lt;/h3&gt;

&lt;p&gt;如果您想要更多控制，可以为此缩放指定锚点，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .scaleEffect(2, anchor: UnitPoint(x: 1, y: 1))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.10_scale_with_anchor.png&#34; alt=&#34;10.10_scale_with_anchor&#34; title=&#34;Specify an anchor&#34; /&gt;
这使得文本视图两倍于常规大小，从右下角缩放。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.9_如何在3D中旋转视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.9_%E5%A6%82%E4%BD%95%E5%9C%A83d%E4%B8%AD%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 12:38:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.9_%E5%A6%82%E4%BD%95%E5%9C%A83d%E4%B8%AD%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;rotation3DEffect()&lt;/code&gt; 修改器让我们可以在三维空间中旋转视图，几乎不需要任何代码就可以创建漂亮的效果。&lt;/p&gt;

&lt;p&gt;这个修改器接受两个参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;旋转的角度（以度或弧度为单位）。&lt;/li&gt;
&lt;li&gt;加上包含X，Y和Z轴的元组，围绕该轴执行旋转。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;: 如果你以前从未进行过三维旋转，那么你应该将X/Y/Z轴视为视图中的扦子。X轴是水平的，所以如果你在X轴上旋转，就像是在你的视图中放置一个水平的扦子 — 任何旋转都会使顶部或底部更近或更远，但不会调整前缘和后缘。&lt;/p&gt;

&lt;h3 id=&#34;2-围绕x轴旋转视图&#34;&gt;2. 围绕X轴旋转视图&lt;/h3&gt;

&lt;p&gt;因此，如果要围绕X轴将某些文本旋转45度（这将导致文本顶部比底部看得更远），可以编写以下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .foregroundColor(.yellow)
            .rotation3DEffect(.degrees(-45), axis: (x: 1, y: 0, z: 0))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.9_rotate_in_3D_x_axis.png&#34; alt=&#34;10.9_rotate_in_3D_x_axis&#34; title=&#34;Rotate a text by x axis in 3D&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.8_如何旋转视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.8_%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 06 Aug 2019 11:16:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.8_%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI的 &lt;code&gt;rotationEffect()&lt;/code&gt; 修改器让我们可以使用度数或弧度自由旋转视图。&lt;/p&gt;

&lt;h3 id=&#34;2-使用角度旋转视图&#34;&gt;2. 使用角度旋转视图&lt;/h3&gt;

&lt;p&gt;例如，如果我们想将某些文本旋转-90度以使其向上读取，我们可以使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .rotationEffect(.degrees(-90))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_90_degree.png&#34; alt=&#34;10.8_rotate_90_degree&#34; title=&#34;Rotate a text by -90 degrees so that it reads upwards&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-使用弧度旋转视图&#34;&gt;3. 使用弧度旋转视图&lt;/h3&gt;

&lt;p&gt;如果我们更喜欢使用弧度，只需传入 &lt;code&gt;.radians()&lt;/code&gt; 作为参数，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Up we go&amp;quot;)
            .rotationEffect(.radians(.pi))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_pi.png&#34; alt=&#34;10.8_rotate_pi&#34; title=&#34;Using radians&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-使用滑块交互&#34;&gt;4. 使用滑块交互&lt;/h3&gt;

&lt;p&gt;视图旋转速度如此之快，以至于实际上是自由的，所以如果需要，甚至可以使用滑块进行交互:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var rotation: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $rotation, in: 0...360, step: 1) { _ in
                print(self.rotation)
            }
            Text(&amp;quot;Up we go&amp;quot;)
                .rotationEffect(.degrees(rotation))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_by_slider.gif&#34; alt=&#34;10.8_rotate_by_slider&#34; title=&#34;Rotate a view by a slider&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-设置旋转锚点&#34;&gt;5. 设置旋转锚点&lt;/h3&gt;

&lt;p&gt;默认情况下，视图围绕其中心旋转，但如果要从特定点固定旋转，则可以为其添加额外参数。 例如，如果你想让旋转器围绕视图的左上角旋转旋转，你可以这样写：&lt;/p&gt;

&lt;p&gt;默认情况下，视图围绕其中心旋转，但如果要从特定点固定旋转，可以为此添加一个额外参数。例如，如果要使上方的滑块围绕视图左上角旋转，可以编写以下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var rotation: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $rotation, in: 0...360, step: 1) { _ in
                print(self.rotation)
            }
            Text(&amp;quot;Up we go&amp;quot;)
                .rotationEffect(.degrees(rotation), anchor: UnitPoint(x: 0, y: 0))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.8_rotate_by_slider_with_anchor.gif&#34; alt=&#34;10.8_rotate_by_slider_with_anchor&#34; title=&#34;Rotate a text by slider with an anchor&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.7_如何剪裁视图使其只有部分可见</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.7_%E5%A6%82%E4%BD%95%E5%89%AA%E8%A3%81%E8%A7%86%E5%9B%BE%E4%BD%BF%E5%85%B6%E5%8F%AA%E6%9C%89%E9%83%A8%E5%88%86%E5%8F%AF%E8%A7%81/</link>
      <pubDate>Tue, 06 Aug 2019 11:01:10 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.7_%E5%A6%82%E4%BD%95%E5%89%AA%E8%A3%81%E8%A7%86%E5%9B%BE%E4%BD%BF%E5%85%B6%E5%8F%AA%E6%9C%89%E9%83%A8%E5%88%86%E5%8F%AF%E8%A7%81/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;通过使用 &lt;code&gt;clipShape()&lt;/code&gt; 修改器，SwiftUI允许我们剪切任何视图以控制其形状。&lt;/p&gt;

&lt;h3 id=&#34;2-创建圆形按钮&#34;&gt;2. 创建圆形按钮&lt;/h3&gt;

&lt;p&gt;例如: 下面的代码使用系统图像 &lt;code&gt;bolt.fill&lt;/code&gt; 创建一个按钮，给它一些填充和背景颜色，然后使用圆形剪裁它，以便我们得到一个圆形按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Button(action: {
            print(&amp;quot;Button tapped!&amp;quot;)
        }, label: {
            Image(systemName: &amp;quot;bolt.fill&amp;quot;)
                .foregroundColor(.white)
                .padding()
                .background(Color.green)
                .clipShape(Circle())
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.7_create_circle_button.png&#34; alt=&#34;10.7_create_circle_button&#34; title=&#34;Create a circle button&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Circle&lt;/code&gt; 剪辑形状将始终从视图中创建圆圈，即使它们的宽度和高度不相等 - 它只会裁剪较大的值以匹配较小的值。&lt;/p&gt;

&lt;h3 id=&#34;3&#34;&gt;3.&lt;/h3&gt;

&lt;p&gt;除了 &lt;code&gt;Circle&lt;/code&gt; 之外，还有 &lt;code&gt;Capsule&lt;/code&gt;，它可以看到圆形的菱形形状。 例如，下面的代码使用 &lt;code&gt;Capsule&lt;/code&gt; 形状创建相同的按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Button(action: {
            print(&amp;quot;Button tapped!&amp;quot;)
        }, label: {
            Image(systemName: &amp;quot;bolt.fill&amp;quot;)
                .foregroundColor(.white)
                .padding(EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20))
                .background(Color.green)
                .clipShape(Capsule())
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.7_create_capsule_button.png&#34; alt=&#34;10.7_create_capsule_button&#34; title=&#34;Create a capsule button&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.6_如何在视图周围绘制阴影</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.6_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1/</link>
      <pubDate>Tue, 06 Aug 2019 10:37:26 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.6_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 为我们提供了一个专用的 &lt;code&gt;shadow()&lt;/code&gt; 修改器，用于在视图周围绘制阴影。 我们可以控制阴影的颜色、半径和位置，还可以通过调整修改器顺序来控制视图的哪些部分被阴影遮盖。&lt;/p&gt;

&lt;h3 id=&#34;2-通过模糊半径绘制阴影&#34;&gt;2. 通过模糊半径绘制阴影&lt;/h3&gt;

&lt;p&gt;在其基本形式中，我们只需指定模糊的半径即可添加阴影，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .shadow(radius: 5)
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.6_shadow_through_radius.png&#34; alt=&#34;10.6_shadow_through_radius&#34; title=&#34;Add a shadow just by specifying the radius of the blur&#34; /&gt;
这段代码添加了一个非常轻微的阴影，以文本为中心的5点模糊。&lt;/p&gt;

&lt;h3 id=&#34;3-绘制红色阴影&#34;&gt;3. 绘制红色阴影&lt;/h3&gt;

&lt;p&gt;我们还可以指定所需的颜色以及原始视图的X和Y偏移。 例如，下面的代码会创建一个强烈的红色阴影，其中包含5点模糊，以文本为中心：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .shadow(color: Color.red, radius: 5)
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.6_shadow_red.png&#34; alt=&#34;10.6_shadow_red&#34; title=&#34;This creates a strong red shadow with a 5 point blur&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-为阴影设置偏移量&#34;&gt;4. 为阴影设置偏移量&lt;/h3&gt;

&lt;p&gt;如果要为阴影指定偏移，请将 &lt;code&gt;x&lt;/code&gt; 和/或 &lt;code&gt;y&lt;/code&gt; 参数添加到修改器，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .shadow(color: Color.red, radius: 5, x: 20, y: 20)
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.6_shadow_red_x20_y20.png&#34; alt=&#34;10.6_shadow_red_x20_y20&#34; title=&#34;Add x and/or y parameters to the modifier&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-为边框绘制阴影&#34;&gt;5. 为边框绘制阴影&lt;/h3&gt;

&lt;p&gt;请记住，SwiftUI 按照列出修改器的顺序来应用它们，因此如果我们希望可以将阴影应用于边框，只需将边框修改器放在阴影修改器之前:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .border(Color.red, width: 4)
            .shadow(color: Color.red, radius: 5, x: 20, y: 20)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/10.6_shadow_set_shadow_for_border.png&#34; alt=&#34;10.6_shadow_set_shadow_for_border&#34; title=&#34;Apply a shadow for the border&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.5_如何在视图周围绘制边框</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.5_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E8%BE%B9%E6%A1%86/</link>
      <pubDate>Tue, 06 Aug 2019 10:17:54 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.5_%E5%A6%82%E4%BD%95%E5%9C%A8%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%BB%98%E5%88%B6%E8%BE%B9%E6%A1%86/</guid>
      <description>

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 为我们提供了一个专用的 &lt;code&gt;border&lt;/code&gt; 修改器，用于在视图周围绘制边框。根据我们是要指定笔划宽度(a stroke width)还是圆角半径(a corner radius)，它有一些变化，因此下面是几个示例:&lt;/p&gt;

&lt;h3 id=&#34;2-绘制1个点的边框&#34;&gt;2. 绘制1个点的边框&lt;/h3&gt;

&lt;p&gt;下面的代码在文本视图周围绘制1个点的黑色边框:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .border(Color.black)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.5_border_1_point.png&#34; alt=&#34;10.5_border_1_point&#34; title=&#34;This adds a simple 1-point black border around a text view&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-先添加填充再绘制边框&#34;&gt;3. 先添加填充再绘制边框&lt;/h3&gt;

&lt;p&gt;如果要使边框不位于视图边缘，请先添加一些填充：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .border(Color.black)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.5_border_with_padding.png&#34; alt=&#34;10.5_border_with_padding&#34; title=&#34;Add some padding first, then add border&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-添加4个点的红色边框&#34;&gt;4. 添加4个点的红色边框&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .border(Color.red, width: 4)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.5_border_4_point_red.png&#34; alt=&#34;10.5_border_4_point_red&#34; title=&#34;This adds a 4 point red border&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.4_如何堆叠修改器以创建更高级的效果</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.4_%E5%A6%82%E4%BD%95%E5%A0%86%E5%8F%A0%E4%BF%AE%E6%94%B9%E5%99%A8%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%95%88%E6%9E%9C/</link>
      <pubDate>Tue, 06 Aug 2019 10:07:51 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.4_%E5%A6%82%E4%BD%95%E5%A0%86%E5%8F%A0%E4%BF%AE%E6%94%B9%E5%99%A8%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%95%88%E6%9E%9C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;我们添加到视图中的每个修改器都会调整其前面的内容，并且可以多次重复使用修改器。&lt;/p&gt;

&lt;p&gt;例如，我们可以在文本视图周围添加填充和背景色，然后添加更多的填充和不同的背景色，然后添加更多的填充和第三种背景色，所有这些都可以产生特定的效果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Forecast: Sun&amp;quot;)
            .font(.largeTitle)
            .foregroundColor(Color.white)
            .padding()
            .background(Color.red)
            .padding()
            .background(Color.orange)
            .padding()
            .background(Color.yellow)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.4_stack_modifiers.png&#34; alt=&#34;10.4_stack_modifiers&#34; title=&#34;Stack modifiers&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.3_如何为视图周围的填充设置颜色</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.3_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E5%A1%AB%E5%85%85%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Tue, 06 Aug 2019 09:46:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.3_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E5%A1%AB%E5%85%85%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;padding()&lt;/code&gt; 修饰符允许我们在视图周围添加一些空间，&lt;code&gt;background()&lt;/code&gt; 修饰符允许我们设置背景颜色。 但是，我们使用它们的方式很重要，因此明确我们的目标以获得最佳结果非常重要。&lt;/p&gt;

&lt;h3 id=&#34;2-先着色后填充&#34;&gt;2. 先着色后填充&lt;/h3&gt;

&lt;p&gt;例如，下面的代码将创建一个具有黑色背景和白色前景的文本视图，然后向其添加系统默认填充:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .background(Color.black)
            .foregroundColor(Color.white)
            .padding()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.3_backgroudcolor_foregroundcolor_padding.png&#34; alt=&#34;10.3_backgroudcolor_foregroundcolor_padding&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-先填充后着色&#34;&gt;3. 先填充后着色&lt;/h3&gt;

&lt;p&gt;例如，下面的代码将为文本视图添加系统默认填充，然后再为其设置红色背景和白色前景:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .padding()
            .background(Color.red)
            .foregroundColor(Color.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.3_padding_backgroudcolor_foregroundcolor.png&#34; alt=&#34;10.3_padding_backgroudcolor_foregroundcolor&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-总结&#34;&gt;4. 总结&lt;/h3&gt;

&lt;p&gt;这两段代码可能看起来很相似，但是它们会产生不同的结果，因为应用修饰符的顺序很重要。在第二个示例中，视图先被填充，然后被着色，这意味着填充也被着色为红色。与此相反，第一个示例是先着色，然后填充，因此填充保持未着色。&lt;/p&gt;

&lt;p&gt;因此，如果我们希望某些文本的背景色比文本本身更宽，请确保使用第二个代码示例 – 先填充后着色。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.2_如何调整视图的位置</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.2_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 06 Aug 2019 09:17:27 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.2_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%8D%E7%BD%AE/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;所有视图在层次结构中都有一个自然位置，但是我们可以通过 &lt;code&gt;offset()&lt;/code&gt; 修改器相对于其自然位置来移动它们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要说明:&lt;/strong&gt; 使用 &lt;code&gt;offset()&lt;/code&gt; 将导致视图相对于其自然位置进行移动，但是不会影响其它视图的位置。这意味着我们可以使一个视图与另一个视图重叠，因为通常情况下它们可能彼此相邻，而这可能不是我们想要的。&lt;/p&gt;

&lt;p&gt;例如，在这个 &lt;code&gt;VStack&lt;/code&gt; 中，我们可以使用 &lt;code&gt;offset()&lt;/code&gt; 将第二个项目向下移动15个点，以便它开始与第三个项目重叠:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;Home&amp;quot;)
            Text(&amp;quot;Options&amp;quot;)
                .offset(y: 15)
            Text(&amp;quot;Help&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.2_adjust_position_2nd_item_in_vstack.png&#34; alt=&#34;10.2_adjust_position_2nd_item_in_vstack&#34; title=&#34;Set offset.y = 15 for the 2nd item&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常，我们可以使用 &lt;code&gt;padding()&lt;/code&gt; 和 &lt;code&gt;offset()&lt;/code&gt; 来得到我们期望的结果，因为这样可以移动一个视图，同时挑着做那个它旁边的视图以使其匹配。&lt;/p&gt;

&lt;p&gt;例如: 我们将第二个项目向下移动15个点，但在其底边添加15个填充点，使其不会与下面的文本视图重叠:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;Home&amp;quot;)
            Text(&amp;quot;Options&amp;quot;)
                .offset(y: 15)
                .padding(.bottom, 15)
            Text(&amp;quot;Help&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.2_adjust_position_using_padding.png&#34; alt=&#34;10.2_adjust_position_using_padding&#34; title=&#34;Set padding.bottom = 15&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.1_如何为视图提供自定义frame</title>
      <link>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.1_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89frame/</link>
      <pubDate>Tue, 06 Aug 2019 00:19:31 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/10-transforming_views/10.1_%E5%A6%82%E4%BD%95%E4%B8%BA%E8%A7%86%E5%9B%BE%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89frame/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;默认情况下，视图只占用自己所需的空间，但是如果我们想要更改它，可以使用 &lt;code&gt;frame()&lt;/code&gt; 修饰符告诉 SwiftUI 我们想要的尺寸范围(size range)。&lt;/p&gt;

&lt;p&gt;例如，可以创建一个具有 &lt;code&gt;200x200&lt;/code&gt; 可点击区域的按钮，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Button(action: {
            print(&amp;quot;Button tapped&amp;quot;)
        }, label: {
            Text(&amp;quot;Welcome&amp;quot;)
                .frame(minWidth: 0, maxWidth: 200, minHeight: 0, maxHeight: 200, alignment: .center)
                .font(.largeTitle)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.1_frame_200wh_button.png&#34; alt=&#34;10.1_frame_200wh_button&#34; title=&#34;Create a 200 * 200 button&#34; /&gt;
或者，我们可以通过指定一个 frame 来使文本视图填充整个屏幕，这个 frame 的最小宽度和最小高度为0，最大宽度和最大高度是无穷大。如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Please login&amp;quot;)
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
                .font(.largeTitle)
                .foregroundColor(Color.white)
                .background(Color.red)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/10.1_frame_fill_screen_text.png&#34; alt=&#34;10.1_frame_fill_screen_text&#34; title=&#34;Create a text which fills the screen&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>9.3_如何使用PresentationLink呈现新视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8presentationlink%E5%91%88%E7%8E%B0%E6%96%B0%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Mon, 05 Aug 2019 18:11:53 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8presentationlink%E5%91%88%E7%8E%B0%E6%96%B0%E8%A7%86%E5%9B%BE/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;PresentationLink&lt;/code&gt; 用于以现有视图控制器的基础上以模态方式呈现新视图控制器，例如在 &lt;code&gt;UIViewController&lt;/code&gt; 上调用 &lt;code&gt;present()&lt;/code&gt;。 要使用一个，给它一些要显示的内容（一些文本、一个图像等）加上一个目的地，然后让 SwiftUI 处理其余的内容。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;提示: 在beta 1和beta 2中，它被命名为 &lt;code&gt;PresentationButton&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如，如果我们有这样的详细视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct DetailView: View {
    var body: some View {
        Text(&amp;quot;Detail&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你我们可以这样呈现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>9.2_点击列表行时如何push新视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.2_%E7%82%B9%E5%87%BB%E5%88%97%E8%A1%A8%E8%A1%8C%E6%97%B6%E5%A6%82%E4%BD%95push%E6%96%B0%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Mon, 05 Aug 2019 17:40:40 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.2_%E7%82%B9%E5%87%BB%E5%88%97%E8%A1%A8%E8%A1%8C%E6%97%B6%E5%A6%82%E4%BD%95push%E6%96%B0%E8%A7%86%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;SwiftUI 中没有 &lt;code&gt;UITableView&lt;/code&gt; 的 &lt;code&gt;didSelectRowAt&lt;/code&gt; 方法的直接等价物，但它不需要这样的方法，因为我们可以将 &lt;code&gt;NavigationLink&lt;/code&gt; 与列表行结合起来并免费获取这种 behavior。&lt;/p&gt;

&lt;p&gt;我们需要将列表与我们可以使用的一些内容放在一起。 首先，我们需要某种数据来显示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Restaurant: Identifiable {
    var id = UUID()
    var name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要一个列表行视图，一次显示一个餐厅:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow: View {
    
    var restaurant: Restaurant
    
    var body: some View {
        Text(restaurant.name)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们需要一个视图，其中包含可用餐厅的列表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        let first = Restaurant(name: &amp;quot;Joe&#39;s Original&amp;quot;)
        let restaurants = [first]
        
        return NavigationView {
            List(restaurants, rowContent: { restaurant in
                RestaurantRow(restaurant: restaurant)
            }).navigationBarTitle(Text(&amp;quot;Select a restaurant&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/9.2_restaurant_list.png&#34; alt=&#34;9.2_restaurant_list&#34; title=&#34;A restaurant list&#34; /&gt;
这段代码在列表中显示一家餐馆，但是不可选。&lt;/p&gt;

&lt;p&gt;为了使点击一行显示详细视图，我们首先需要一个可以显示餐厅的详细视图。 例如，像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow: View {
    
    var restaurant: Restaurant
    
    var body: some View {
        Text(&amp;quot;Come and eat at \(restaurant.name)&amp;quot;)
            .font(.largeTitle)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了它，我们现在可以在 &lt;code&gt;NavigationLink&lt;/code&gt; 中包装 &lt;code&gt;RestaurantRow&lt;/code&gt; 行，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        let first = Restaurant(name: &amp;quot;Joe&#39;s Original&amp;quot;)
        let restaurants = [first]
        
        return NavigationView {
            List(restaurants, rowContent: { restaurant in
                NavigationLink(destination: RestaurantRow(restaurant: restaurant)) {
                    RestaurantRow(restaurant: restaurant)
                }
            }).navigationBarTitle(Text(&amp;quot;Select a restaurant&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/9.2_select_a_restaurant.gif&#34; alt=&#34;9.2_select_a_restaurant&#34; title=&#34;Select a restaurant&#34; /&gt;
如您所见，使用 &lt;code&gt;RestaurantRow(restaurant: restaurant)&lt;/code&gt; 作为行点击事件的目的地，因此将创建 &lt;code&gt;RestaurantView&lt;/code&gt; 并传递附加到列表行的餐厅。&lt;/p&gt;

&lt;p&gt;请注意，我们是如何在导航按钮中添加列表行的 — SwiftUI 凭借其出色的构图能力使其工作正常。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>9.1_如何将新视图push到NavigationView</title>
      <link>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.1_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%B0%E8%A7%86%E5%9B%BEpush%E5%88%B0navigationview/</link>
      <pubDate>Mon, 05 Aug 2019 16:58:35 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/9-presenting_views/9.1_%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%B0%E8%A7%86%E5%9B%BEpush%E5%88%B0navigationview/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果我们有一个导航视图，并且希望将一个新视图 push 到 SwiftUI 的导航堆栈上，那么我们应该使用 &lt;code&gt;NavigationLink&lt;/code&gt;，在 beta 1和2 中使用的是 &lt;code&gt;NavigationButton&lt;/code&gt;。这将一个目标作为它的第一个参数，以及在按钮内部显示什么作为它的第二个参数（或者作为一个尾随闭包），并负责将新视图和动画一起 push 到堆栈上。&lt;/p&gt;

&lt;p&gt;例如: 如果我们有这样一个 &lt;strong&gt;详细视图&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct DetailView: View {
    var body: some View {
        Text(&amp;quot;Detail&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以这样呈现它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView(), label: {
                Text(&amp;quot;Click!&amp;quot;)
                    .background(Color.red)
            })
            .navigationBarTitle(Text(&amp;quot;Navigation&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/9.1_push_view_to_navigationview.png&#34; alt=&#34;9.1_push_view_to_navigationview&#34; title=&#34;Push a view onto the navigationView&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8.4_如何显示一个action_sheet</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.4_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAaction_sheet/</link>
      <pubDate>Mon, 05 Aug 2019 16:14:42 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.4_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAaction_sheet/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 为我们提供了 &lt;code&gt;ActionSheet&lt;/code&gt; 视图，用于创建供用户选择的操作表。但是，我们确实需要确保在它被解除时重置我们的状态，否则，我们将无法再次显示它。&lt;/p&gt;

&lt;p&gt;稍后，我们再展示所有代码，现在我们首先将其分解，因为这并不容易。&lt;/p&gt;

&lt;p&gt;首先，我们需要定义一个属性来跟踪是否需要显示操作表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@State private var showingSheet = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们应该创建一个属性来存储操作表。这需要标题和消息文本，但也应该提供一个按钮数组。如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var sheet = ActionSheet(title: Text(&amp;quot;Action&amp;quot;),
                        message: Text(&amp;quot;Quote mark&amp;quot;),
                        buttons: [.default(Text(&amp;quot;Show sheet&amp;quot;))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，我们可以使用显示工作表的演示文稿将操作表附加到视图中，或者根据showsSheet的值执行任何操作，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showingSheet = false
    var sheet = ActionSheet(title: Text(&amp;quot;Action&amp;quot;),
                            message: Text(&amp;quot;Quote mark&amp;quot;),
                            buttons: [.default(Text(&amp;quot;Show sheet&amp;quot;))])
        
        
    var body: some View {
        Button(action: {
            self.showingSheet = true
        }, label: {
            Text(&amp;quot;Woo&amp;quot;)
        })
        .actionSheet(isPresented: $showingSheet, content: {
            self.sheet
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/8.4_show_action_sheet.gif&#34; alt=&#34;8.4_show_action_sheet&#34; title=&#34;Show an action sheet&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8.3_如何向alert_buttons添加actions</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.3_%E5%A6%82%E4%BD%95%E5%90%91alert_buttons%E6%B7%BB%E5%8A%A0actions/</link>
      <pubDate>Mon, 05 Aug 2019 15:54:28 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.3_%E5%A6%82%E4%BD%95%E5%90%91alert_buttons%E6%B7%BB%E5%8A%A0actions/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;基本的 SwiftUI alert 如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Alert(title: Text(&amp;quot;Important message&amp;quot;), message: Text(&amp;quot;Wear sunscreen&amp;quot;), dismissButton: .default(Text(&amp;quot;Got it!&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，我们经常需要将操作附加到按钮上，以便在点击按钮时执行特定操作。要做到这一点，请在按钮上附加一个闭包，当按钮被点击时闭包将被调用，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showAlert = false
    
    var body: some View {
        Button(action: {
            self.showAlert = true
        }, label: {
            Text(&amp;quot;Show alert&amp;quot;)
        })
        .alert(isPresented: $showAlert,
               content: {
                Alert(title: Text(&amp;quot;Are you sure you want to delete this?&amp;quot;),
                      message: Text(&amp;quot;There is no undo.&amp;quot;),
                      primaryButton: .destructive(Text(&amp;quot;Delete&amp;quot;), action: {
                        print(&amp;quot;Deleting...&amp;quot;)
                      }),
                      secondaryButton: .cancel())
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/8.3_add_actions_to_alert_buttons.gif&#34; alt=&#34;8.3_add_actions_to_alert_buttons&#34; title=&#34;Add actions to alert buttons&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;提示: 在预览视图中，点击 &lt;code&gt;Delete&lt;/code&gt; 按钮，控制台没有日志输出。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>8.2_如何显示一个alert</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.2_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAalert/</link>
      <pubDate>Mon, 05 Aug 2019 15:23:39 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.2_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAalert/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;创建一个基本的 SwiftUI alert 的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Alert(title: Text(&amp;quot;Important message&amp;quot;), message: Text(&amp;quot;Wear sunscreen&amp;quot;), dismissButton: .default(Text(&amp;quot;Got it!&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它定义了一个标题和消息，就像我们在 &lt;code&gt;UIAlertController&lt;/code&gt; 中看到的那样，然后添加了一个带有默认样式的 dismiss 按钮和文本 &amp;ldquo;Got it!&amp;ldquo;。&lt;/p&gt;

&lt;p&gt;要显示该 alert，我们需要定义某种可绑定条件，以确定 alert 是否可见。然后将其作为演示附加到主视图中，在 alert 条件变为 true 的时候，立即显示 alert。&lt;/p&gt;

&lt;p&gt;例如: 下面的代码创建一个 &lt;code&gt;showingAlert&lt;/code&gt; 的布尔值，用于跟踪是否应该显示 &amp;ldquo;sunscreen message&amp;rdquo;，在点击按钮时将该布尔值设置为 true，然后使用该布尔值创建并附加一个 alert 视图，以便在点击按钮时显示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showingAlert = false
    
    var body: some View {
        Button(action: {
            self.showingAlert = true
        }, label: {
            Text(&amp;quot;Show alert&amp;quot;)
        })
        .alert(isPresented: $showingAlert,
               content: {
                Alert(title: Text(&amp;quot;Important message&amp;quot;), message: Text(&amp;quot;Wear sunscreen&amp;quot;), dismissButton: .default(Text(&amp;quot;Got it!&amp;quot;)))
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果演示:
&lt;img src=&#34;img/8.2_show_alert.gif&#34; alt=&#34;8.2_show_alert&#34; title=&#34;Show a alert&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; 通过这种方式展示一个 alert，当按下关闭按钮时，会自动将 &lt;code&gt;showingAlert&lt;/code&gt; 设置回 false。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>8.1_使用presentations</title>
      <link>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.1_%E4%BD%BF%E7%94%A8presentations/</link>
      <pubDate>Mon, 05 Aug 2019 11:54:02 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/8-alerts_and_action_sheets/8.1_%E4%BD%BF%E7%94%A8presentations/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的声明性编程方法意味着我们不会像在 UIKit 中那样创建和呈现 &lt;strong&gt;警报(Alerts)&lt;/strong&gt; 和 &lt;strong&gt;操作表(Action sheets)&lt;/strong&gt;。 相反，我们定义了它们应该什么条件下显示，告诉它它们应该是什么样子，然后让它自己计算出其余部分。&lt;/p&gt;

&lt;p&gt;这一切都是通过使用 &lt;code&gt;presentation()&lt;/code&gt; 修饰符来完成的，该修饰符将新 UI 附加到我们的视图中，当满足某个条件时将显示该 UI。我们可以根据需要附加任意多个，并且它们实际上会等待观察，直到它们的状态变为真(true)，这个时候，它们显示自己的 UI。例如: 我们可以在按下按钮时切换一个布尔值，这会触发要显示的警报(alerts)。&lt;/p&gt;

&lt;p&gt;我们可以将演示文稿附加到主视图或其任何子视图，甚至是可以调整状态的按钮，以便触发演示文稿。这是一个微妙的区别，但重要的是要理解，这些演示文稿并没有附加到按钮上，因为它是一个按钮，也就是说，由于点按了按钮，所以不会以任何方式显示警报(alerts)。相反，我们将它附加到我们的视图层次结构中，以便 SwiftUI 知道它可能在任何时候显示。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.4_如何将视图组合在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.4_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Mon, 05 Aug 2019 11:22:27 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.4_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果我们需要将多个视图作为一个视图，例如: 一起转换。那么，我们应该使用 SwiftUI 的 &lt;code&gt;Group&lt;/code&gt; 视图。这一点尤为重要，因为出于底层的技术原因，我们一次性最多只能向父视图添加十个子视图。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;line - 0&amp;quot;)
            Text(&amp;quot;line - 1&amp;quot;)
            Text(&amp;quot;line - 2&amp;quot;)
            Text(&amp;quot;line - 3&amp;quot;)
            Text(&amp;quot;line - 4&amp;quot;)
            Text(&amp;quot;line - 5&amp;quot;)
            Text(&amp;quot;line - 6&amp;quot;)
            Text(&amp;quot;line - 7&amp;quot;)
            Text(&amp;quot;line - 8&amp;quot;)
            Text(&amp;quot;line - 9&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/group_10_lines.png&#34; alt=&#34;group_10_lines&#34; title=&#34;Show 10 lines&#34; /&gt;
一切正常，但是，当我们尝试添加第11行文本的时候，就会报错:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Ambiguous reference to member &#39;buildBlock&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误预览:
&lt;img src=&#34;img/grouo_11_lines_error.png&#34; alt=&#34;grouo_11_lines_error&#34; title=&#34;When show the 11th line, throw a error&#34; /&gt;
后面是一串这样的错误信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;ContentView.swift:10:16: Found this candidate (SwiftUI.ViewBuilder)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为 SwiftUI 的视图构建系统中有各种各样的代码设计，可以让我们添加1个视图、2个视图、2个视图、3个视图、4个视图、5个视图、6个视图、7个视图、8个视图、9个视图和10个视图，但是不适用于11个或更多视图 - 这不起作用。&lt;/p&gt;

&lt;p&gt;幸运的是，我们可以像这样使用 &lt;code&gt;group&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Group {
                Text(&amp;quot;line - 0&amp;quot;)
                Text(&amp;quot;line - 1&amp;quot;)
                Text(&amp;quot;line - 2&amp;quot;)
                Text(&amp;quot;line - 3&amp;quot;)
                Text(&amp;quot;line - 4&amp;quot;)
                Text(&amp;quot;line - 5&amp;quot;)
            }
            Group {
                Text(&amp;quot;line - 6&amp;quot;)
                Text(&amp;quot;line - 7&amp;quot;)
                Text(&amp;quot;line - 8&amp;quot;)
                Text(&amp;quot;line - 9&amp;quot;)
                Text(&amp;quot;line - 10&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/group_11_lines.png&#34; alt=&#34;group_11_lines&#34; title=&#34;Group 11 lines&#34; /&gt;
这产生了完全相同的结果，现在我们可以超过10个视图的限制，因为 &lt;code&gt;VStack&lt;/code&gt; 中只包含两个视图——两个组。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.3_如何给导航视图添加bar_items</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.3_%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0bar_items/</link>
      <pubDate>Mon, 05 Aug 2019 11:06:31 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.3_%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0bar_items/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过 &lt;code&gt;navigationBarItems()&lt;/code&gt; 修饰符，我们可以在导航视图的 &lt;em&gt;前缘(leading)&lt;/em&gt; 和 &lt;em&gt;后缘(trailing)&lt;/em&gt;  添加 &lt;strong&gt;bar items&lt;/strong&gt;。这些 &lt;strong&gt;bar items&lt;/strong&gt; 可能是一个可点击的按钮，但没有任何限制 - 您可以添加任何类型的视图。&lt;/p&gt;

&lt;p&gt;例如: 我们可以在导航视图的后缘(trailing)添加一个 &lt;strong&gt;帮助按钮&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        NavigationView {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;))
            .navigationBarItems(trailing:
                Button(action: {
                    print(&amp;quot;Help tapped!&amp;quot;)
                }, label: {
                    Text(&amp;quot;Help&amp;quot;)
                })
            )
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_add_bar_items.png&#34; alt=&#34;navigationview_add_bar_items&#34; title=&#34;Add bar items.&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.2_如何在导航视图中嵌入视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.2_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Fri, 02 Aug 2019 18:18:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.2_%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AF%BC%E8%88%AA%E8%A7%86%E5%9B%BE%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;NavigationView&lt;/code&gt; 几乎等同于 UIKit 中的 &lt;code&gt;UINavigationController&lt;/code&gt;，因为它不仅可以呈现内容，而且它能够处理视图之间的导航，并在屏幕顶部放置一个导航栏。&lt;/p&gt;

&lt;h3 id=&#34;2-嵌入文本视图&#34;&gt;2. 嵌入文本视图&lt;/h3&gt;

&lt;p&gt;接下来，我们以最简单的形式，将文本视图放入导航视图中，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        NavigationView {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_embed_text_no_navigationbar.png&#34; alt=&#34;navigationview_embed_text_no_navigationbar&#34; title=&#34;Embed a text in  the navigationView&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-设置导航栏标题&#34;&gt;3. 设置导航栏标题&lt;/h3&gt;

&lt;p&gt;但是这样，顶部的导航栏为空。因此，通常在嵌入的内容上使用 &lt;code&gt;navigationBarTitle()&lt;/code&gt; 修饰符，因此，我们可以在屏幕顶部添加标题，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;NavigationView {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
        .navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_embed_text_has_navigationbar.png&#34; alt=&#34;navigationview_embed_text_has_navigationbar&#34; title=&#34;Embed a text in the navigationView which has a navigationBar&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-自定义导航标题&#34;&gt;4. 自定义导航标题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;navigationBarTitle()&lt;/code&gt; 修饰符为我们提供了一些自定义选项。&lt;/p&gt;

&lt;p&gt;例如: 默认情况下，它将从呈现它的任何视图继承大型标题显示模式，或者如果它是初始视图，那么它将使用大型标题。但是，如果我们想强制启用或禁用大标题，那么我们应该使用 &lt;code&gt;inline&lt;/code&gt; 参数，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;), displayMode: .inline)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/navigationview_navigationbar_inline.png&#34; alt=&#34;navigationview_navigationbar_inline&#34; title=&#34;Display mode is inline.&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.1_使用容器</title>
      <link>https://coderxdlee.github.io/post/swiftui/7-container/7.1_%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 02 Aug 2019 18:06:43 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/7-container/7.1_%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 设计为开箱即用，这意味着我们可以根据需要将一个视图放在另一个视图中。&lt;/p&gt;

&lt;p&gt;这在处理我们习惯的主要容器视图（如导航控制器和选项卡栏控制器）时特别有用。我们可以将想要的任何视图直接放置到另一个容器视图中，Swiftui将自动调整其布局。&lt;/p&gt;

&lt;p&gt;在这方面，Swiftui自己的容器—— &lt;code&gt;NavigationView&lt;/code&gt;、&lt;code&gt;TabbedView&lt;/code&gt;、&lt;code&gt;Group&lt;/code&gt; 等等——与我们用自己的视图组合制作的容器没有什么不同。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.6_显示或隐藏表单行</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.6_%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E8%A1%8C/</link>
      <pubDate>Fri, 02 Aug 2019 15:27:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.6_%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E8%A1%8C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 允许我们可以根据需要在表单中添加和删除项目，当我们希望调整基于先前选项可见的选项列表时，特别有用。&lt;/p&gt;

&lt;p&gt;例如，这会显示单个 &lt;em&gt;toggle&lt;/em&gt; ，提示用户是否要显示更多高级选项。启用该 &lt;em&gt;toggle&lt;/em&gt; 后，会出现第二个 &lt;em&gt;toggle&lt;/em&gt; ，允许他们启用日志记录:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var showingAdvancedOptions = false
    @State var enableLogging = false
    
    var body: some View {
        Form {
            Section {
                Toggle(isOn: $showingAdvancedOptions) {
                    Text(&amp;quot;Show advanced options&amp;quot;)
                }
                
                if showingAdvancedOptions {
                    Toggle(isOn: $enableLogging) {
                        Text(&amp;quot;Enable logging&amp;quot;)
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.6_form_show_hide.gif&#34; alt=&#34;6.6_form_show_hide&#34; title=&#34;Form show or hide&#34; /&gt;
与其他绑定一样，可以要求 SwiftUI 对绑定更改导致的视图更改使用隐式动画，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State var showingAdvancedOptions = false
    @State var enableLogging = false
    
    var body: some View {
        Form {
            Section {
                Toggle(isOn: $showingAdvancedOptions.animation()) {
                    Text(&amp;quot;Showing Advanced Options&amp;quot;)
                }
            }
            
            if showingAdvancedOptions {
                Toggle(isOn: $enableLogging) {
                    Text(&amp;quot;Enable Logging&amp;quot;)
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.6_form_show_hide_animation.gif&#34; alt=&#34;6.6_form_show_hide_animation&#34; title=&#34;Form show or hide with animation&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.5_启用和禁用表单中的元素</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 02 Aug 2019 15:04:09 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.5_%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 允许我们通过使用 &lt;code&gt;disabled()&lt;/code&gt; 修饰符来禁用表单的任何部分甚至整个表单。这需要一个布尔值来定义是否应禁止使用该元素。表单元素的样式会自动更新以反映其状态-例如，&lt;em&gt;buttons&lt;/em&gt; 和  &lt;em&gt;toggles&lt;/em&gt; 变为灰色。&lt;/p&gt;

&lt;p&gt;例如，这将创建一个包含两个 sections 的表单：一个 &lt;em&gt;section&lt;/em&gt; 包含 Toggle ，另一个 &lt;em&gt;section&lt;/em&gt; 包含仅在切换打开时才启用的 Button：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var agreedToTerms = false
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    Toggle(isOn: $agreedToTerms) {
                        Text(&amp;quot;Agree to terms and conditions&amp;quot;)
                    }
                }
                Section {
                    Button(action: {
                        // show next screen here
                    }) {
                        Text(&amp;quot;Continue&amp;quot;)
                    }
                    .disabled(!agreedToTerms)
                }
            }
            .navigationBarTitle(Text(&amp;quot;Welcome&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.5_form_enable_disable.gif&#34; alt=&#34;6.5_form_enable_disable&#34; title=&#34;Form enable and disable&#34; /&gt;
如您所见，只需将禁用 &lt;code&gt;(!agreeToTerms)&lt;/code&gt; 添加到修改器列表中即可禁用该按钮。&lt;/p&gt;

&lt;p&gt;与许多其他SwiftIUI修饰符一样，您可以提升 &lt;code&gt;disabled()&lt;/code&gt;，以便它在 Section 上运行，甚至在整个表单上运行，这取决于您想要的行为——例如，只需移动 &lt;code&gt;disabled(!agreedToTerms)&lt;/code&gt; 使它位于该 section 之后:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Section {
    Button(action: {
        // show next screen here
    }) {
        Text(&amp;quot;Continue&amp;quot;)
    }
}
.disabled(!agreedToTerms)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>6.4_表单中选择器的使用</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 02 Aug 2019 13:49:59 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.4_%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;在表单内部，SwiftUI 的 &lt;code&gt;选择器视图&lt;/code&gt; 具有特殊的行为，可根据我们使用它们的平台自动进行调整。在 iOS 上，这种行为尤其令人印象深刻，因为选择器可以折叠到一个列表行，该行导航到一个新的可能选项列表中——这是处理许多选项的一种非常自然的方式。&lt;/p&gt;

&lt;p&gt;例如，这将创建一个带有选择器的表单，并为其项使用数组：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var strengths = [&amp;quot;Mild&amp;quot;, &amp;quot;Medium&amp;quot;, &amp;quot;Mature&amp;quot;]
    @State var selectedStrength = 0
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    Picker(selection: $selectedStrength, label: Text(&amp;quot;Text strength&amp;quot;)) {
                        ForEach(0..&amp;lt;strengths.count) {
                            Text(self.strengths[$0]).tag($0)
                        }
                    }
                }
            }
            .navigationBarTitle(Text(&amp;quot;Select your cheese&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.4_form_pickers.gif&#34; alt=&#34;6.4_form_pickers&#34; title=&#34;Form pickers&#34; /&gt;
表单中的选择器
在 iOS 上，这将显示为一个单独的列表行，您可以点击该行进入一个新屏幕，显示所有可能的选项—— Mild、Medium 和 Mature。您当前的选择旁边将有一个复选标记，当您选择一个新选项时，它将返回上一个屏幕，并显示当前的选项。&lt;/p&gt;

&lt;p&gt;如果要禁用此行为，可以使用.PickerStyle(.wheel)修饰符强制选取器采用其常规样式，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Picker(selection: $selectedStrength, label: Text(&amp;quot;Text strength&amp;quot;)) {
    ForEach(0..&amp;lt;strengths.count) {
        Text(self.strengths[$0]).tag($0)
    }
}
.pickerStyle(WheelPickerStyle())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.4_form_pickers_wheel.gif&#34; alt=&#34;6.4_form_pickers_wheel&#34; title=&#34;Picker with wheel style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.3_将表单分成几个sections</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/</link>
      <pubDate>Fri, 02 Aug 2019 12:01:16 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.3_%E5%B0%86%E8%A1%A8%E5%8D%95%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AAsections/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的表单通常在分成多个部分时效果最好，就像常规的内容列表一样。 如何将它们分组取决于你，但是通常情况下，按照它们的目的进行分组效果最好 - 如果它是一个订单页面你可以将项目放在一个组中，在另一个组中进行定制，并在第三个组中进行交付。
很有帮助的是，表单 sections 与列表 sections 相同，这意味着您可以在两个地方重复使用相同的代码。因此，您可以向 sections 中添加 &lt;em&gt;header&lt;/em&gt; 和/或 &lt;em&gt;footer&lt;/em&gt; ，或者两者都不使用，只需在 sections 之间获得一些屏幕上的间距。&lt;/p&gt;

&lt;p&gt;例如，这将创建一个包含两个 section 的表单，第一个 section 带有 &lt;em&gt;segmented control&lt;/em&gt; 和 &lt;em&gt;toggle&lt;/em&gt; ，第二个 section 带有保存按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var enableLogging = false
    @State var selectedColor = 0
    @State var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        Form {
            Section(footer: Text(&amp;quot;Note: Enabling logging may slow down the app&amp;quot;)) {
                SegmentedControl(selection: $selectedColor) {
                    ForEach(0..&amp;lt;colors.count) {
                        Text(self.colors[$0]).tag($0)
                    }
                }
                Toggle(isOn: $enableLogging) {
                    Text(&amp;quot;Enable logging&amp;quot;)
                }
            }
            Section {
                Button(action: {
                    
                }) {
                    Text(&amp;quot;Save changes&amp;quot;)
                }
            }
        }
        .navigationBarTitle(Text(&amp;quot;Settings&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.3_form_sections.gif&#34; alt=&#34;6.3_form_sections&#34; title=&#34;Form sections&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.2_基本表单设计</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 02 Aug 2019 00:37:07 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;p&gt;SwiftUI 中的 &lt;code&gt;表单(forms)&lt;/code&gt; 可以当作容器使用，就像 &lt;code&gt;HStack&lt;/code&gt; 和 &lt;code&gt;VStack&lt;/code&gt; 一样，这意味着我们可以根据需要在其中添加其它视图。 但是，表单会自动调整某些控件的行为和样式，以便它们更好地适应表单环境。
例如，我们将创建一个带有 _toggle_、&lt;em&gt;segmentedControl&lt;/em&gt; 和 &lt;em&gt;button&lt;/em&gt; 的表单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var enableLogging = false
    @State var selectedColor = 0
    @State var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        NavigationView {
            Form {
                Picker(selection: $selectedColor, label: Text(&amp;quot;&amp;quot;)) {
                    ForEach(0..&amp;lt;colors.count) {
                        Text(self.colors[$0]).tag($0)
                    }
                }
                .pickerStyle(SegmentedPickerStyle())
                
                Toggle(isOn: $enableLogging) {
                    Text(&amp;quot;Enable logging!&amp;quot;)
                }
                Button(action: {
                    // activate theme!
                }) {
                    Text(&amp;quot;Save changes&amp;quot;)
                }
            }
            .navigationBarTitle(Text(&amp;quot;Settings&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.3_forms_basic_design.gif&#34; alt=&#34;6.3_forms_basic_design&#34; /&gt;
当代码运行时，我们将看到两件对表单行为至关重要的事情:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 iOS 上，表单自动采用 &lt;code&gt;分组列表&lt;/code&gt; 的样式，因此用户可以看到滚动选项。&lt;/li&gt;
&lt;li&gt;按钮已经调整了自己，看起来像一个可操作的列表行—— &lt;code&gt;左对齐，蓝色&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 我们可以根据需要在表单中包含尽可能多的行，但如果需要超过10，请记住使用组(groups)。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>6.1_表单的使用介绍</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 02 Aug 2019 00:21:32 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SwiftUI 专注于声明性用户界面，因此它为我们提供了一种构建 &lt;code&gt;表单(Form)&lt;/code&gt; 的绝佳机制也就不足为奇了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;表单(Form)&lt;/code&gt; 指的是用于&lt;strong&gt;收集信息&lt;/strong&gt;的用户输入控件的集合，例如 &lt;em&gt;订单表单&lt;/em&gt; 或 &lt;em&gt;设置界面&lt;/em&gt; 。&lt;/li&gt;
&lt;li&gt;更好的是，在表单中，SwiftUI 的几个部分会自适应放置——它们的外观和行为会发生变化，因此它们与其它输入控件组一起工作得更好。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你认为这很聪明，你会喜欢这个: 实际上 SwiftUI 会动态地调整布局，以便它可以根据代码运行的平台自动为我们生成全新的页面 - 它完全将控件的目的与它们的视觉效果分离开来。 这意味着我们描述了我们想要的东西，SwiftUI 找出了在当前平台上实现这一目标的惯用方法。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; &lt;code&gt;Form&lt;/code&gt; 和 &lt;code&gt;VStack&lt;/code&gt; 一样是常规容器，因此我们可以根据需要在这两者之间自由切换。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>5.9_如何使用隐式叠加</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/</link>
      <pubDate>Thu, 01 Aug 2019 23:23:26 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%8F%A0%E5%8A%A0/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;如果创建一个动态列表并在每行中放置多个内容，会发生什么情况？SwiftUI 的解决方案简单、灵活，并且在默认情况下为我们提供了良好的行为: 它创建了一个隐式的 &lt;code&gt;HStack&lt;/code&gt; 来保存您的项目，因此它们会自动进行水平布局。
例如，如果我们想要创建一行，其中左侧有一张小图片，剩余的空间分配给一个文本字段，那么我们将从一个结构开始，这样保存数据:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User: Identifiable {
    var id = UUID()
    var username = &amp;quot;Anonymous&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我已经给出了这两个默认值，以便简化示例。
完成后，我们可以创建一个包含三个用户的数组，并在动态列表中显示它们，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    let users = [User(), User(), User()]

    var body: some View {
        List(users) { user in
            Image(&amp;quot;paul-hudson&amp;quot;)
                .resizable()
                .frame(width: 40, height: 40)
            Text(user.username)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_9_list_implicit_stacking.gif&#34; alt=&#34;5_9_list_implicit_stacking&#34; title=&#34;Implicit stacking&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.8_如何制作分组列表</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/</link>
      <pubDate>Thu, 01 Aug 2019 23:22:15 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.8_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%88%86%E7%BB%84%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 List 支持 &lt;em&gt;grouped&lt;/em&gt; 或 &lt;em&gt;plain&lt;/em&gt; 样式，就像 &lt;code&gt;UITableView&lt;/code&gt; 一样。默认为 &lt;em&gt;plain&lt;/em&gt; 样式，但如果要改为 &lt;em&gt;grouped&lt;/em&gt; 样式，则应使用 列表 的 &lt;code&gt;.listStyle(.grouped)&lt;/code&gt; 修饰符。
例如，这里定义了一个示例行，并将其放置在分组列表中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ExampleRow : View {
    var body: some View {
        Text(&amp;quot;Example Row&amp;quot;)
    }
}

struct ContentView : View {
    var body: some View {
        List {
            Section(header: Text(&amp;quot;Examples&amp;quot;)) {
                ExampleRow()
                ExampleRow()
                ExampleRow()
            }
        }.listStyle(.grouped)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_8_list_grouped_style.gif&#34; alt=&#34;5_8_list_grouped_style&#34; title=&#34;List - grouped style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.7_如何向列表中添加sections</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/</link>
      <pubDate>Thu, 01 Aug 2019 23:21:13 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.7_%E5%A6%82%E4%BD%95%E5%90%91%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0sections/</guid>
      <description>&lt;p&gt;SwiftUI 的列表视图内置了对 &lt;em&gt;sections&lt;/em&gt; 和 &lt;em&gt;section headers&lt;/em&gt; 的支持，就像 UIKit 中的 &lt;code&gt;UITableView&lt;/code&gt; 一样。若要给某些 cells 添加一个 _section_，首先在其周围放置一个 &lt;code&gt;Section&lt;/code&gt;，也可以添加 &lt;em&gt;header&lt;/em&gt; 和 _footer_。
举个例子，这里有一行包含提醒应用的任务数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct TaskRow: View {
    var body: some View {
        Text(&amp;quot;Task data goes here&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们要做的是创建一个列表视图，它有两个Sections：一个用于重要任务，另一个用于次要任务。这是它的样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        List {
            Section(header: Text(&amp;quot;Important task&amp;quot;)) {
                TaskRow()
                TaskRow()
                TaskRow()
            }
            Section(header: Text(&amp;quot;Other task&amp;quot;)) {
                TaskRow()
                TaskRow()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_7_list_sections.gif&#34; alt=&#34;5_7_list_sections&#34; title=&#34;List sections&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.6_如何使用EditButton在列表上启用编辑</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/</link>
      <pubDate>Wed, 31 Jul 2019 00:40:13 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8editbutton%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%8A%E5%90%AF%E7%94%A8%E7%BC%96%E8%BE%91/</guid>
      <description>&lt;p&gt;如果您已配置 SwiftUI 列表视图以支持删除或编辑其项目，则可以允许用户通过在某个地方添加 &lt;code&gt;EditButton&lt;/code&gt; 来切换列表视图的编辑模式。
例如，这个 ContentView 结构定义了一个用户数组，附加了一个 &lt;code&gt;OnDelete()&lt;/code&gt; 方法，然后在导航栏中添加了一个编辑按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var users = [&amp;quot;Paul&amp;quot;, &amp;quot;Taylor&amp;quot;, &amp;quot;Adele&amp;quot;]
    
    var body: some View {
        NavigationView {
            List {
                ForEach(users.identified(by: \.self)) { user in
                    Text(user)
                }
                .onDelete(perform: delete)
            }
            .navigationBarItems(trailing: EditButton())
        }
    }
    
    func delete(at offsets: IndexSet) {
        if let first = offsets.first {
            users.remove(at: first)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后，您会发现您可以点击编辑按钮来启用或禁用列表中项目的编辑模式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.5_如何让用户移动列表中的行</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/</link>
      <pubDate>Wed, 31 Jul 2019 00:26:20 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.5_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E7%A7%BB%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A1%8C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 为我们提供了简单地列表挂钩（hooks），让我们可以移动行(rows)，尽管 WWDC 上演示的一些功能在当前的测试版中实际上不可用，所以我们需要一个变通的解决方法。
我们可以将 &lt;code&gt;onMove(perform:)&lt;/code&gt; 修饰符附加到列表中的项目，并让它在移动操作发生时调用我们选择的方法。 该方法需要接受 source IndexSet 和 destination Int，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func move(from source: IndexSet, to destination: Int) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移动多个项目时，最好先移动后一个项目，这样可以避免移动其他项目并混淆索引
例如，我们可以创建一个 ContentView 结构，它设置一个由三个用户名字符串组成的数组，并要求SwiftUI在调用 &lt;code&gt;move()&lt;/code&gt;方法时移动它们。为了激活“移动”（即显示拖动手柄），它还向导航视图添加了一个编辑按钮，以便用户切换编辑模式。
这是代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var users = [&amp;quot;Paul&amp;quot;, &amp;quot;Taylor&amp;quot;, &amp;quot;Adele&amp;quot;]
    
    var body: some View {
        NavigationView {
            List {
                ForEach(users, id: \.self, content: { user in
                    Text(user)
                })
                .onMove(perform: move)
            }
            .navigationBarItems(trailing: EditButton())
        }
    }
    
    func move(from source: IndexSet, to destination: Int) {
        // sort the indexes low to high
        let reverseSource = source.sorted()
        
        // then loop from the back to avoid reordering problems
        for index in reverseSource.reversed() {
            // for each item, remove it and insert it at the destination
            users.insert(users.remove(at: index), at: destination)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_5_list_move_row.gif&#34; alt=&#34;5_5_list_move_row&#34; title=&#34;Move row&#34; /&gt;
在WWDC会话演示中，他们的 &lt;code&gt;move()&lt;/code&gt; 方法只是一行代码，因为它在 Swift 数组上使用了一个对我们不可用的扩展——希望它很快就会到来！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.4_如何让用户从列表中删除行</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/</link>
      <pubDate>Tue, 30 Jul 2019 23:55:31 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.4_%E5%A6%82%E4%BD%95%E8%AE%A9%E7%94%A8%E6%88%B7%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%8C/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;通过将 &lt;code&gt;OnDelete(perform:)&lt;/code&gt; 处理程序附加到部分或全部数据，SwiftUI 可以方便地让用户滑动以删除行。此处理程序需要具有一个特定签名，它可以接受多个索引以删除，如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func delete(at offsets: IndexSet) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，您可以循环访问集合中的每个索引，或者只读取第一个索引（如果您只想处理它的话）。因为SwiftUI 正在监视您的状态，所以您所做的任何更改都将自动反映在您的UI中。
注意：此功能的 WWDC 演示使用了一个名为 &lt;code&gt;remove(atOffsets:)&lt;/code&gt; 的不存在的Swift数组方法，它为我们完成了所有这些工作 - 希望这将在未来版本中出现。
例如，此代码创建一个包含三个项目列表的 ContentView 结构，然后附加一个 &lt;code&gt;OnDelete(perform:)&lt;/code&gt; 修饰符，用于删除列表中的任何项目:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State var users = [&amp;quot;Paul&amp;quot;, &amp;quot;Taylor&amp;quot;, &amp;quot;Adele&amp;quot;]
    
    var body: some View {
        List {
            ForEach(users, id: \.self) { user in
                Text(user)
            }
            .onDelete(perform: delete)
        }
    }
    
    func delete(at offsets: IndexSet) {
        if let first = offsets.first {
            users.remove(at: first)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_4_list_delete_row.gif&#34; alt=&#34;5_4_list_delete_row&#34; title=&#34;Delete a row&#34; /&gt;
如果您运行该代码，您会发现可以滑动以删除列表中的任何行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.3_如何创建动态项目列表</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jul 2019 22:26:03 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;为了处理动态项目，我们必须首先告诉 SwiftUI 如何识别哪个项目是哪个。 这是使用 &lt;code&gt;Identifiable&lt;/code&gt; 协议完成的，该协议只有一个要求: 某种类型的 id 值，SwiftUI 可以使用它来查看哪个项目是哪个。
例如，我们可以创建一个 &lt;code&gt;Restaurant&lt;/code&gt; 结构体，该结构表示餐馆具有 ID 和 name ，ID 是一个随机标识符，以便 SwiftUI 知道哪个是哪个:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Restaurant: Identifiable {
    var id = UUID()
    var name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们将定义列表行的外观。在我们的例子中，我们将定义一个 &lt;code&gt;Restaurantrow&lt;/code&gt; 视图，该视图存储一个餐厅并在文本视图中打印其名称:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow : View {
    
    var restaurant: Restaurant
    
    var body: some View {
        Text(&amp;quot;Come and eat at \(restaurant.name)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们可以创建一个列表视图来显示所有内容。这意味着创建一些示例数据，将其放入数组中，然后将其传递到要呈现的列表中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var body: some View {
        
        let first = Restaurant(name: &amp;quot;Joe&#39;s Original&amp;quot;)
        let second = Restaurant(name: &amp;quot;The Real Joe&#39;s Original&amp;quot;)
        let third = Restaurant(name: &amp;quot;Original Joe&#39;s&amp;quot;)
        let restaurants = [first, second, third]
        
        return List(restaurants) { restaurant in
            RestaurantRow(restaurant: restaurant)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中大部分只是创建数据——最后一部分是实际操作的地方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;return List(restaurants) { restaurant in
    RestaurantRow(restaurant: restaurant)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它从 restaurants 数组创建一个列表，对数组中的每个项目执行一次闭包。每次执行闭包时，餐厅的输入都将由数组中的一个项目填充，因此我们使用它来创建一个 Restaurantrow。
事实上，在这种小case下，我们可以使代码更短:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;return List(restaurants, rowContent: RestaurantRow.init)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_3_list_dynamic_items_list.gif&#34; alt=&#34;5_3_list_dynamic_items_list&#34; title=&#34;Dynamic list&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.2_如何创建静态项列表</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jul 2019 00:23:02 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E9%A1%B9%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;要创建静态项目列表，首先需要定义列表中每行的外观。 这是一个与其他视图一样的视图，因此您可以编写如下的视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RestaurantRow : View {
    
    var name: String
    
    var body: some View {
        Text(&amp;quot;Restaurant: \(name)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然已经定义了每一行的外观，那么就可以创建一个 &lt;code&gt;List&lt;/code&gt;，根据需要创建任意数量的行，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        List {
            RestaurantRow(name: &amp;quot;Joe&#39;s Original&amp;quot;)
            RestaurantRow(name: &amp;quot;The Real Joe&#39;s Original&amp;quot;)
            RestaurantRow(name: &amp;quot;Original Joe&#39;s&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/5_2_list_static_items_list.gif&#34; alt=&#34;5_2_list_static_items_list&#34; title=&#34;static list&#34; /&gt;
当该代码运行时，您将在表中看到三行，就像您在 UIKit 中使用 &lt;code&gt;UITableView&lt;/code&gt; 一样。
您不需要使每一行使用相同的视图类型，因此您可以根据需要混合和匹配行视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.1_使用List</title>
      <link>https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/</link>
      <pubDate>Mon, 29 Jul 2019 01:40:08 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/5-list/5.1_%E4%BD%BF%E7%94%A8list/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;List&lt;/code&gt; 视图类似于 &lt;code&gt;UITableView&lt;/code&gt;，它可以根据您的需要显示静态或动态表视图单元格(table view cells)。 但是，它使用起来要简单得多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们不需要在 storyboard 中创建原型cell( &lt;em&gt;prototype cell&lt;/em&gt; );&lt;/li&gt;
&lt;li&gt;也不需要在代码中注册 Cell;&lt;/li&gt;
&lt;li&gt;我们不需要告诉它有多少行;&lt;/li&gt;
&lt;li&gt;我们不需要手动出列(dequeue)和配置单元格等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相反，SwiftUI 的列表是为可组合性而设计的 - 旨在能够从较小的东西构建更大的东西。 因此，SwiftUI 不需要一个手动配置单元的大视图控制器，而是让我们构建小视图，知道如何将自己配置为列表行，然后使用它们。&lt;/p&gt;

&lt;p&gt;在代码大小方面（如果没有其他的话），差异是惊人的——您可以删除几乎所有的表视图代码，仍然可以获得与您习惯的相同的出色外观和感觉。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4.3_如何使用@EnvironmentObject在视图之间共享数据</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 29 Jul 2019 01:17:25 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8environmentobject%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;对于应该与整个应用程序中所有视图共享的数据，SwiftUI 为我们提供了 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 。这使我们可以在任何需要的地方共享模型数据，同时确保当模型数据发生变化时，我们的视图自动保持更新。&lt;/p&gt;

&lt;p&gt;可以将 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 看作是在多个视图中使用 &lt;code&gt;@ObjectBinding&lt;/code&gt; 的一种更智能、更简单的方法。而不是在视图 A 中创建一些数据，然后将其传递给视图 B，然后查看视图 C，然后在最终使用数据之前查看视图 D，我们可以在视图中创建它并将其放入环境（environment）中，这样的话，视图B、C、D将会自动访问它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 环境对象必须由祖先视图（ancestor view）提供 &amp;ndash; 如果 SwiftUI 找不到正确类型的环境对象，将会导致崩溃（crash），这也适用于预览，所以要小心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 这里有一个可绑定对象，用于存储用户设置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Combine
import SwiftUI
​
class UserSettings: BindableObject {
    
    var didChange = PassthroughSubject&amp;lt;Void, Never&amp;gt;()
    
    var score = 0 {
        didSet {
            didChange.send(())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，它只存储一个值，但是没关系 &amp;ndash; 重要的是: 当值发生改变时，&lt;code&gt;PassthroughSubject&lt;/code&gt; 会告诉所有使用它（这个值）的的视图进行刷新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用户设置&lt;/strong&gt; 是我们可能希望能够在应用程序的任何地方共享的一个合理的数据，这样我们就不再需要手动处理同步。&lt;/p&gt;

&lt;p&gt;因此，当我们的应用程序首次启动时，我们将创建一个 &lt;code&gt;UserSettings&lt;/code&gt; 的实例。以便在我们的应用程序中随处都可以访问共享实例。&lt;/p&gt;

&lt;p&gt;如果打开 &lt;em&gt;Scenedelegate.swift&lt;/em&gt; ，您将在 &lt;code&gt;（_:willConnectTo:options:）&lt;/code&gt;方法：中找到这两行代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let window = UIWindow(windowScene: windowScene)
window.rootViewController = UIHostingController(rootView: ContentView())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行代码创建我们的初始内容视图（ContentView）并将其显示到屏幕上。这就是我们需要传入我们创建的任何环境对象的地方，以便 SwiftUI 可以在 ContentView 以及它使用的任何其它视图中使用我们创建的环境对象。&lt;/p&gt;

&lt;p&gt;首先，将其添加为 &lt;code&gt;SceneDelegate&lt;/code&gt; 的一个属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var settings = UserSettings() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会创建一个 &lt;em&gt;settings&lt;/em&gt; 实例，并安全地存储它。现在回到刚才展示的那两行代码，并更改第二行，以便将我们的 &lt;em&gt;settings&lt;/em&gt; 属性作为环境对象传递给 &lt;code&gt;ContentView&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;window.rootViewController = UIHostingController(rootView: ContentView().environmentObject(settings))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，共享的 &lt;code&gt;UserSettings&lt;/code&gt; 实例可用于 ContentView 以及它承载（hosts）或展现（presents）的任何其它视图。你只需要使用 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 属性包装器创建一个属性，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@EnvironmentObject var settings: UserSettings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不需要使用默认值进行初始化，因为它将自动从环境中读取。&lt;/p&gt;

&lt;p&gt;因此，我们可以创建一个 &lt;code&gt;ContentView&lt;/code&gt; 结构来增加我们的分数设置，甚至使它呈现出一个显示分数设置的 &lt;code&gt;Detailview&lt;/code&gt;，所有这些都不需要创建或传递任何 &lt;code&gt;UserSettings&lt;/code&gt; 的本地实例 &amp;ndash; 它总是使用环境。&lt;/p&gt;

&lt;p&gt;以下是实现这一目标的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @EnvironmentObject var settings: UserSettings
    
    var body: some View {
        NavigationView {
            VStack {
                Button(action: {
                    self.settings.score += 1
                }) {
                    Text(&amp;quot;Increase score&amp;quot;)
                }
                
                NavigationButton(destination: DetailView()) {
                    Text(&amp;quot;Show Detail View&amp;quot;)
                }
            }
        }
    }
}
​
struct DetailView : View {
    
    @EnvironmentObject var settings: UserSettings
    
    var body: some View {
        // A text view that reads from the environment settings
        Text(&amp;quot;Score: \(settings.score)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，一旦你将一个对象注入到环境中，你就可以立即在顶层视图中或者在下面的十层视图中使用它——这并不重要。最重要的是，每当任何视图改变环境时，依赖它的所有视图都会自动刷新，从而保持同步。&lt;/p&gt;

&lt;p&gt;如你所见，我们不需要将场景代理（scene delegate）中的 &lt;code&gt;UserSettings&lt;/code&gt; 实例与我们两个视图中的 &lt;code&gt;settings&lt;/code&gt; 属性显式关联 - SwiftUI 会自动发现它在环境中有一个 &lt;code&gt;UserSettings&lt;/code&gt; 实例，因此这就是要使用的实例。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;警告：既然我们的视图依赖于存在的环境对象，那么您还必须更新预览代码以提供一些要使用的示例设置。例如，使用 &lt;code&gt;ContentView().EnvironmentObject(UserSettings())&lt;/code&gt; 进行预览应该可以做到这一点。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>4.2_如何使用@ObjectBinding创建对象绑定</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Mon, 29 Jul 2019 00:09:24 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8objectbinding%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-两件重要的事情&#34;&gt;1. 两件重要的事情&lt;/h3&gt;

&lt;p&gt;当使用对象绑定时，我们需要处理两个细微不同的东西:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BindableObject 协议，用于一些可以存储数据的类。&lt;/li&gt;
&lt;li&gt;@ObjectBinding 属性包装器，在视图中用于存储可绑定对象实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;举个例子，这是一个遵循 &lt;code&gt;BindableObject&lt;/code&gt; 协议的 &lt;code&gt;UserSettings&lt;/code&gt; 类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Combine
import SwiftUI

class UserSettings: BindableObject {
    var didChange = PassthroughSubject&amp;lt;Void, Never&amp;gt;()
    
    var score = 0 {
        didSet {
            didChange.send(())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码代码量很小，但是却包含了相当多的知识点，接下来我们逐一解释:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一: &lt;code&gt;didChange&lt;/code&gt;是 &lt;code&gt;PassthroughSubject&lt;/code&gt; 的一个实例。

&lt;ul&gt;
&lt;li&gt;这个类来自 &lt;code&gt;Combine&lt;/code&gt; 框架，我们需要添加 &lt;code&gt;import Combine&lt;/code&gt; 以使我们的代码能够编译。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;passthrough subject&lt;/em&gt; 的工作很简单: 每当我们想要告诉世界我们的对象发生了变化，我们就要求  &lt;em&gt;passthrough subject&lt;/em&gt; 为我们做这件事情。它被称为 &lt;em&gt;pass through&lt;/em&gt; ，因为我们传递给它的值实际上会传递给任何正在观察变化对象的视图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PassthroughSubject&lt;/code&gt; 在技术上被称为 &lt;em&gt;publisher&lt;/em&gt; ，因为它对世界发布了变化的公告。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二: &lt;code&gt;PassthroughSubject&lt;/code&gt; 是 &lt;code&gt;Void&lt;/code&gt; 和 &lt;code&gt;Never&lt;/code&gt; 的泛型。

&lt;ul&gt;
&lt;li&gt;第一个参数 &lt;code&gt;Void&lt;/code&gt; 意味着 &amp;ldquo;&lt;strong&gt;我不发送任何值&lt;/strong&gt;&amp;ldquo;。在 SwiftUI 的情况下，我们不需要发送值，因为我们想要的是视图刷新 - 它将自动从 &lt;code&gt;@ObjectBinding&lt;/code&gt; 状态中获取新数据。&lt;/li&gt;
&lt;li&gt;第二个参数 &lt;code&gt;Never&lt;/code&gt;，意味着 &amp;ldquo;&lt;strong&gt;我永远不会抛出错误&lt;/strong&gt;&amp;ldquo;。如果你想，你可以定义一个自定义的错误类型，如 &lt;code&gt;NetworkError&lt;/code&gt;，并将其发送，但是通常会发现在可绑定对象内部本地处理错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三: 我们在 &lt;code&gt;UserSettings&lt;/code&gt; 的 &lt;em&gt;score&lt;/em&gt; 属性上附加了一个 &lt;code&gt;didSet&lt;/code&gt; 属性观察器，这样我们就可以在该值发生变化时运行代码。 在我们的示例代码中，每当得分发生变化时，我们都会调用 &lt;code&gt;didChange.send(())&lt;/code&gt;，这就是告诉 &lt;code&gt;didChange&lt;/code&gt; 发布者发布我们的数据已更改的消息，以便任何订阅的视图都可以刷新。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以在这样的视图中使用 &lt;code&gt;UserSettings&lt;/code&gt;类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @ObjectBinding var settings = UserSettings()
    
    var body: some View {
        VStack {
            Text(&amp;quot;Your score is \(settings.score)&amp;quot;)
            Button(action: {
                self.settings.score += 1
            }) {
                Text(&amp;quot;Increase Score&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你所看到的，除了使用带有 &lt;code&gt;@ObjectBinding&lt;/code&gt; 属性包装器的 &lt;em&gt;settings&lt;/em&gt; 之外，其他所有内容都或多或少看起来相同 - SwiftUI 负责处理我们的所有实现细节。
但是有一个重要区别: &lt;em&gt;settings&lt;/em&gt; 属性未声明为 &lt;code&gt;private&lt;/code&gt;。 这是因为绑定对象可以被多个视图使用，因此通常会公开共享它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;警告: 当您使用 publisher 宣布您的对象已更改时，这必须在主线程上发生。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>4.1_@ObjectBinding、@State 和 @EnvironmentObject三者之间的区别</title>
      <link>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 28 Jul 2019 22:31:35 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/4-advanced_state/4.1_objectbinding_state_environmentobject%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-state&#34;&gt;1. &lt;code&gt;@State&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在任何现代应用程序中，&lt;strong&gt;状态（State）&lt;/strong&gt;都是不可避免的。&lt;/p&gt;

&lt;p&gt;但是对于 SwiftUI 来说，重要的是要记住:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们所有的视图都只是它们的状态的函数&lt;/li&gt;
&lt;li&gt;我们不会直接改变视图，而是操纵状态并让它决定结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SwiftUI 为我们提供了几种在应用程序中存储状态的方法，但是它们之间略有不同，理解它们之间的区别对于正确使用框架是很重要的。&lt;/p&gt;

&lt;p&gt;到目前为止，在我们所有的状态示例中，我们都使用 &lt;code&gt;@State&lt;/code&gt; 来创建如下属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    @State var score = 0
    // more code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码在视图中创建了一个属性，但它使用 &lt;code&gt;@State&lt;/code&gt; 属性包装器（property wrapper）来请求 SwiftUI 来管理内存。这一点很重要: 我们所有的视图都是结构体（structs），这意味着它们不能被改变，如果我们不能在一场比赛中给一个分数加1，那么这就不是一场比赛了。&lt;/p&gt;

&lt;p&gt;因此，当我们使用 &lt;code&gt;@State&lt;/code&gt; 创建一个属性时，就意味着将该属性的控制权交给了 SwiftUI，这样的话，只要视图存在，它就在内存中保持不变。当该状态发生变化时，SwiftUI 知道用最新的变化自动重新加载视图，以便反映其新信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@State&lt;/code&gt; 对于属于特定视图且从未在该视图之外使用的简单属性非常有用，因此通常最好将这些属性标记为私有属性，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@State private var score = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这再次强化了这样一种观点，即这种状态是专门设计的，永远不会脱离它的视图。简单理解，就是在视图内部使用的。&lt;/p&gt;

&lt;h3 id=&#34;2-objectbinding&#34;&gt;2. &lt;code&gt;@ObjectBinding&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;对于更复杂的属性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当你有一个要使用的自定义类型，该类型可能具有多个属性和方法&lt;/li&gt;
&lt;li&gt;可能在多个视图中共享时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，你应该使用 &lt;code&gt;@ObjectBinding&lt;/code&gt;。
这与 &lt;code&gt;@State&lt;/code&gt; 非常相似，只是现在我们使用的是外部引用类型，而不是简单地本地属性，如字符串或整数。我们仍然可以说视图取决于要更改的数据，除了我们负责管理自己的数据: 我们需要创建类的实例，创建自己的属性，等等。&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;@ObjectBinding&lt;/code&gt; 一起使用的任何类型都应该遵循 &lt;code&gt;BindableObject&lt;/code&gt; 协议，该协议只有一个要求: 您的类型必须实现某种类型的 &lt;code&gt;didchange&lt;/code&gt; 属性，该属性在数据发生更改时通知视图。&lt;/p&gt;

&lt;p&gt;这就是我的意思，当我说这是你负责管理自己的数据时——当你在绑定对象上设置一个属性时，你就可以决定是否应该强制视图刷新。你通常会的，但不是必须的。&lt;/p&gt;

&lt;p&gt;一个可绑定的对象可以使用 &lt;code&gt;Combine&lt;/code&gt; 框架中 &lt;em&gt;publisher&lt;/em&gt;  通知其视图重要数据已经更改。如果碰巧有几个视图使用可绑定对象的数据，那么它将自动通知所有这些视图。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;警告:&lt;/strong&gt; 当你使用 &lt;em&gt;publisher&lt;/em&gt; 宣布你的对象已更改，这个动作必须在主线程上执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;3-environmentobject&#34;&gt;3. &lt;code&gt;@EnvironmentObject&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们已经了解了如何通过 &lt;code&gt;@State&lt;/code&gt; 声明一个类型的简单属性，该类型数据在发生更改时自动导致视图更新，以及如何通过 &lt;code&gt;@Objectbinding&lt;/code&gt; 声明外部类型的属性，该属性在更改时可能会或可能不会导致视图更新。这两个都必须由我们的视图设置，但是 &lt;code&gt;@Objectbinding&lt;/code&gt; 可能与其他视图共享。&lt;/p&gt;

&lt;p&gt;针对这种情况，我们还有第三种类型的属性可供使用，即 &lt;code&gt;@EnvironmentObject&lt;/code&gt;。这是一个通过应用程序本身对视图可用的值 -&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它是每个视图都可以读取的共享数据，因此，如果你的应用程序有一些重要的模型数据，所有视图都需要读取，你可以把它从一个视图传递到另一个视图，或者把它放到每个视图都可以即时访问的环境中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们需要在应用程序中传递大量数据时，可以将 &lt;code&gt;@Environmentobject&lt;/code&gt; 视为一种极大的便利。由于所有视图都指向同一模型，因此如果一个视图更改模型，则所有视图都会立即更新 - 不会有使应用程序的不同部分不同的风险。&lt;/p&gt;

&lt;h3 id=&#34;4-总结差异&#34;&gt;4. 总结差异&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;@State&lt;/code&gt; 用于属于单个视图的简单属性。 它们通常应标记为 &lt;code&gt;private&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;@ObjectBinding&lt;/code&gt; 用于可能属于多个视图的复杂属性。 无论何时使用引用类型，都应该使用&lt;code&gt;@ObjectBinding&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;@EnvironmentObject&lt;/code&gt; 用于在应用程序中其他位置创建的属性，例如共享数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这三种方法中，您会发现 &lt;code&gt;@objectbinding&lt;/code&gt; 是最有用和最常用的，因此如果您不确定要使用哪种方法，请从那里开始。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.14_如何响应视图生命周期事件_appear_and_disappear</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/</link>
      <pubDate>Sun, 28 Jul 2019 20:37:20 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.14_%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E8%A7%86%E5%9B%BE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6_appear_and_disappear/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 以 &lt;code&gt;onAppear()&lt;/code&gt; 和 &lt;code&gt;onDisappear()&lt;/code&gt; 的形式为我们提供了 UIKit 的&lt;code&gt;viewDidAppear()&lt;/code&gt; 和 &lt;code&gt;viewDidDisappear()&lt;/code&gt; 的等价物。 您可以将任何代码附加到您想要的这两个事件，SwiftUI 将在它们发生时执行它们。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;注意：在当前的beta版本， onAppear() 工作得很好，但 onDisappear() 似乎没有被调用。
例如: 我们创建两个使用 onAppear() 和 onDisappear() 来打印消息的视图，并使用导航按钮在两者之间移动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView()) {
                Text(&amp;quot;Hello World&amp;quot;)
            }
        }.onAppear {
            print(&amp;quot;ContentView appeared!&amp;quot;)
        }.onDisappear {
            print(&amp;quot;ContentView disappeared!&amp;quot;)
        }
    }
}

struct DetailView : View {
    var body: some View {
        VStack {
            Text(&amp;quot;Second View&amp;quot;)
        }.onAppear {
            print(&amp;quot;DetailView appeared!&amp;quot;)
        }.onDisappear {
            print(&amp;quot;DetailView disappeared!&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_14_live_event_appear_disappear.gif&#34; alt=&#34;3_14_live_event_appear_disappear&#34; title=&#34;onAppear and onDisappear&#34; /&gt;
当代码运行时，我们应该能够在两个视图之间移动，并看到 Xcode 调试控制台中打印的消息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.13_如何给视图添加手势识别器</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/</link>
      <pubDate>Sun, 28 Jul 2019 19:59:32 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.13_%E5%A6%82%E4%BD%95%E7%BB%99%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;任何 SwiftUI  视图都可以附加手势识别器，而这些手势识别器又可以附加闭包，在识别器被激活时执行闭包。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;有几个手势识别器可供使用，这里我们提供其中几个的代码示例，以帮助入门 - 我们将看到它们有多相似。&lt;/p&gt;

&lt;h4 id=&#34;2-1-tapgesture-点击手势&#34;&gt;2.1 &lt;code&gt;TapGesture&lt;/code&gt; 点击手势&lt;/h4&gt;

&lt;p&gt;创建 TapGesture 时，可以指定触发手势所需的 点击次数，然后附加将在手势发生时运行的 &lt;code&gt;onEnded&lt;/code&gt; 闭包。&lt;/p&gt;

&lt;p&gt;例如，我们来创建一个每次点击时都会变大的图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var scale: Length = 1
    
    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .scaleEffect(scale)
            .gesture(
                TapGesture()
                    .onEnded({ (_) in
                        self.scale += 0.1
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_13_tap_gesture_scale_image.gif&#34; alt=&#34;3_13_tap_gesture_scale_image&#34; title=&#34;Tap to scale a image&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-2-longpressgesture-长按手势&#34;&gt;2.2 &lt;code&gt;LongPressGesture&lt;/code&gt; 长按手势&lt;/h4&gt;

&lt;p&gt;LongPressGesture 可识别用户何时按下视图并保持至少一段用户指定的时间。
因此，我们创建一个图像视图，在按下该消息至少两秒时打印该消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {

    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .gesture(
                LongPressGesture(minimumDuration: 2.0)
                    .onEnded({ (_) in
                            print(&amp;quot;LongPressed!&amp;quot;)
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/3_13_long_press_gesture_duration_2s.gif&#34; alt=&#34;3_13_long_press_gesture_duration_2s&#34; title=&#34;Long pressed!&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-3-draggesture-拖拽手势&#34;&gt;2.3 &lt;code&gt;DragGesture&lt;/code&gt; 拖拽手势&lt;/h4&gt;

&lt;p&gt;最后，当用户按下视图并移动至少一定距离时，DragGesture 会触发。因此，我们创建一个带有拖动手势的图像，当它们移动至少50个点时会触发:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
 
    var body: some View {
        Image(&amp;quot;example-image&amp;quot;)
            .gesture(
                DragGesture(minimumDistance: 50)
                    .onEnded({ (_) in
                        print(&amp;quot;Dragged!&amp;quot;)
                    })
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;img/3_13_drag_gesture_distance_50.gif&#34; alt=&#34;3_13_drag_gesture_distance_50&#34; title=&#34;Drag gesture&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.12_如何设置tap和double Tap手势</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/</link>
      <pubDate>Sun, 28 Jul 2019 18:38:38 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.12_%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEtap%E5%92%8Cdouble-tap%E6%89%8B%E5%8A%BF/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;任何 SwiftUI 视图都可以附加 &lt;code&gt;点击操作(tap action)&lt;/code&gt;，我们可以指定在触发操作之前应该接收多少次点击。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个文本视图，在点击时将打印消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        Text(&amp;quot;Tap me!&amp;quot;)
            .tapAction {
                print(&amp;quot;Tapped&amp;quot;)
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/tap_gesture_tap_text.gif&#34; alt=&#34;tap_gesture_tap_text&#34; title=&#34;Tap a text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再创建一个图像视图，当双击时将打印消息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    var body: some View {
        Image(&amp;quot;example-img&amp;quot;)
            .tapAction(count: 2) {
                print(&amp;quot;Double tapped!&amp;quot;)
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/tap_gesture_double_tap_image.gif&#34; alt=&#34;tap_gesture_double_tap_image&#34; title=&#34;Double tapped!&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.11_如何创建分段控件并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 10:16:45 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.11_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI中 的 &lt;code&gt;SegmentedControl&lt;/code&gt; 与 UIKit中的 &lt;code&gt;UISegmentedControl&lt;/code&gt; 的工作方式类似，但是它需要绑定到某种状态（state），并且必须确保为每个分段（segment）提供一个 tag 标记，以便能够识别它。&lt;strong&gt;分段(Segments) 可以是文本或者图片，其它任何东西都会自动失败&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;我们将创建一个分段控件，该控件使用 &lt;code&gt;favoriteColor&lt;/code&gt; 作为状态属性，并且在下面添加一个文本视图，用于显示所选的任何值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var favoriteColor = 0
    
    var body: some View {
        VStack {
            SegmentedControl(selection: $favoriteColor) {
                Text(&amp;quot;Red&amp;quot;).tag(0)
                Text(&amp;quot;Green&amp;quot;).tag(1)
                Text(&amp;quot;Blue&amp;quot;).tag(2)
            }
            Text(&amp;quot;Value: \(favoriteColor)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/segmented_control_favoritecolor.gif&#34; alt=&#34;segmented_control_favoritecolor&#34; title=&#34;Select a favorite color&#34; /&gt;
不过，在本例中，我们最好创建一个数组来存储各种颜色，然后使用 &lt;em&gt;foreach&lt;/em&gt; 在内部使用循环创建文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State private var favoriteColor = 0

    var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        VStack {
            SegmentedControl(selection: $favoriteColor) {
                ForEach(0..&amp;lt;colors.count) { index in
                    Text(self.colors[index]).tag(index)
                }
            }
            Text(&amp;quot;Value: \(colors[favoriteColor])&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/segmented_control_favoritecolor_string.gif&#34; alt=&#34;segmented_control_favoritecolor_string&#34; title=&#34;select a favorite color, display with string&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.10_如何创建DatePicker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sun, 28 Jul 2019 00:28:44 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.10_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdatepicker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-初识&#34;&gt;1. 初识&lt;/h3&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;DatePicker&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UIDatePicker&lt;/code&gt;，它提供了各种选项来控制它的外观和工作方式。和所有存储值的控件一样，它也需要绑定到应用程序中的某种状态。&lt;/p&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到 &lt;code&gt;birthDate&lt;/code&gt; 属性的日期选择器，然后显示日期选择器的值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        return formatter
    }
    
    @State var birthDate = Date()
    
    var body: some View {
        VStack {
            DatePicker($birthDate,
                       maximumDate: Date(),
                       displayedComponents: .date)
            Text(&amp;quot;Date is \(birthDate, formatter: dateFormatter)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/datepicker_select_birthdate.gif&#34; alt=&#34;datepicker_select_birthdate&#34; title=&#34;Select birth date&#34; /&gt;
可以看到我已经将 &lt;strong&gt;DisplayedComponents&lt;/strong&gt; 设置为 .Date，但您也可以使用 &lt;code&gt;.hourAndMinute&lt;/code&gt;来获取时间数据。
我还使用 &lt;em&gt;maximumDate&lt;/em&gt; 来阻止人们在将来指定出生日期，但是您可以指定 &lt;em&gt;minimumDate&lt;/em&gt; 来阻止人们指定早于您选择的日期。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.9_如何创建选择器Picker并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:56:24 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.9_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8picker%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Picker&lt;/code&gt; 视图将 UIPicker 和 UITableView 结合在一起。同时也适应其它操作系统上的其它样式。最棒的是我们真的不需要关系它是如何工作的 &amp;ndash; SwiftUI 可以很好的自动适应它的环境。
与大多数其它控件一样，必须将 picker 附加到某种 state，以跟踪 picker 的选择。例如: 这会创建一个 colors 数组和一个存储所选颜色的整数，然后将其与 picker，Text 视图一起使用，以便您可以看到正在读取的值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Orange&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Green&amp;quot;]
    @State private var selectedColor = 0
    
    var body: some View {
        VStack {
            Picker(selection: $selectedColor, label: Text(&amp;quot;Please choose a color&amp;quot;)) {
                ForEach(0..&amp;lt;colors.count) {
                    Text(self.colors[$0]).tag($0)
                }
            }
            Text(&amp;quot;You selected: \(colors[selectedColor]) &amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/picker_select_color.gif&#34; alt=&#34;picker_select_color&#34; title=&#34;Selected color&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意: 将选择器视图放在某个内容中非常重要，以确保它在iOS上以默认的轮子样式显示。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.8_如何创建Slider并从中读取值</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</link>
      <pubDate>Sat, 27 Jul 2019 23:40:23 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.8_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAslider%E5%B9%B6%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;Slider&lt;/code&gt; 视图的工作原理与 &lt;code&gt;UISlider&lt;/code&gt; 非常相似，尽管您需要将其绑定到某个地方，以便存储其值。
当我们创建它时，可以提供多种参数，但我们可能最关心的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Value&lt;/code&gt;:  要绑定到的值是多少&lt;/li&gt;
&lt;li&gt;&lt;code&gt;From and To&lt;/code&gt;: 滑块的范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;By&lt;/code&gt;: 移动滑块时要更改多少值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-示例&#34;&gt;2. 示例&lt;/h3&gt;

&lt;p&gt;例如: 我们创建一个绑定到  Celsius 属性的滑块，然后在滑块移动时更新文本视图，以便在 &lt;strong&gt;Celsius(摄氏温度)&lt;/strong&gt; 和 &lt;strong&gt;Fahrenheit(华氏温度)&lt;/strong&gt; 之间进行转换:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var celsius: Double = 0
    
    var body: some View {
        VStack {
            Slider(value: $celsius, from: -100, through: 100, by: 0.1)
                .padding()
            Text(&amp;quot;\(celsius) Celsius is \(celsius * 9 / 5 + 32) Fahrenheit&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/slider_celsius_to_fahrenheit.gif&#34; alt=&#34;slider_celsius_to_fahrenheit&#34; title=&#34;celsius to fahrenheit&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.7_如何使用SecureField创建一个安全的文本输入框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 23:33:00 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.7_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8securefield%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;SecureField&lt;/code&gt; 与常规的 &lt;code&gt;TextField&lt;/code&gt; 的工作原理几乎相同，不同之处在于，出于保护隐私的目的而屏蔽了文本框中的字符。当然，将其绑定到的基础值仍然是一个纯字符串，因此我们可以根据需要进行检查。&lt;/p&gt;

&lt;p&gt;这里有一个示例，创建了一个绑定到本地 &lt;code&gt;@State&lt;/code&gt;  属性的 &lt;code&gt;SecureField&lt;/code&gt;，以便我们可以显示键入文本框中的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var password: String = &amp;quot;&amp;quot;
    var body: some View {
        VStack {
            SecureField(&amp;quot;Enter your password&amp;quot;, text: $password)
                .padding()
                .textFieldStyle(RoundedBorderTextFieldStyle())
            Text(&amp;quot;You entered: \(password)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/3.7_securefield_enter_password.gif&#34; alt=&#34;3.7_securefield_enter_password.gif&#34; title=&#34;Enter a password&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.6_如何给TextField添加占位符</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</link>
      <pubDate>Sat, 27 Jul 2019 22:59:59 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.6_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E5%8D%A0%E4%BD%8D%E7%AC%A6/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 支持占位符文本，就像 &lt;code&gt;UITextField&lt;/code&gt; 一样 &amp;ndash; 当 TextField 为空时在 TextField 中显示灰色文本。要么使用提示（&amp;rdquo;Enter your password&amp;rdquo;），要么显示一些示例数据。&lt;/p&gt;

&lt;p&gt;要设置 placeholder，请将其作为 TextField 初始化设置的一部分传入，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var emailAddress = &amp;quot;&amp;quot;
    var body: some View {
        TextField(&amp;quot;test@gmail.com&amp;quot;, text: $emailAddress)
            .padding()
            .textFieldStyle(RoundedBorderTextFieldStyle())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/3.6_textfield_placeholder.png&#34; alt=&#34;3.6_textfield_placeholder&#34; title=&#34;Set a placeholder for text field&#34; /&gt;
这将在 TextField 中显示占位文本 &lt;code&gt;test@gmail.com&lt;/code&gt;，而 TextField 为空，但一旦用户在其中键入内容，占位文本就会消失。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.5_如何给TextField添加边框</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</link>
      <pubDate>Sat, 27 Jul 2019 22:42:34 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.5_%E5%A6%82%E4%BD%95%E7%BB%99textfield%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图默认没有样式，这意味着在屏幕上它是一个空白区域。如果这样就符合你想要的风格，那就太好了，你已经完成了。但是，我们大多时候更希望在 &lt;code&gt;TextField&lt;/code&gt; 周围添加边框，以使其更清晰。&lt;/p&gt;

&lt;p&gt;如果想获得我们习惯使用的 UITextField 的圆角矩形样式，我们应该使用 &lt;code&gt;.textFieldStyle(RoundedBorderTextFieldStyle())&lt;/code&gt; 修饰符，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    @State private var name = &amp;quot;&amp;quot;
    var body: some View {
        TextField(&amp;quot;Enter your name&amp;quot;, text: $name)
            .padding()
            .textFieldStyle(RoundedBorderTextFieldStyle())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/3.5_textfield_style_rounded_border.png&#34; alt=&#34;3.5_textfield_style_rounded_border&#34; title=&#34;textFieldStyle is roundedBorder style&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.4_如何从TextField中读取文本</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</link>
      <pubDate>Sat, 27 Jul 2019 21:42:21 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.4_%E5%A6%82%E4%BD%95%E4%BB%8Etextfield%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;TextField&lt;/code&gt; 视图类似于 UIkit 中的 &lt;code&gt;UITextField&lt;/code&gt;，但是，在默认情况下 &lt;code&gt;TextField&lt;/code&gt; 看起来有点不同，并且它非常依赖于 &lt;strong&gt;状态绑定（binding to state）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-创建-textfield&#34;&gt;2. 创建 TextField&lt;/h3&gt;

&lt;p&gt;那么，要创建一个 TextField，我们应该给在 &lt;em&gt;text field&lt;/em&gt; 传入一个 &lt;code&gt;placeholder&lt;/code&gt;，再加上它应该绑定到的状态属性。&lt;/p&gt;

&lt;p&gt;例如: 现在，我们要创建一个 &lt;strong&gt;绑定到本地字符串的 TextField&lt;/strong&gt;，然后在其下面放置一个文本视图，在键入时显示 TextField 的输出:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var name = &amp;quot;&amp;quot;
    
    var body: some View {
        VStack {
            TextField(&amp;quot;Enter your name&amp;quot;, text: $name)
            Text(&amp;quot;Hello, \(name)&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后，我们应该能够在 TextField 中输入文字，并在下面直接看到一条问候语。
运行效果:
&lt;img src=&#34;img/3.4_textfield_enter_your_name.gif&#34; alt=&#34;3.4_textfield_enter_your_name&#34; title=&#34;Enter your name&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用 TextField 时有两个重要的限制条件:&lt;/p&gt;

&lt;p&gt;首先，默认情况下，它没有边框，因此我们可能看不到任何内容 &amp;ndash; 我们需要大致点击其所在位置，以激活键盘。
其次，我们可能会发现无法在布局的画布预览中键入内容。如果遇到这个问题，请按 Cmd+R 在模拟器中构建和运行代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.3_如何创建一个可点击的按钮</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</link>
      <pubDate>Sat, 27 Jul 2019 16:21:22 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.3_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84%E6%8C%89%E9%92%AE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-button-vs-uibutton&#34;&gt;1. Button vs UIButton&lt;/h3&gt;

&lt;p&gt;SwiftUI 的 &lt;code&gt;按钮(Button)&lt;/code&gt; 类似于 UIKit 中的 &lt;code&gt;UIButton&lt;/code&gt;，跟 UIButton 的区别在于:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在显示内容方面 SwiftUI 的按钮更为灵活&lt;/li&gt;
&lt;li&gt;SwiftUI 的按钮使用 &lt;code&gt;闭包&lt;/code&gt; 来实现其 action，而 UIButton 使用的是旧的 &lt;code&gt;target/action&lt;/code&gt; 系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-button-初体验&#34;&gt;2. Button 初体验&lt;/h3&gt;

&lt;p&gt;那么，如何创建一个 SwiftUI 的按钮呢?，我们可以从以下代码开始:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 创建一个 SwiftUI 按钮
        Button(action: {
            // your action here
        }, label: {
            Text(&amp;quot;Button title&amp;quot;)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由以上代码可以看到，创建 Button 的的方法有两个参数，都是闭包，第一个闭包负责传入 action，第二个闭包负责传入按钮上的文本。&lt;/p&gt;

&lt;h3 id=&#34;3-button-简单用例&#34;&gt;3. Button 简单用例&lt;/h3&gt;

&lt;p&gt;例如: 我们可以创建一个按钮，在点击按钮时显示或隐藏一些详细信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showDetails = false
    
    var body: some View {
        
        // 2. 点击按钮，显示或隐藏详细信息
        VStack {
            Button(action: {
                self.showDetails.toggle()
            }, label: {
                Text(&amp;quot;Show details&amp;quot;)
            })
            
            if showDetails {
                Text(&amp;quot;You should follow me on https://coderxdlee.github.io/&amp;quot;)
                    .font(.largeTitle)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/3.3_button_show_detail_information.gif&#34; alt=&#34;3.3_button_show_detail_information&#34; title=&#34;Click button to show detail information&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-提示&#34;&gt;4. 提示&lt;/h3&gt;

&lt;p&gt;在学习框架时，最常做的事情是分散调用 &lt;code&gt;print()&lt;/code&gt;，这样我们就可以看到什么时候发生了什么事情。 如果我们想通过按钮 action 来尝试，首先应右键单击预览画布中的播放按钮，然后选择 &lt;strong&gt;调试预览&lt;/strong&gt;，以便调用 &lt;code&gt;print()&lt;/code&gt; 工作。
按钮内的标题可以是任何类型的视图，因此您可以创建这样的图像按钮:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showDetails = false
    
    var body: some View {
        // 2. 点击按钮，显示或隐藏详细信息
        VStack {
            Button(action: {
                self.showDetails.toggle()
            }, label: {
                Image(&amp;quot;example-image&amp;quot;)
            })
            
            if showDetails {
                Text(&amp;quot;You should follow me on https://coderxdlee.github.io/&amp;quot;)
                    .font(.largeTitle)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/3.3_button_image_show_detail.gif&#34; alt=&#34;3.3_button_image_show_detail&#34; title=&#34;Set an image for button&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.2_如何创建 Toggle</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAtoggle/</link>
      <pubDate>Sat, 27 Jul 2019 15:55:42 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.2_%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAtoggle/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 中的 &lt;code&gt;toggle&lt;/code&gt; 允许用户在 &lt;strong&gt;true&lt;/strong&gt; 和 &lt;strong&gt;false&lt;/strong&gt; 的状态之间进行切换，就像 UIKit 中的 &lt;code&gt;UISwitch&lt;/code&gt; 一样。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;我们可以创建一个 &lt;em&gt;toggle&lt;/em&gt; ，然后根据是否启用 &lt;em&gt;toggle&lt;/em&gt; 来决定显示或者不显示消息。但是我们不希望手动跟踪 &lt;em&gt;toggle&lt;/em&gt; 的状态 &amp;ndash; 我们希望 SwiftUI 为我们做这件事。&lt;/p&gt;

&lt;p&gt;与以往不同，在这里，我们应该定义一个 &lt;code&gt;@State Boolean&lt;/code&gt; 属性，用于存储 toggle 的当前值。然后我们可以根据需要使用它来显示或隐藏其它视图。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @State private var showGreeting: Bool = true
    
    var body: some View {
        VStack {
            Toggle(isOn: $showGreeting) {
                Text(&amp;quot;Show welcome message&amp;quot;)
            }.padding()
            
            if showGreeting {
                Text(&amp;quot;Hello world!&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/3.2_how_to_create_a_toggle.gif&#34; alt=&#34;3.2_how_to_create_a_toggle&#34; title=&#34;Show welcome message&#34; /&gt;
这段代码，只有当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;true&lt;/em&gt; 时才会返回文本视图，这意味着当 &lt;code&gt;showGreeting&lt;/code&gt; 为 &lt;em&gt;false&lt;/em&gt; 时，&lt;code&gt;VStack&lt;/code&gt; 的大小会减小 - 它的堆栈中没有第二个视图。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 使用 &lt;code&gt;@State&lt;/code&gt; 时，Apple建议我们使用 &lt;code&gt;private&lt;/code&gt; 访问控制修饰符标记属性，以明确表明此状态属于本地视图，而不在其他地方使用。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>3.1_使用 state</title>
      <link>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</link>
      <pubDate>Fri, 26 Jul 2019 22:48:19 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/3-responding_to_events/3.1_%E4%BD%BF%E7%94%A8state/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-概念&#34;&gt;1. 概念&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;所有应用程序都会更改状态。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户点击了一个按钮来显示更多信息&lt;/li&gt;
&lt;li&gt;用户在文本框中输入了一些文本&lt;/li&gt;
&lt;li&gt;用户从日期选择器中选择了一个日期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有涉及应用程序 &lt;strong&gt;从一种状态转变到另一种状态&lt;/strong&gt; 的事情，都叫做应用程序更改状态。&lt;/p&gt;

&lt;h3 id=&#34;2-问题所在&#34;&gt;2. 问题所在&lt;/h3&gt;

&lt;p&gt;状态的问题在于它是混乱的: &lt;strong&gt;当它发生变化时，我们需要发现变化并更新我们的布局来匹配变化&lt;/strong&gt;。 这个一开始听起来可能很简单，但是随着我们的状态不断增长，它就会变得越来越难 - 因为这个时候，我们很容易忘记更新一件事，或者更新顺序出错，以致于用户界面状态达不到预期效果。&lt;/p&gt;

&lt;h3 id=&#34;3-swiftui-如何破解&#34;&gt;3. SwiftUI 如何破解？&lt;/h3&gt;

&lt;p&gt;SwiftUI 通过 &lt;strong&gt;从控件中移除状态&lt;/strong&gt; 来解决这个问题。&lt;/p&gt;

&lt;p&gt;当我们向视图添加属性时，这些属性实际上是惰性的 - 当然，它们有值，但是更改这些值不会有任何作用。 但是如果我们在这些属性之前添加了特殊的&lt;code&gt;@State&lt;/code&gt; 来包装属性，SwiftUI 将自动监视属性变化并更新使用该状态的视图的任何部分。&lt;/p&gt;

&lt;p&gt;示例代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@state var name: String = &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;code&gt;@state&lt;/code&gt; 这种语法称为 属性包装器，这里不作详细介绍，可以自行查找文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当涉及到某种状态时 - 例如，当切换开关（toggle switch）改变时告诉状态属性改变。
&lt;strong&gt;这里需要注意的是&lt;/strong&gt;: 我们不能直接引用这个属性。这是因为 Swift 会认为我们现在所指的是&lt;code&gt;&amp;quot;属性当前的值&amp;quot;&lt;/code&gt;，而不是说 &lt;code&gt;&amp;quot;请注意这件事情(属性状态变化)&amp;quot;&lt;/code&gt;。幸运的是，SwiftUI 的解决方案是在属性名称前放置一个&lt;code&gt;美元符号($)&lt;/code&gt;，这样的话，我们就可以引用属性本身而不是它当前的值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当然，这里一开始理解起有点令人困惑，但在当我们学习一两个示例之后就会理解，非常简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，请记住，SwiftUI 是声明性的，这意味着我们预先将所有可能状态的所有布局都告诉了它，并让它知道当属性发生变化时如何在它们之间移动。我们称之为 &lt;strong&gt;&lt;em&gt;绑定（binding）&lt;/em&gt;&lt;/strong&gt; - 要求 SwiftUI 同步 UI 控件和基础属性之间的更改。
如果你已经习惯了一种更强制性的编程风格，那么使用 state 一开始会让你感到头疼，但是请相信我 - 一旦你了解了它，一切都会一帆风顺。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.13_如何将视图放到安全区域之外</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.13_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</link>
      <pubDate>Fri, 26 Jul 2019 22:12:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.13_%E5%A6%82%E4%BD%95%E5%B0%86%E8%A7%86%E5%9B%BE%E6%94%BE%E5%88%B0%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%A4%96/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;默认情况下，我们的 SwiftUI 视图将主要位于安全区域内 - 它将会到达屏幕底部，但不会靠近设备顶部的任何凹口。
如果我们想改变它 - 想让视图真正全屏，即使这意味着被一个缺口或其他硬件切口部分遮挡 - 那么我们应该使用 &lt;code&gt;edgesIgnoringSafeArea()&lt;/code&gt; 修饰符。
例如，这会创建一个红色文本视图，要求填充所有可用空间，然后将其设置为忽略任何安全区域，以使其真正边缘化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // edgesIgnoringSafeArea
        Text(&amp;quot;Hello World&amp;quot;)
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)
            .background(Color.red)
            .edgesIgnoringSafeArea(.all)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/2.13_edgesIgnoringSafeArea.png&#34; alt=&#34;2.13_edgesIgnoringSafeArea&#34; title=&#34;edgesIgnoringSafeArea all&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.10_如何使用size_classes创建不同的布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.10_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 26 Jul 2019 16:52:17 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.10_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8size_classes%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;SwiftUI 通过在环境中暴露 &lt;em&gt;size classes&lt;/em&gt; 来原生支持它。如果要使用它，我们首先需要创建一个 &lt;code&gt;@Environment&lt;/code&gt; 对象来存储其值，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Environment(\.horizontalSizeClass) var horizontalSizeClass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以根据需要检查该属性的值，查找 &lt;code&gt;.compact&lt;/code&gt; 或 &lt;code&gt;.regular&lt;/code&gt;，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if horizontalSizeClass == .compact {
    return Text(&amp;quot;Compact&amp;quot;)
} else {
    return Text(&amp;quot;Regular&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将所有代码组合在一起，可以创建这样的视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    @Environment(\.horizontalSizeClass) var horizontalSizeClass
    
    var body: some View {
        if horizontalSizeClass == .compact {
            return Text(&amp;quot;Compact&amp;quot;)
        } else {
            return Text(&amp;quot;Regular&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:&lt;/p&gt;

&lt;p&gt;(1) 正向竖屏
&lt;img src=&#34;img/2.10_size_classes_compact.png&#34; alt=&#34;2.10_size_classes_compact&#34; title=&#34;Text - Compact&#34; /&gt;
(2) 横屏 - 刘海在右侧
&lt;img src=&#34;img/2.10_size_classes_regular01.png&#34; alt=&#34;2.10_size_classes_regular01&#34; title=&#34;Text - Regular01&#34; /&gt;
(3) 横屏 - 刘海在左侧
&lt;img src=&#34;img/2.10_size_classes_regular02.png&#34; alt=&#34;2.10_size_classes_regular02&#34; title=&#34;Text - Regular02&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SizeClass 是通过将 VStack 或 HStack 用于内容来使用户界面智能地适应可用空间的好方法。 例如，如果我们有很多空间，则可以水平放置东西，但在空间有限时切换到垂直布局。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.9_如何使用ForEach在循环中创建视图</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Fri, 26 Jul 2019 00:21:40 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8foreach%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</guid>
      <description>

&lt;p&gt;通常，我们会发现，我们需要遍历一个序列来创建视图，而在 SwiftUI 中，这是通过 &lt;code&gt;ForEach&lt;/code&gt; 来完成的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;:
我们很容易一看到 &lt;em&gt;ForEach&lt;/em&gt; 就认为它与 Swift 序列中的 &lt;em&gt;forEach()&lt;/em&gt; 方法相同，但事实并非如此。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SwiftUI 中的 &lt;code&gt;ForEach&lt;/code&gt; 本身是一个视图结构，这就意味着我们可以根据需要直接从视图 &lt;em&gt;Body&lt;/em&gt; 返回它。&lt;/li&gt;
&lt;li&gt;我们为它提供一系列项目，可能还需要告诉 SwiftUI 它如何唯一地标识每个项目，以便 SwiftUI 知道如何在值更改时更新它们。&lt;/li&gt;
&lt;li&gt;我们还传递一个要运行的闭包，来为循环中的每个项目创建一个视图。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于范围内的简单循环，我们可以将范围直接传递到 ForEach 中，并告诉 Swift 将每个数字用作项目的唯一标识符。&lt;/p&gt;

&lt;h3 id=&#34;1-循环-1-10-创建文本视图&#34;&gt;1. 循环 1&amp;hellip;10 创建文本视图&lt;/h3&gt;

&lt;p&gt;例如，这从10减少到1，然后在最后添加一条消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 循环 1...10 创建文本视图
        VStack(alignment: .leading) {
            ForEach((1...10).reversed(), id: \.self, content: {
                Text(&amp;quot;\($0)...&amp;quot;)
            })
            
            Text(&amp;quot;Ready or not, here I come!&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.9_foreach_create_text_views.png&#34; alt=&#34;2.9_foreach_create_text_views&#34; title=&#34;Create text views using ForEach&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.id(: \.self)&lt;/code&gt; 部分是必需的，这样 SwiftUI 可以唯一地标识数组中的每个元素——这意味着，如果添加或删除一个项，SwiftUI 可以确切地知道是哪一个。&lt;/p&gt;

&lt;h3 id=&#34;2-foreach-colors&#34;&gt;2. ForEach colors&lt;/h3&gt;

&lt;p&gt;我们可以使用这种方法来创建任何类型的循环。 例如，此代码创建一个由三种颜色组成的数组，将它们全部循环，并使用每种颜色名称和颜色值创建文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    
    let colors: [Color] = [.red, .green, .blue]
    
    var body: some View {
        // 2. ForEach colors
        VStack {
            ForEach(colors, id: \.self) { color in
                Text(color.description.capitalized)
                    .padding()
                    .background(color)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.9_foreach_colors_array.png&#34; alt=&#34;2.9_foreach_colors_array&#34; title=&#34;foreach colors&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;\.self&lt;/code&gt; 告诉 Swift，每个项目都使用其自己的值进行唯一标识。 因此，如果我们有数组 [1、2、3] 并通过 &lt;code&gt;\.self&lt;/code&gt; 标识每个值，则意味着第一项具有标识符1，第二个2 和 第三个3。&lt;/p&gt;

&lt;h3 id=&#34;3-foreach-custom-type&#34;&gt;3. ForEach custom type&lt;/h3&gt;

&lt;p&gt;如果数组中有自定义类型，则应使用  &lt;code&gt;.id:&lt;/code&gt; 类型内的任何属性对其进行唯一标识。
例如，这是一个存储测试结果的结构，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Result {
    var id = UUID()
    var score: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它有一个带有 &lt;code&gt;UUID&lt;/code&gt; 的 &lt;code&gt;id&lt;/code&gt; 属性，这意味着它保证是唯一的 - 对于我们的目的而言是完美的。 如果我们要遍历结果数组，创建一个文本视图以显示 &lt;code&gt;VStack&lt;/code&gt; 中每个结果，那么我们可以使用以下方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {

    let results = [Result(score: 8), Result(score: 5), Result(score: 10)]
    
    var body: some View {
        // 3. ForEach custom type
        VStack {
            ForEach(results, id: \.id, content: { result in
                Text(&amp;quot;Result: \(result.score)&amp;quot;)
            })
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.9_foreach_custom_type.png&#34; alt=&#34;2.9_foreach_custom_type&#34; title=&#34;ForEach custom type&#34; /&gt;
这告诉 SwiftUI 它可以通过查看它们的 &lt;code&gt;id&lt;/code&gt; 属性来区分 &lt;code&gt;ForEach&lt;/code&gt; 中的视图。&lt;/p&gt;

&lt;p&gt;或者，如果使 Result 符合 &lt;code&gt;Identifiable&lt;/code&gt; 协议，则只需编写 &lt;code&gt;ForEach(results)&lt;/code&gt;。 遵守该协议意味着添加一个 id 属性，该属性唯一地标识每个对象，在我们的情况下，我们已经拥有了它。 因此，此代码实现了相同的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Result: Identifiable {
    var id = UUID()
    var score: Int
}

struct ContentView: View {
    let results = [Result(score: 8), Result(score: 5), Result(score: 10)]

    var body: some View {
        VStack {
            ForEach(results) { result in
                Text(&amp;quot;Result: \(result.score)&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>2.8_如何返回不同的视图类型</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 25 Jul 2019 13:47:21 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.8_%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B/</guid>
      <description>

&lt;p&gt;当我们从视图的 body 返回 &lt;code&gt;some View&lt;/code&gt; 的时候，Swift 会理解为这意味着我们拥有一个特定的返回类型。&lt;/p&gt;

&lt;p&gt;例如: 如果我们想掷硬币并显示 &amp;ldquo;你赢了!&amp;ldquo;的图像，或是一些文字，表示 &amp;ldquo;下次运气更好&amp;rdquo;， 那么我们不能这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    if Bool.random() {
        Image(&amp;quot;example-image&amp;quot;)
    } else {
        Text(&amp;quot;Better luck next time&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码会报错:
&lt;img src=&#34;img/2.8_error_return_view_type.png&#34; alt=&#34;2.8_error_return_view_type&#34; title=&#34;Compilation error&#34; /&gt;
因为它可能返回 &lt;em&gt;Image&lt;/em&gt; 或者 &lt;em&gt;Text&lt;/em&gt; ，这是不允许的 &amp;ndash;  我们&lt;code&gt;必须精确返回一种类型&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有两种方法可以解决这个问题。&lt;/p&gt;

&lt;h3 id=&#34;1-group&#34;&gt;1. Group&lt;/h3&gt;

&lt;p&gt;第一种方法是将输出包装在一个 &lt;code&gt;group&lt;/code&gt; 中，这样无论我们发送图像视图还是文本视图，它们都将返回到一个 &lt;code&gt;group&lt;/code&gt; 中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Group {
        if Bool.random() {
            Image(&amp;quot;example-image&amp;quot;)
        } else {
            Text(&amp;quot;Better luck next time&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/2.8_return_view_in_group.png&#34; alt=&#34;2.8_return_view_in_group&#34; title=&#34;Return an image or a text in a group.&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-anyview&#34;&gt;2. AnyView&lt;/h3&gt;

&lt;p&gt;第二种方法，SwiftUI 提供了一个名为 &lt;code&gt;AnyView&lt;/code&gt; 的类型擦除包装器，我们可以返回这种类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: AnyView {
    if Bool.random() {
        return AnyView(Image(&amp;quot;example-image&amp;quot;))
    } else {
        return AnyView(Text(&amp;quot;Better luck next time&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.8_return_view_in_anyView.png&#34; alt=&#34;2.8_return_view_in_anyView.png&#34; title=&#34;Return an image or a text in an anyView.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你还没有听说过这个概念，它会强制让 Swift 忘记 &lt;code&gt;AnyView&lt;/code&gt; 中包含的特定类型，让它们看起来像是一样的东西。但这会降低性能，所以请不要经常使用它。
尽管 &lt;code&gt;Group&lt;/code&gt; 和 &lt;code&gt;AnyView&lt;/code&gt; 都为我们实现了相同的布局效果，但通常最好使用 &lt;code&gt;Group&lt;/code&gt;，因为它对 SwiftUI 效率更高。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.6_如何使用ZStack将视图叠加在一起</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/</link>
      <pubDate>Thu, 25 Jul 2019 13:26:52 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.6_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8zstack%E5%B0%86%E8%A7%86%E5%9B%BE%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7/</guid>
      <description>

&lt;p&gt;SwiftUI 有一个专用的 &lt;em&gt;stack&lt;/em&gt; 类型，用于创建重叠内容，例如，如果我们想在图片上放置一些文本，它就很有用。它被称为 &lt;code&gt;ZStack&lt;/code&gt;，其工作原理与其他两种 &lt;em&gt;stack&lt;/em&gt; 类型相同。&lt;/p&gt;

&lt;h3 id=&#34;1-在文本下面放置图片&#34;&gt;1. 在文本下面放置图片&lt;/h3&gt;

&lt;p&gt;例如: 我们可以在如下文本下面放置一个大图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    ZStack() {
        Image(&amp;quot;example-image&amp;quot;)
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(Color.black)
            .foregroundColor(.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.6_zstack_image_text.png&#34; alt=&#34;2.6_zstack_image_text&#34; title=&#34;Set zstack with a image and a text, image is below text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-对齐&#34;&gt;2. 对齐&lt;/h3&gt;

&lt;p&gt;与其它 &lt;em&gt;stack&lt;/em&gt; 类型一样，&lt;code&gt;ZStack&lt;/code&gt; 也可以设置对齐方式，这样它就不会总是将事物置于自身的中心位置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    ZStack(alignment: .leading) {
        Image(&amp;quot;example-image&amp;quot;)
            .resizable()
            .aspectRatio(contentMode: .fit)
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(Color.black)
            .foregroundColor(.white)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.6_zstack_alignment_leading.png&#34; alt=&#34;2.6_zstack_alignment_leading&#34; title=&#34;Set zstack&#39;s alignment as .leading&#34; /&gt;
但是，它没有 &lt;em&gt;spacing&lt;/em&gt; 属性，因为它实际上没有意义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.3_如何使用padding控制单个视图周围的间距</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/</link>
      <pubDate>Thu, 25 Jul 2019 11:39:45 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8padding%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D/</guid>
      <description>

&lt;p&gt;SwiftUI 允许我们使用 &lt;code&gt;padding()&lt;/code&gt; 修饰符在视图周围设置单独的填充。&lt;/p&gt;

&lt;h3 id=&#34;1-系统默认-padding&#34;&gt;1. 系统默认 padding&lt;/h3&gt;

&lt;p&gt;如果在不传参数的情况下使用 &lt;em&gt;padding()&lt;/em&gt; ，我们将在视图的四周获得系统默认填充，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            // 1. 系统默认 padding
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding()
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_system_default.png&#34; alt=&#34;2.3_padding_system_default&#34; title=&#34;Set padding with system default&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 这里默认设置了视图四周的填充。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-只设置一侧系统默认-padding&#34;&gt;2. 只设置一侧系统默认 padding&lt;/h3&gt;

&lt;p&gt;我们也可以自定义要应用的 填充 和 位置。因此，我们只希望将系统填充应用于一侧:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {  
            // 2. 只设置一侧填充
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding(.bottom)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_system_bottom.png&#34; alt=&#34;2.3_padding_system_bottom&#34; title=&#34;Set bottom padding with system default&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 这里只设置了底部填充，与上面的例子不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;3-用具体数值来设置-padding&#34;&gt;3. 用具体数值来设置 padding&lt;/h3&gt;

&lt;p&gt;我们可能希望控制对所有边应用了多少填充:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {  
            // 2. 只设置一侧填充
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding(100)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_100.png&#34; alt=&#34;2.3_padding_100&#34; title=&#34;Set padding as 100&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-在视图一侧添加特定数量的填充&#34;&gt;4. 在视图一侧添加特定数量的填充&lt;/h3&gt;

&lt;p&gt;我们也可以将这两者结合起来，在视图的一侧添加特定数量的填充：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
                .padding(.bottom, 100)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.3_padding_bottom_100.png&#34; alt=&#34;2.3_padding_bottom_100&#34; title=&#34;Set bottom padding as 100&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.2_如何通过alignment和spacing自定义stack布局</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 25 Jul 2019 10:54:52 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.2_%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87alignment%E5%92%8Cspacing%E8%87%AA%E5%AE%9A%E4%B9%89stack%E5%B8%83%E5%B1%80/</guid>
      <description>

&lt;h3 id=&#34;1-spacing&#34;&gt;1. &lt;code&gt;spacing&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以通过在 SwiftUI stacks 的构造方法中填一个值来设置间距，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 设置 spacing
        VStack(spacing: 50) {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.2_stack_spacing.png&#34; alt=&#34;2.2_stack_spacing&#34; title=&#34;Set a spacing for stack&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-divider&#34;&gt;2. &lt;code&gt;Divider&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以在项目之间创建分隔线，以便 SwiftUI 在 &lt;em&gt;stack&lt;/em&gt; 中的每个项目之间进行较小的视觉区分，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 设置 divider
        VStack {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Divider()
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.2_stack_divider.png&#34; alt=&#34;2.2_stack_divider&#34; title=&#34;Set a divider for stack&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-alignment&#34;&gt;3. &lt;code&gt;alignment&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;默认情况下，&lt;em&gt;stacks&lt;/em&gt; 中的项目居中对齐。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;em&gt;HStack&lt;/em&gt; 中: 项目在中间垂直对齐，因此如果有两个不同高度的文本视图，它们都将与垂直中心对齐。&lt;/li&gt;
&lt;li&gt;在 &lt;em&gt;VStack&lt;/em&gt; 中: 项目在中间水平对齐，因此如果有两个长度不同的文本视图，它们都将与水平中心对齐。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要调整这种情况，请在创建 &lt;em&gt;stack&lt;/em&gt; 时按以下方式传递一个 &lt;em&gt;alignment&lt;/em&gt; 参数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 设置 alignment
        VStack(alignment: .leading) {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.2_stack_alignment_leading.png&#34; alt=&#34;2.2_stack_alignment_leading&#34; title=&#34;Set alignment to .leading&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这将使 &lt;code&gt;Hello SwiftUI&lt;/code&gt; 和 &lt;code&gt;Hello M X&lt;/code&gt; 左对齐，但它们最终将位于屏幕的中间，因为 stack 只占用所需的空间。&lt;/p&gt;

&lt;h3 id=&#34;4-同时设置-alignment-和-spacing&#34;&gt;4.同时设置 &lt;code&gt;alignment&lt;/code&gt; 和 &lt;code&gt;spacing&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;我们可以同时使用 &lt;em&gt;alignment&lt;/em&gt; 和 &lt;em&gt;spacing&lt;/em&gt; ，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 同时设置 alignment 和 spacing
        VStack(alignment: .leading, spacing: 20) {
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;Hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/2.2_stack_alignment_spacing.png&#34; alt=&#34;2.2_stack_alignment_spacing&#34; title=&#34;Using alignment and spacing in stack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这将使两个文本视图水平对齐到 &lt;code&gt;leading&lt;/code&gt;（对于从左到右的语言是左对齐），并在它们之间放置20个点的垂直间距。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.1_如何使用VStack和HStack创建stacks</title>
      <link>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/</link>
      <pubDate>Thu, 25 Jul 2019 10:10:50 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/2-view_layout/2.1_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vstack%E5%92%8Chstack%E5%88%9B%E5%BB%BAstacks/</guid>
      <description>

&lt;p&gt;SwiftUI 的内容视图(content views)必须返回一个视图，即我们希望它们显示的视图。当我们想要一次性在屏幕上显示多个视图时，我们需要告诉 SwiftUI 如何排列它们，这就是 &lt;code&gt;堆栈（stacks）&lt;/code&gt;的来源。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;堆栈（Stacks）&lt;/code&gt; 相当于 UIKit 中的 &lt;strong&gt;UIStackView&lt;/strong&gt; 。有三种形式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;水平（HStack）&lt;/li&gt;
&lt;li&gt;垂直（VStack）&lt;/li&gt;
&lt;li&gt;基于深度（ZStack）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们想放置子视图以便它们重叠时可以使用后者。&lt;/p&gt;

&lt;h3 id=&#34;1-vstack&#34;&gt;1. VStack&lt;/h3&gt;

&lt;p&gt;让我们从一些简单的事情开始，先创建一个文本视图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            // 1. 创建一个文本视图
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.1_single_text.png&#34; alt=&#34;2.1_single_text&#34; title=&#34;A single text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们想在下面再放一个文本视图，我们不能只写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
    Text(&amp;quot;Hello M X&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话，编译器会直接报错。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;记住，我们只能返回一个视图，否则代码就不会工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么怎么办呢？我们需要将其放置在 &lt;code&gt;VStack&lt;/code&gt; 中，以便将文本视图放置在彼此上方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        VStack {
            // 2. 创建两个文本视图
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.1_two_text_in_vstack.png&#34; alt=&#34;2.1_two_text_in_vstack&#34; title=&#34;Two texts in VStack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;您会注意到: &lt;code&gt;VStack&lt;/code&gt; 位于屏幕的中心，标签也居中，并且它们之间有一些自动间隔。&lt;/p&gt;

&lt;h3 id=&#34;2-hstack&#34;&gt;2. HStack&lt;/h3&gt;

&lt;p&gt;如果我们希望文本视图并排水平放置，请使用如下方式将 &lt;code&gt;VStack&lt;/code&gt; 替换为 &lt;code&gt;HStack&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        HStack {
            // 3. 水平放置
            Text(&amp;quot;Hello SwiftUI&amp;quot;)
                .background(Color.red)
            Text(&amp;quot;hello M X&amp;quot;)
                .background(Color.blue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/2.1_two_text_in_hstack.png&#34; alt=&#34;2.1_two_text_in_hstack&#34; title=&#34;Two texts in HStack&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.9_如何使用图像和其它视图作为背景</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/</link>
      <pubDate>Wed, 24 Jul 2019 15:46:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.9_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%92%8C%E5%85%B6%E5%AE%83%E8%A7%86%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF/</guid>
      <description>

&lt;p&gt;我们可以使用相同的 &lt;code&gt;background()&lt;/code&gt; 修饰符来设置背景图像，而不是设置背景颜色。&lt;/p&gt;

&lt;h3 id=&#34;1-给文本视图设置图像背景&#34;&gt;1. 给文本视图设置图像背景&lt;/h3&gt;

&lt;p&gt;例如: 现在，我们要创建一个大字体的文本视图，然后在其后面放置一个 &lt;code&gt;100x100 的图像&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 设置图像背景
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(
                Image(&amp;quot;example-image&amp;quot;)
                    .resizable()
                    .frame(width: 100, height: 100)
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.9_background_image.png&#34; alt=&#34;1.9_background_image&#34; title=&#34;Set background with image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-给文本视图设置一个红色圆圈作为背景&#34;&gt;2. 给文本视图设置一个红色圆圈作为背景&lt;/h3&gt;

&lt;p&gt;在 SwiftUI 中，背景 View 并不一定是一个图像，实际上我们可以使用任何类型的视图作为背景。
例如: 现在将创建相同的文本视图，然后在其后面放置一个 &lt;code&gt;200x200 的红色圆圈&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 设置红色圆圈背景
        Text(&amp;quot;Hello SwiftUI&amp;quot;)
            .font(.largeTitle)
            .background(
                Circle()
                    .fill(Color.red)
                    .frame(width: 200, height: 200)
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.9_background_red_circle.png&#34; alt=&#34;1.9_background_red_circle&#34; title=&#34;Set background with a red circle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，背景视图会自动占用尽可能多的空间以完全可见，但如果需要，可以使用 &lt;code&gt;clipped(&lt;/code&gt;) 修饰符将其剪裁为父视图的大小：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Text(&amp;quot;Hello SwiftUI&amp;quot;)
        .font(.largeTitle)
        .background(
            Circle()
                .fill(Color.red)
                .frame(width: 200, height: 200)
                .clipped()
        )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.9_background_red_circle_clipped.png&#34; alt=&#34;1.9_background_red_circle_clipped&#34; /&gt;&lt;/p&gt;

&lt;p&gt;明确地说，您可以使用任何视图作为背景，例如，如果需要，可以使用另一个文本视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.8_如何显示几何形状</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/</link>
      <pubDate>Wed, 24 Jul 2019 15:46:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.8_%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6/</guid>
      <description>

&lt;p&gt;如果我们想在应用程序中使用简单的几何形状，我们可以直接创建它们，然后根据需要对它们进行着色和定位。&lt;/p&gt;

&lt;h3 id=&#34;1-矩形&#34;&gt;1. 矩形&lt;/h3&gt;

&lt;p&gt;例如，如果我们想要一个 &lt;code&gt;200x200&lt;/code&gt; 红色矩形，可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 200 * 200 红色矩形
        Rectangle()
            .fill(Color.red)
            .frame(width: 200, height: 200)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.8_square_red_wh200.png&#34; alt=&#34;1.8_square_red_wh200&#34; title=&#34;Square: 200 x 200&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-圆&#34;&gt;2. 圆&lt;/h3&gt;

&lt;p&gt;同样，如果你想要一个 &lt;code&gt;50x50&lt;/code&gt; 的蓝色圆圈，您可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 50 * 50 蓝色圆圈
        Circle()
            .fill(Color.blue)
            .frame(width: 50, height: 50)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.8_circle_blue_r50.png&#34; alt=&#34;1.8_circle_blue_r50&#34; title=&#34;Circle: 50 x 50&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.7_如何渲染渐变</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/</link>
      <pubDate>Wed, 24 Jul 2019 15:45:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.7_%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E6%B8%90%E5%8F%98/</guid>
      <description>

&lt;p&gt;SwiftUI 为我们提供了各种渐变选项（gradient options），所有这些选项都可以以各种方式来使用。例如:&lt;/p&gt;

&lt;h3 id=&#34;1-垂直线性渐变&#34;&gt;1. 垂直线性渐变&lt;/h3&gt;

&lt;p&gt;我们使用从白色到黑色的线性渐变来渲染文本视图，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 线性渐变: white -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .black]), startPoint: .top, endPoint: .bottom))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_vertical_white_black.png&#34; alt=&#34;1.7_gradient_vertical_white_black&#34; title=&#34;vertical gradient: white -&amp;gt; black&#34; /&gt;&lt;/p&gt;

&lt;p&gt;颜色被指定为一个数组，我们可以设置任意多我们想要的颜色 - 默认情况下，SwiftUI 将会平均分配这些颜色。所以，我们也可以这样从 白色 -&amp;gt; 红色 -&amp;gt; 黑色 来设置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2. 线性渐变: white -&amp;gt; red -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .top, endPoint: .bottom))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_vertical_white_red_black.png&#34; alt=&#34;1.7_gradient_vertical_white_red_black&#34; title=&#34;vertical gradient: white -&amp;gt; red -&amp;gt; black&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-水平线性渐变&#34;&gt;2. 水平线性渐变&lt;/h3&gt;

&lt;p&gt;要实现一个水平渐变（a horizontal gradient）而不是一个垂直渐变（a vertical one），使用 &lt;code&gt;.leading&lt;/code&gt; 和 &lt;code&gt;.trailing&lt;/code&gt; 来作为 &lt;em&gt;startPoint&lt;/em&gt; 和 &lt;em&gt;endPoint&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 水平线性渐变: white -&amp;gt; red -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .leading, endPoint: .trailing))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_horizontal_white_red_black.png&#34; alt=&#34;1.7_gradient_horizontal_white_red_black&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-对角线线性渐变&#34;&gt;3. 对角线线性渐变&lt;/h3&gt;

&lt;p&gt;要实现对角线渐变，可以使用 &lt;code&gt;.topLeading&lt;/code&gt; 和 &lt;code&gt;.bottomTrailing&lt;/code&gt; 作为 &lt;em&gt;startPoint&lt;/em&gt; 和 &lt;em&gt;endPoint&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 对角线性渐变: white -&amp;gt; red -&amp;gt; black
        Text(&amp;quot;Hello World&amp;quot;)
            .padding()
            .foregroundColor(.white)
            .background(LinearGradient(gradient: Gradient(colors: [.white, .red, .black]), startPoint: .topLeading, endPoint: .bottomTrailing))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_diagonal.png&#34; alt=&#34;1.7_gradient_diagonal&#34; title=&#34;diagonal gradient: white -&amp;gt; red -&amp;gt; black &#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-径向渐变&#34;&gt;4. 径向渐变&lt;/h3&gt;

&lt;p&gt;对于其他渐变样式，请尝试 &lt;code&gt;RadialGradient&lt;/code&gt; 或 &lt;code&gt;AngularGradient&lt;/code&gt;。
例如，这将创建一个从圆心开始到边缘的各种颜色的径向渐变:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 5. 径向渐变
        let colors = Gradient(colors: [.red, .yellow, .green, .blue, .purple])
        let conic = RadialGradient(gradient: colors, center: .center, startRadius: 50, endRadius: 200)
        return Circle()
            .fill(conic)
            .frame(width: 400, height: 400)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_radial.png&#34; alt=&#34;1.7_gradient_radial&#34; title=&#34;Radial gradient&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-角度渐变-圆锥梯度&#34;&gt;5. 角度渐变(圆锥梯度)&lt;/h3&gt;

&lt;p&gt;这就形成一个角梯度（通常称为圆锥梯度），通过各种颜色然后返回到开始循环:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 6. 圆锥梯度
        let colors = Gradient(colors: [.red, .yellow, .green, .blue, .purple, .red])
        let conic = AngularGradient(gradient: colors, center: .center)
        return Circle()
            .fill(conic)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_angular.png&#34; alt=&#34;1.7_gradient_angular&#34; title=&#34;Angular gradient&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-角度渐变-圆环&#34;&gt;6. 角度渐变(圆环)&lt;/h3&gt;

&lt;p&gt;由于所有三种渐变类型都符合 &lt;code&gt;ShapeStyle&lt;/code&gt; 协议，因此可以将它们用于背景，填充和笔触。 例如，这使用我们的彩虹圆锥形渐变作为圆的粗内部笔画：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 7. 圆环
        let colors = Gradient(colors: [.red, .yellow, .green, .blue, .purple, .red])
        let conic = AngularGradient(gradient: colors, center: .center, startAngle: .zero, endAngle: .degrees(360))
        return Circle()
            .strokeBorder(conic, lineWidth: 50)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.7_gradient_circle.png&#34; alt=&#34;1.7_gradient_circle&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.6_如何调整图像视图的填充模式</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:45:07 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.6_%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;img/1.6_ba_xian_tai.png&#34; alt=&#34;1.6_ba_xian_tai&#34; /&gt;
SwiftUI 的 &lt;code&gt;Image&lt;/code&gt; 视图能够以不同的方式进行缩放，就像 &lt;code&gt;UIImageView&lt;/code&gt; 的 &lt;strong&gt;content mode&lt;/strong&gt; 一样。&lt;/p&gt;

&lt;h3 id=&#34;1-默认&#34;&gt;1.默认&lt;/h3&gt;

&lt;p&gt;默认情况下，图像视图会根据其内容自动调整大小，这可能会使它们超出屏幕范围。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_the_default_content_mode.png&#34; alt=&#34;1.6_the_default_content_mode&#34; title=&#34;default content mode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果添加 &lt;code&gt;resizable()&lt;/code&gt; 修饰符，则图像将自动调整大小，以填充所有可用空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_resizable_image.png&#34; alt=&#34;1.6_resizable_image&#34; title=&#34;resizable image&#34; /&gt;
然而，这也可能导致图像的原始纵横比失真，因为它将在所有维度上被拉伸任意量，以使其填充空间。&lt;/p&gt;

&lt;h3 id=&#34;2-fill-和-fit&#34;&gt;2. &lt;code&gt;.fill&lt;/code&gt; 和 &lt;code&gt;.fit&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;如果要保持其纵横比，应使用 &lt;code&gt;.fill&lt;/code&gt; 或 &lt;code&gt;.fit&lt;/code&gt;添加一个&lt;code&gt;aspectRatio()&lt;/code&gt;修饰符，如下所示:&lt;/p&gt;

&lt;h4 id=&#34;2-1-fill&#34;&gt;2.1 fill&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
    .aspectRatio(contentMode: .fill)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_fill_content_mode.png&#34; alt=&#34;1.6_fill_content_mode&#34; title=&#34;content mode = .fill&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-2-fit&#34;&gt;2.2 fit&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(&amp;quot;ba_xian_tai&amp;quot;)
    .resizable()
    .aspectRatio(contentMode: .fit)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.6_fit_content_mode.png&#34; alt=&#34;1.6_fit_content_mode&#34; title=&#34;content mode = .fit&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.5_如何使用图像视图绘制图像</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:44:15 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.5_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</guid>
      <description>

&lt;p&gt;使用图像视图 &lt;code&gt;Image&lt;/code&gt; 可以在 SwiftUI 布局中渲染图像（images）。我们可以从 &lt;code&gt;Bundle&lt;/code&gt;、&lt;code&gt;System icons&lt;/code&gt;、&lt;code&gt;UIImage&lt;/code&gt; 等中加载图像，但这三个将是最常见的。&lt;/p&gt;

&lt;h3 id=&#34;1-从-bundle-加载&#34;&gt;1. 从 Bundle 加载&lt;/h3&gt;

&lt;p&gt;要从 Bundle 中加载图像并将其显示在图像视图中，只需使用以下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {
    Image(&amp;quot;example-image&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_load_image_from_bundle.png&#34; alt=&#34;1.5_load_image_from_bundle.png&#34; title=&#34;load image from buldle&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-从-system-icons-加载&#34;&gt;2. 从 System icons 加载&lt;/h3&gt;

&lt;p&gt;要从苹果旧金山符号集(Apple’s San Francisco Symbol set)中加载图标，请使用 &lt;code&gt;Image(systemName: )&lt;/code&gt; 初始化器，传入图标字符串进行加载，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_load_image_from_systemicon.png&#34; alt=&#34;1.5_load_image_from_systemicon&#34; title=&#34;load image from system icons&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-从-uiimage-加载&#34;&gt;3. 从 UIImage 加载&lt;/h3&gt;

&lt;p&gt;最后，可以从现有的 UIImage 创建一个图像视图。因为这需要更多的代码，所以需要显式地使用 return 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let image = UIImage(named: &amp;quot;example-image&amp;quot;) else {
    fatalError(&amp;quot;Unable to load image&amp;quot;)
}

return Image(uiImage: image)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_load_image_from_uiimage.png&#34; alt=&#34;1.5_load_image_from_uiimage&#34; title=&#34;load image from uiimage&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-通过-foregroundcolor-给系统图标着色&#34;&gt;4. 通过 foregroundColor 给系统图标着色&lt;/h3&gt;

&lt;p&gt;如果你使用的是 系统图标集，则返回的图像是 &lt;code&gt;可缩放&lt;/code&gt; 和 &lt;code&gt;可着色&lt;/code&gt; 的，这意味着你可以使用 &lt;code&gt;foregroundColor()&lt;/code&gt; 修改器对图像着色。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
    .foregroundColor(.red)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_foreground_color_image.png&#34; alt=&#34;1.5_foreground_color_image&#34; title=&#34;set foreground color for system icon&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-通过给系统图标设置动态文本样式来放大图像&#34;&gt;5. 通过给系统图标设置动态文本样式来放大图像&lt;/h3&gt;

&lt;p&gt;这意味着你可以通过匹配任何 &lt;code&gt;Dynamic Type&lt;/code&gt; 文本样式，来要求 SwiftUI 放大图像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &amp;quot;cloud.heavyrain.fill&amp;quot;)
    .font(.largeTitle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/1.5_font_largetitle_image.png&#34; alt=&#34;1.5_font_largetitle_image&#34; title=&#34;set font as largeTitle for system icons&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.4_如何格式化文本视图中的文本</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/</link>
      <pubDate>Wed, 24 Jul 2019 15:43:29 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.4_%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/</guid>
      <description>&lt;p&gt;SwiftUI 的文本视图有一个可选的 &lt;code&gt;formatter&lt;/code&gt; 参数，允许我们自定义数据在标签（label）中的显示方式。这一点很重要，因为在我们的程序中发生某些事情时，通常会为我们更新值，因此通过附加 &lt;code&gt;formatter&lt;/code&gt;， SwiftUI 可以确保我们的数据以我们期望的方式来正确显示。&lt;/p&gt;

&lt;p&gt;例如，我们定义了一个日期格式化程序（date formatter），并使用它来确保 任务日期 以人类可读的形式显示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftUI

struct ContentView: View {
    static let taskDateFormat: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        return formatter
    }()
    
    var dueDate = Date()
    
    var body: some View {
        Text(&amp;quot;Task due date: \(dueDate, formatter: Self.taskDateFormat)&amp;quot;)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.4_date_formatter_text.png&#34; alt=&#34;1.4_date_formatter_text.png&#34; title=&#34;date formatter&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.3_如何使用字体颜色行距等设置文本视图的样式</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Wed, 24 Jul 2019 15:42:28 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.3_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%A1%8C%E8%B7%9D%E7%AD%89%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F/</guid>
      <description>

&lt;!-- more --&gt;

&lt;p&gt;&lt;code&gt;Text&lt;/code&gt; 不仅在外观方面可以让我们进行可预测的广泛控制，而且它们还可以与 &lt;code&gt;Dynamic Type&lt;/code&gt; 等 Apple 的核心技术无缝协作。&lt;/p&gt;

&lt;h3 id=&#34;1-设置字体&#34;&gt;1. 设置字体&lt;/h3&gt;

&lt;p&gt;默认情况下，文本视图有一个 &lt;code&gt;Body&lt;/code&gt; 动态类型样式，但是我们可以通过以下方式调用 &lt;code&gt;.font()&lt;/code&gt;，从其它 &lt;em&gt;sizes&lt;/em&gt; 和 &lt;em&gt;weights&lt;/em&gt; 进行选择:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 1. 设置字体
        Text(&amp;quot;This is an extremely long text string that will never fit even the widest of Phones&amp;quot;)
            .font(.largeTitle)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_font_large_title.png&#34; alt=&#34;1.3_text_font_large_title&#34; title=&#34;Set a font for text&#34; /&gt;
我们现在在文本视图下面使用了两个修改器，这没关系 - 我们可以将它们堆叠起来，并且它们都会生效。&lt;/p&gt;

&lt;h3 id=&#34;2-设置文本对齐方式&#34;&gt;2. 设置文本对齐方式&lt;/h3&gt;

&lt;p&gt;特别是，现在我们有多行文本，我们需要调整文本的对齐方式，使其居中，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 2.设置文本对齐方式
        Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones&amp;quot;)
            .font(.largeTitle)
            .multilineTextAlignment(.center)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_alignment_center.png&#34; alt=&#34;1.3_text_alignment_center&#34; title=&#34;Set center alignment for text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-设置字体颜色&#34;&gt;3. 设置字体颜色&lt;/h3&gt;

&lt;p&gt;我们可以通过 &lt;code&gt;.foregroundColor()&lt;/code&gt; 修改器来设置文本颜色，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 3. 设置字体颜色
        Text(&amp;quot;The best laid plans&amp;quot;)
            .foregroundColor(.red)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_foregroundcolor.png&#34; alt=&#34;1.3_text_foregroundcolor&#34; title=&#34;Set a foreground color for text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-设置背景颜色&#34;&gt;4. 设置背景颜色&lt;/h3&gt;

&lt;p&gt;我们可以使用 &lt;code&gt;.background()&lt;/code&gt; 来设置背景颜色，但是它不仅仅可以用来设置背景颜色，也可以设置背景视图。无论如何，为了给我们的文本视图设置一个黄色背景，代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 4. 设置背景颜色
        Text(&amp;quot;The best laid plans&amp;quot;)
            .foregroundColor(.red)
            .background(Color.yellow)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_backgroundcolor.png&#34; alt=&#34;1.3_text_backgroundcolor&#34; title=&#34;Set a background color for text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-设置行间距&#34;&gt;5. 设置行间距&lt;/h3&gt;

&lt;p&gt;我们可以设置多行文本的行间距，行间距默认值为0，表示没有额外的行间距，但是我们可以通过以下方式在行与行之间指定一个值来添加额外的行间距。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {
    var body: some View {
        // 5.设置行间距
        Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones&amp;quot;)
            .font(.largeTitle)
            .lineSpacing(50)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.3_text_line_spacing.png&#34; alt=&#34;1.3_text_line_spacing&#34; title=&#34;Set a line spacing for text&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.2_如何使用 Text 创建静态标签</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-text-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Wed, 24 Jul 2019 13:35:01 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.2_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-text-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E6%A0%87%E7%AD%BE/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Text&lt;/code&gt; 主要用于在屏幕上显示静态文本，相当于 UIKit 中的 &lt;code&gt;UILabel&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;2-基本用法&#34;&gt;2. 基本用法&lt;/h3&gt;

&lt;p&gt;最基本的用法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;ContentView&lt;/code&gt; 的预览窗口中，我们可能会看到 &lt;code&gt;Automatic preview updating paused&lt;/code&gt;， 继续按 &lt;code&gt;Resume&lt;/code&gt; 以让 Swift 开始构建代码并向我们展示 &lt;code&gt;ContentView&lt;/code&gt; 外观的实时预览。&lt;/p&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_automatic_preview_updating_paused.png&#34; alt=&#34;1.2_automatic_preview_updating_paused&#34; title=&#34;Automatic preview updating paused, need to resume.&#34; /&gt;
&lt;img src=&#34;img/1.2_text_hello_world.png&#34; alt=&#34;1.2_text_hello_world&#34; title=&#34;Hello world&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-设置显示行数&#34;&gt;3. 设置显示行数&lt;/h3&gt;

&lt;p&gt;默认情况下，Text 视图会根据需要自动换行(包含尽可能多的行)，但是如果我们更希望限制它们可以使用的行数，则应该添加 &lt;code&gt;lineLimit&lt;/code&gt; 修改器，如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;Hello world&amp;quot;)
    .lineLimit(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 请注意 &lt;code&gt;lineLimit(3)&lt;/code&gt; 位于 &lt;code&gt;Text(&amp;quot;Hello World&amp;quot;)&lt;/code&gt; 下方靠右侧的方式。这不是必需的，但从长远来看，它确实使我们的代码更易于阅读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果对某些文本设置行限制，然后为其提供一个太长而不适合可用空间的字符串，SwiftUI将截断文本，使其以 &lt;code&gt;...&lt;/code&gt; 结尾。&lt;/p&gt;

&lt;p&gt;或者，我们可以为 &lt;code&gt;lineLimit()&lt;/code&gt; 方法指定 &lt;code&gt;nil&lt;/code&gt;，这样就允许它根据需要运行任意多行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones.&amp;quot;)
    .lineLimit(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_text_line_limit_nil.png&#34; alt=&#34;1.2_text_line_limit_nil&#34; title=&#34;lineLimit = nil&#34; /&gt;
&amp;gt; &lt;strong&gt;注意:&lt;/strong&gt; 这里设置 &lt;code&gt;lineLimit(0)&lt;/code&gt; 不能实现多行显示，这一点跟 UIKit 中是不一样的。&lt;/p&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_text_line_limit_0.png&#34; alt=&#34;1.2_text_line_limit_0&#34; title=&#34;lineLimit = 0&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-文本截断&#34;&gt;4. 文本截断&lt;/h3&gt;

&lt;p&gt;我们也可以调整 SwiftUI 截断文本的方式: 默认情况下，从末尾删除文本并在那里显示省略号，但也可以将省略号放在中间或开头，具体取决于字符串各个部分的重要程度。&lt;/p&gt;

&lt;p&gt;例如: 以下代码会在中间截断文本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&amp;quot;This is an extremely long string that will never fit even the widest of Phones.&amp;quot;)
    .lineLimit(0)
    .truncationMode(.middle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果预览:
&lt;img src=&#34;img/1.2_text_truncation_mode_middle.png&#34; alt=&#34;1.2_text_truncation_mode_middle&#34; title=&#34;truncationMode = middle&#34; /&gt;
不管我们如何截断文本，我们将看到文本视图始终位于主视图（main view）的中心。这是 SwiftUI 的默认行为 &amp;ndash; 除非我们明确告诉 SwiftUI 将视图定位到其它位置，否则 SwiftUI 会将视图定位到相对于屏幕中心的位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1.1_工程模板介绍</title>
      <link>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 23 Jul 2019 15:51:58 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/1-text_and_image/1.1_%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h3 id=&#34;1-简介&#34;&gt;1. 简介&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;img/1.1_swiftui_basic_template.png&#34; alt=&#34;1.1_swiftui_basic_template&#34; /&gt;
如图，自 Xcode 11 之后，基本的 单一视图应用程序(Single View App)模板 为我们提供以下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AppDelegate.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它负责监视外部事件。&lt;/li&gt;
&lt;li&gt;例如: 如果另一个应用程序试图向我们发送要一个要打开的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SceneDelegate.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它负责管理应用程序的显示方式。&lt;/li&gt;
&lt;li&gt;例如: 让多个实例同时运行，或者当一个实例移动到后台时采取操作/措施。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContentView.swift&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是我们最初的用户界面。&lt;/li&gt;
&lt;li&gt;如果这是一个 UIKit 项目，它就相当于 Xcode 提供给我们的 &lt;strong&gt;ViewController&lt;/strong&gt; 类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Assets.xcassets&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是项目的资产目录。&lt;/li&gt;
&lt;li&gt;存储着我们项目中使用的所有图像和颜色。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LaunchScreen.storyboard&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是在我们的应用加载时显示的屏幕。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Info.plist&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它是一个属性列表文件，用于存储应用程序的系统级设置。&lt;/li&gt;
&lt;li&gt;例如: 应该在 iOS 主屏幕上的图标下面显示什么名称。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preview content&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;它是一个名为 &lt;strong&gt;Preview content&lt;/strong&gt; 的组，其中包含另一个名为 &lt;strong&gt;Preview Assests&lt;/strong&gt; 的资产目录。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就是这样 - 只有少量的代码和资源，这意味着我们可以在此基础上进行构建。&lt;/p&gt;

&lt;h3 id=&#34;2-查看-scenedelegate&#34;&gt;2. 查看 SceneDelegate&lt;/h3&gt;

&lt;p&gt;事实上，我们真正关心的、也是唯一重要的部分是 &lt;code&gt;ContentView.swift&lt;/code&gt;。这是我们应用程序的主要功能，在这里我们可以立即开始尝试各种 &lt;code&gt;SwiftUI&lt;/code&gt; 代码。&lt;/p&gt;

&lt;p&gt;不过，我们首先要弄清楚的是: 是什么让 &lt;em&gt;ContentView.swift&lt;/em&gt; 显示在屏幕上?
上面我们提到: &lt;code&gt;SceneDelegate.swift&lt;/code&gt; 负责管理应用程序的显示方式。那么，我们打开 &lt;code&gt;SceneDelegate.swift&lt;/code&gt;，就会看到下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create the SwiftUI view that provides the window contents.
let contentView = ContentView()

// Use a UIHostingController as window root view controller.
if let windowScene = scene as? UIWindowScene {
    let window = UIWindow(windowScene: windowScene)
    window.rootViewController = UIHostingController(rootView: contentView)
    self.window = window
    window.makeKeyAndVisible()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码创建了一个新的 &lt;code&gt;ContentView&lt;/code&gt; 实例（这是我们即将看到的主要功能），并将其放置在窗口中，以便在屏幕上显示。通过显示 &lt;code&gt;ContentView&lt;/code&gt; 的第一个实例，可以有效地引导我们的应用程序，并从那里结束 - 那么接下来你想做什么？&lt;/p&gt;

&lt;h3 id=&#34;3-查看-contentview&#34;&gt;3. 查看 ContentView&lt;/h3&gt;

&lt;p&gt;打开  &lt;code&gt;ContentView.swift&lt;/code&gt; ，让我们看看一些实际的 SwiftUI 代码。我们应该可以看到这样的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftUI

struct ContentView: View {
    var body: some View {
        Text(&amp;quot;Hello World&amp;quot;)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不是很多代码，但它实际上包含了大量代码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，请注意，&lt;code&gt;ContentView&lt;/code&gt; 是一个结构体。熟悉 UIKit 的开发人员都知道 - 我们从用户界面的所有值类型的不变性和简单性中获益巨大！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其次，&lt;code&gt;ContentView&lt;/code&gt; 遵守 &lt;code&gt;View&lt;/code&gt; 协议。我们想在 SwiftUI 中显示的所有内容都需要遵守 &lt;code&gt;View&lt;/code&gt; 协议，这实际上只意味着一件事: 我们需要一个名为 &lt;code&gt;body&lt;/code&gt; 的属性来返回 &lt;code&gt;some View&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三，&lt;code&gt;body&lt;/code&gt; 的返回类型是 &lt;code&gt;some View&lt;/code&gt;。&lt;code&gt;some&lt;/code&gt; 关键字是在 Swift 5.1 中新引入的，是一个名为 &lt;strong&gt;不透明返回类型（opaque return types）&lt;/strong&gt; 功能的一部分，在这种情况下，它的意思是 将返回某种视图，但 SwiftUI 不需要知道（或关心）什么。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;重要说明:&lt;/strong&gt; 返回 &lt;code&gt;some View&lt;/code&gt; 意味着 &lt;code&gt;body&lt;/code&gt; 属性将返回遵守 &lt;code&gt;View&lt;/code&gt; 协议的内容。我们不能返回很多东西或忘记返回任何东西，否则，Swift 编译器将拒绝构建我们的代码。为了清楚起见，我们的视图 body 必须始终返回一个子视图。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第四，body 属性中有 &lt;code&gt;Text(&amp;quot;hello world&amp;quot;)&lt;/code&gt;，它创建了文本内容为 &amp;ldquo;hello world&amp;rdquo; 的标签。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，在 ContentView 下面的是一个类似但不同的 struct，称为 &lt;code&gt;ContentView_Previews&lt;/code&gt;。它不遵守 &lt;code&gt;View&lt;/code&gt; 协议，因为它专门用于在 Xcode 中显示 视图预览（Preview），而不是在真正的应用程序中显示在屏幕上。这就是为什么你会看到它在 &lt;code&gt;#if DEBUG&lt;/code&gt; 和 &lt;code&gt;#endif&lt;/code&gt; 之间 - 当我们的应用程序在调试环境中运行时，这段代码只构建在 成品（finished product）中，因为它在生产应用程序（Production app）中没有意义。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
