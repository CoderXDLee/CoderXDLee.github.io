<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Forms on M X</title>
    <link>https://coderxdlee.github.io/tags/forms/</link>
    <description>Recent content in Forms on M X</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>M X ©{year}</copyright>
    <lastBuildDate>Fri, 02 Aug 2019 00:37:07 +0800</lastBuildDate>
    
	    <atom:link href="https://coderxdlee.github.io/tags/forms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>6.2_基本表单设计</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 02 Aug 2019 00:37:07 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.2_%E5%9F%BA%E6%9C%AC%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;p&gt;SwiftUI 的 &lt;code&gt;表单(forms)&lt;/code&gt; 用作容器，就像 &lt;code&gt;HStack&lt;/code&gt; 和 &lt;code&gt;VStack&lt;/code&gt; 一样，这意味着您可以根据需要在其中添加其它视图。 但是，它们会自动调整某些控件的行为和样式，以便它们更好地适应表单环境。
例如，这将创建一个带有 _toggle_、&lt;em&gt;segmentedControl&lt;/em&gt; 和 &lt;em&gt;button&lt;/em&gt; 的表单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView : View {
    
    @State var enableLogging = false
    @State var selectedColor = 0
    @State var colors = [&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;]
    
    var body: some View {
        NavigationView {
            Form {
                SegmentedControl(selection: $selectedColor) {
                    ForEach(0..&amp;lt;colors.count) {
                        Text(self.colors[$0]).tag($0)
                    }
                }
                Toggle(isOn: $enableLogging) {
                    Text(&amp;quot;Enable logging!&amp;quot;)
                }
                Button(action: {
                    // activate theme!
                }) {
                    Text(&amp;quot;Save changes&amp;quot;)
                }
            }
            .navigationBarTitle(Text(&amp;quot;Settings&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果:
&lt;img src=&#34;img/6.3_forms_basic_design.gif&#34; alt=&#34;6.3_forms_basic_design&#34; /&gt;
当代码运行时，您将看到两件对表单行为至关重要的事情：
在 iOS 上，表单自动采用分组列表的样式，因此用户可以看到滚动选项。
这个按钮已经调整了自己，看起来像一个可操作的列表行——左对齐，蓝色。
您可以根据需要在表单中包含尽可能多的行，但如果需要超过10，请记住使用组。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.1_表单的使用介绍</title>
      <link>https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 02 Aug 2019 00:21:32 +0800</pubDate>
      
      <guid>https://coderxdlee.github.io/post/swiftui/6-forms/6.1_%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;!-- more --&gt;

&lt;p&gt;由于 SwiftUI 将重点放在声明性用户界面上，因此它为我们提供了一种构建表单的奇妙机制——用于收集信息的用户输入控件集合，例如订单或设置界面。
更好的是，SwiftUI 的几个部分会自动适应放置在表单中——它们的外观和行为会发生变化，因此它们可以更好地与其他输入控件组一起工作。
如果你认为这很聪明，你会喜欢这个: SwiftUI 实际上动态地调整布局，以便它可以根据你的代码运行的平台自动为我们制作全新的屏幕 - 它完全解耦了目的 我们的视觉控制。 这意味着我们描述了我们想要的东西，SwiftUI 找出了在当前平台上实现这一目标的惯用方法。
提示：&lt;code&gt;Form&lt;/code&gt; 和 &lt;code&gt;VStack&lt;/code&gt; 一样是常规的容器，因此您可以根据自己的目的在这两者之间自由切换。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
